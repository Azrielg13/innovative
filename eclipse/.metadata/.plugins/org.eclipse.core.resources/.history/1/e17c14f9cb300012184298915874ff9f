/**
 *           | Master Data Interface Version 2.0 |
 *
 * Copyright (c) 2002-2007, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team.
 * 	                   All rights reserved.
 *
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package com.sce.esp.object.model;

import java.io.Serializable;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Collection;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.TreeSet;
import java.util.Vector;

import javax.persistence.Entity;
import javax.persistence.NamedNativeQueries;
import javax.persistence.NamedNativeQuery;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;
import javax.swing.Icon;

import com.sce.esp.object.dao.AbankDAO;
import com.sce.esp.util.Calculate;
import com.sce.esp.util.IconsFactory;
import com.sce.esp.util.db.PDBConnection;
@Entity
@Table(schema="MDI",name="MDI107_ABANK_V")
@NamedQueries({
	@NamedQuery(name = "findByID", query="SELECT o FROM Abank o WHERE o.PLANYEAR=?1 AND o.ABANK_SUB_ID=?2"),//AUTO-GENERATED
	@NamedQuery(name = "findAll", query="SELECT o FROM Abank o"),//AUTO-GENERATED
	@NamedQuery(name = "findAllActive", query="SELECT o FROM Abank o WHERE o.DELETED_TS IS NULL"),//AUTO-GENERATED
})
@NamedNativeQueries({
	@NamedNativeQuery(name = "refresh", query="SELECT o.* FROM MDI107_ABANK_V o WHERE o.PLANYEAR=? AND o.ABANK_SUB_ID=?"),//AUTO-GENERATED
})
public class Abank extends AbankDAO implements Serializable{

	private static final long serialVersionUID = -3676881245163467040L;

	/**
	 * The Constructor.
	 *
	 * @param planyear
	 *            the planyear
	 */
	public Abank(){
	}
	public Abank(int planyear){
		super(planyear,0);
	}
	
	/**
	 * The Constructor.
	 *
	 * @param id
	 *            the id
	 * @param planYear
	 *            the plan year
	 *
	 * @throws SQLException
	 *             the SQL exception
	 */
	public Abank(int planYear, int subId)throws SQLException{
		super(planYear,subId);
	}

	public Abank(Abank abank) {
		super(abank);
	}

	/**
	 * Gets the level.
	 *
	 * @return the level
	 */
	public int getLevel(){
		return ABANK_SUB;
	}
	
	public int getCoTypeId(){
		return CoType.ABANK;
	}

	/**
	 * Gets the year.
	 *
	 * @param simId
	 *            the sim id
	 * @param year
	 *            the year
	 *
	 * @return the year
	 *
	 * @throws SQLException
	 *             the SQL exception
	 */
	public AbankYear getYear(int simId, int year)throws SQLException{
		return getYear(simId,year,true);
	}
	public AbankYear getYear(int simId, int year, boolean fetch)throws SQLException{
		return AbankYear.getInstance(getPlanyear(),simId,getSubId(),year,fetch);
	}

	/**
	 * This method returns a treeset of abank ties. There is a single abank tie
	 * object for any time that a child of this abank ties to a child of another
	 * abank. A collection of bbank to and from ties is also created for the
	 * abank tie.
	 *
	 * @param simId
	 *            the sim id
	 *
	 * @return a TreeSet containing <code>ParentTie</code> objects.
	 *
	 * @throws Exception
	 *             the exception
	 * @throws SQLException
	 */
	public TreeSet<ParentTie> getParentTies(int simId)throws Exception{
		Hashtable<Integer,ParentTie> abanks = new Hashtable<Integer,ParentTie>();
		for(int i=getPlanyear()-1; i<getPlanyear()+User.getActiveUser().getPlanFor(getPlanyear(),simId); i++) {
			for(BbankTie tie : ((AbankYear)getYear(simId,i)).getToTies()) {
				Abank abank = ((BbankYear)tie.getFromSub().getYear(simId,i)).getAbank();
				if(this!=abank && abank!=null) {
					if(!abanks.containsKey(abank.getId()))
						abanks.put(abank.getId(),new ParentTie(this,abank,simId));
					abanks.get(abank.getId()).addToTie(tie);
				}
			}
			for(BbankTie tie : ((AbankYear)getYear(simId,i)).getFromTies()) {
				Abank abank = ((BbankYear)tie.getToSub().getYear(simId,i)).getAbank();
				if(this!=abank && abank!=null) {
					if(!abanks.containsKey(abank.getId()))
						abanks.put(abank.getId(),new ParentTie(this,abank,simId));
					abanks.get(abank.getId()).addFromTie(tie);
				}
			}
		}
		return new TreeSet<ParentTie>(abanks.values());
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.Sub#getAllEverSubVars()
	 */
	public TreeSet<SubVar> getAllEverSubVars(int simId)throws SQLException{
		TreeSet<SubVar> subVars = new TreeSet<SubVar>(getSubVars(simId));
		for(Bbank bbank : getBbanks(0,SubFilter.CORE_SUB)) {
			for(SubVar subVar : bbank.getSubVars(simId)) {
				if(subVar.isHighSide())
					subVars.add(subVar);
			}
		}
		return subVars;
	}

	/**
	 * Gets the weather stations.
	 *
	 * @return a <code>Weatherstation</code> collection
	 *
	 * @throws SQLException
	 *             the SQL exception
	 */
	public TreeSet<Weatherstation> getWeatherStations()throws SQLException{
		TreeSet<Weatherstation> weatherstations = new TreeSet<Weatherstation>();
		for(int year=getPlanyear()-1; year<getPlanyear()+Department.getInstance(getPlanyear()).getPlanFor();year++)
			weatherstations.addAll(getYear(0, year).getWeatherStations());
		return weatherstations;
	}

	/**
	 * Gets the weatherstations by instance.
	 *
	 * @return the weatherstations by instance
	 *
	 * @throws SQLException
	 *             the SQL exception
	 */
	public Vector<Weatherstation> getWeatherStationsByInstance()throws SQLException{
		Vector<Weatherstation> weatherstations = new Vector<Weatherstation>();
		for(Bbank bBank:getYear(0,getPlanyear()-1).getBbanks(SubFilter.IN_SERVICE_SUB)){
			for(Weatherstation ws:bBank.getWeatherStations())
				weatherstations.add(ws);
		}
		return weatherstations;
	}



	/**
	 * Gimme percent instance.
	 *
	 * @param ws
	 *            the ws
	 *
	 * @return the double
	 *
	 * @throws SQLException
	 *             the SQL exception
	 *
	 * @see com.sce.esp.object.model.CoreObject#getPercentInstance(com.sce.esp.object.model.Weatherstation)
	 */
	public double getPercentInstance(Weatherstation ws) throws SQLException {
		double pi = 0;
		for(Weatherstation ws2: getWeatherStationsByInstance())
			if(ws == ws2)
				pi++;
		return Calculate.round(pi/getWeatherStationsByInstance().size()*100,1);
	}

	/**
	 * Gets the coin child flag.
	 *
	 * @param simId
	 *            the sim id
	 *
	 * @return the coin child flag
	 *
	 * @throws SQLException
	 *             the SQL exception
	 */
	public int getCoinChildFlag(int simId) throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.COIN_FLAG);
		if(getPeakDailyPeak(simId)!=null && flag!=null && !flag.isDisabled() && flag.isShowFlag()) {
			double childsum = 0;

			TreeSet<Bbank> bbanks = getYear(simId,getPlanyear()-1).getBbanks(SubFilter.IN_SERVICE_SUB);
			if(bbanks.size()==0)
				return 0;

			for(Sub sub:bbanks)
				if(sub.getSubType().isLoadServer())
					childsum += sub.getDailyPeak(getPeakDate(simId)).getActualPeak()*sub.getDailyPeak(getPeakDate(simId)).getCoinFactor();

			double parent = getPeakDailyPeak(simId).getActualPeak();
			if(parent==0 || Math.abs((childsum/parent)-1) > flag.getValue())
				return flag.getFlagId();
		}
		return 0;
	}

	/**
	 * Gets the var reserve flag.
	 *
	 * @param simId
	 *            the sim id
	 *
	 * @return the var reserve flag
	 *
	 * @throws SQLException
	 *             the SQL exception
	 */
	public int getVarReserveFlag(int simId)throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.VAR_RESERVE_SYS_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()){
			for(int y=getPlanyear(); y<getPlanyear()+User.getActiveUser().getPlanFor(getPlanyear(),simId); y++){
				if(getYear(simId, y).getVarReserveFlag()>0)
					return flag.getFlagId();
			}
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the Total Non-Coincident Child Load
	 * is < the Parent Load for a given year.
	 *
	 * @param simId
	 *            the sim id
	 *
	 * @return - flag id or 0
	 *
	 * @throws SQLException
	 *             the SQL exception
	 */
	public int getNonCoinChildFlag(int simId) throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.NON_COIN_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()) {

			TreeSet<Bbank> bbanks = getYear(simId,getPlanyear()-1).getBbanks(SubFilter.IN_SERVICE_SUB);
			if(bbanks.size()==0)
				return 0;

			double childsum = 0;

			for(Bbank bbank:bbanks)
				if(bbank.getSubType().isLoadServer())
					childsum += bbank.getStartingPoint(simId);

//			System.out.println(" sp "+getNormStartingPoint(simId) + " > " + childsum + " * " + flag.getValue() + " = "+ (childsum * flag.getValue()));
			
			if(getNormStartingPoint(simId) > childsum * flag.getValue())
				return flag.getFlagId();
		}
		return 0;
	}

	/**
	 * Gets the icon.
	 *
	 * @return the icon
	 */
	public Icon getIcon(){
		try {
			if(getStatus(0).equalsIgnoreCase(Sub.OUT_OF_SERVICE))
				return IconsFactory.getOverlayIcon(null,
						IconsFactory.getImageIcon(IconsFactory.Tree.ABANK),
						IconsFactory.getImageIcon("icons/overlay_error.png"),
						IconsFactory.ICON_BBANK.getIconWidth()-12,
						IconsFactory.ICON_BBANK.getIconHeight()-12);
		} catch (SQLException e) {			
			e.printStackTrace();
		}
		return IconsFactory.ICON_ABANK;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.Sub#getInsertStatus()
	 */
	public Vector<String> getInsertStatus(){
		Vector<String> errors = new Vector<String>();
		return errors;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getChildren(int)
	 */
	public Collection<Bbank> getChildren(int simId)throws SQLException{
		return getChildren(simId, SubFilter.CORE_SUB);
	}
	/*
	 * (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getChildren(int, com.sce.mdi.object.SubFilter)
	 */
	public Collection<Bbank> getChildren(int simId, SubFilter sf)throws SQLException {
		return getBbanks(simId, sf);
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getPYInstance(int)
	 */
	public Abank getPlanYearInstance(int planyear)throws SQLException{
		return getInstance(planyear,getSubId());
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getPaTotal(int)
	 */
	public int getPaTotal(int simId){
		return 1;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getPaFin(int)
	 */
	public int getPaFin(int simId) throws SQLException{
		return getSimSub(simId).isPaFinalized()?1:0;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getPaApp(int)
	 */
	public int getPaApp(int simId) throws SQLException{
		return getSimSub(simId).isPaApproved()?1:0;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getLgTotal(int)
	 */
	public int getLgTotal(int simId){
		return 1;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getLgFin(int)
	 */
	public int getLgFin(int simId) throws SQLException{
		return getSimSub(simId).isLgFinalized()?1:0;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getLgApp(int)
	 */
	public int getLgApp(int simId) throws SQLException{
		return getSimSub(simId).isLgApproved()?1:0;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getCsTotal(int)
	 */
	public int getCsTotal(int simId){
		return 0;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getCsFin(int)
	 */
	public int getCsFin(int simId) throws SQLException{
		return 0;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getCsApp(int)
	 */
	public int getCsApp(int simId) throws SQLException{
		return 0;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getN1Fin(int)
	 */
	public int getN1Fin(int simId) throws SQLException{
		int count=0;
		for(Sys sys:getSyss(simId))
			if(sys.isN1Finalized())
				count++;
		return count;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getN1App(int)
	 */
	public int getN1App(int simId) throws SQLException{
		int count=0;
		for(Sys sys:getSyss(simId))
			if(sys.isN1Approved())
				count++;
		return count;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getN1Total(int)
	 */
	public int getN1Total(int simId) throws SQLException{
		return getSyss(simId).size();
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getVarFin(int)
	 */
	public int getVarFin(int simId) throws SQLException{
		int count=0;
		for(Sys sys:getSyss(simId))
			if(sys.isStvFinalized())
				count++;
		return count;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getVarApp(int)
	 */
	public int getVarApp(int simId) throws SQLException{
		int count=0;
		for(Sys sys:getSyss(simId))
			if(sys.isStvApproved())
				count++;
		return count;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getVarTotal(int)
	 */
	public int getVarTotal(int simId) throws SQLException{
		return getSyss(simId).size();
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.Sub#setN1Approved(boolean)
	 */
	public void setN1Approved(boolean state) throws SQLException {
		for(Sys sys:getSyss(0))
			sys.setN1Approved(state);
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.Sub#setN1Finalized(boolean)
	 */
	public void setN1Finalized(boolean state) throws SQLException {
		for(Sys sys:getSyss(0))
			sys.setN1Finalized(state);
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.Sub#setVarApproved(boolean)
	 */
	public void setVarApproved(boolean state) throws SQLException {
		for(Sys sys:getSyss(0))
			sys.setStvApproved(state);
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.Sub#setVarFinalized(boolean)
	 */
	public void setVarFinalized(boolean state) throws SQLException {
		for(Sys sys:getSyss(0))
			sys.setStvFinalized(state);
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.Sub#getLgProjs(int)
	 */
	public TreeSet<LgProj> getLgProjs(int simId) throws SQLException {
		TreeSet<LgProj> lgProjs = new TreeSet<LgProj>();
		for(Bbank bb : getBbanks(simId))
			for(LgProj lg : bb.getLgProjs(simId))
				lgProjs.add(lg);
		return lgProjs;
	}
	
	public TreeSet<SceProjRev> getSceProjRevsCostYr(int simId, Collection<Program> progs,int projStatuses,int costYear) throws SQLException {
		TreeSet<SceProjRev> sceProjRevs = new TreeSet<SceProjRev>();
		for(Sub sub : getDownStreamSubs(simId)) {
			for(SceProjElemCost spec : sub.getSceProjElemCosts()) {
				if(spec.getCost(costYear) > 0){
					SceProjRev rev = spec.getSceProjRev().getSceProj().getCurRev(getPlanyear(), simId);
					if(rev != null && (progs == null || progs.contains(rev.getProgram())) && (rev.getProjectStatus() & projStatuses) > 0)
						sceProjRevs.add(rev);
				}
			}
		}
		return sceProjRevs;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getPifs()
	 */
	public TreeSet<Pif> getPifs() throws SQLException {
		TreeSet<Pif> v = new TreeSet<Pif>();
		for(Bbank bb : getBbanks(0))
			for(Pif p : bb.getPifs())
				v.add(p);
		return v;
	}
	/**
	 * Gets the coin child total proj load, on the peak day of the parent 
	 *
	 * @return the coin child total proj load MVA
	 *
	 * @throws SQLException the SQL exception
	 */
	public double getCoinChildTotalProjLoad(int simId) throws SQLException {
		double childsum = 0;
		for(Bbank b: getYear(simId, getPlanyear()-1).getBbanks(SubFilter.IN_SERVICE_SUB))
			if(b.getSubType().isLoadServer())
				childsum += b.getDailyPeak(getPeakDate(simId),true).getActualPeak()*b.getDailyPeak(getPeakDate(simId),true).getCoinFactor();
		return childsum;
	}
	public double getVarARequired(int simId, int year) throws SQLException {
		return getYear(simId, year).getTotalVarReq();
	}
	public double getVarASupply(int simId, int year) throws SQLException {
		return getYear(simId, year).getTotalVarSupply();
	}
	public double getVarBRequired(int simId, int year) throws SQLException {
		return getYear(simId, year).getBBankTotFieldReq() + getYear(simId, year).getBBankTotStationReq();
	}
	public double getVarBSupply(int simId, int year) throws SQLException {
		return getYear(simId, year).getBBankTotFieldReq() + getYear(simId, year).getBBankTotStationSupply();
	}
	public double getVarAReserved(int simId, int year) throws SQLException {
		return getVarASupply(simId, year) - getVarARequired(simId, year);
	}
	public double getVarBReserved(int simId, int year) throws SQLException {
		return getVarBSupply(simId, year) - getVarBRequired(simId, year);
	}
	public AutomatedEquipment getCoinParent() {
		return null;
	}
	public CoType getCoType() throws SQLException{
		return CoType.getInstance(CoType.ABANK);
	}
	public TreeSet<Stl> getStls(Calendar asOf, int simId)throws SQLException{
		SceProjElemCost last = getMostRecentSceProjElemCost(asOf,simId);
		if(last != null)
			return last.getStlsPost(getPlanyear(),simId);
		return new TreeSet<Stl>();
	}
	public TreeSet<Stl> getStlsInService(Calendar asOf,int simId)throws SQLException{
		SceProjElemCost last = getMostRecentSceProjElemCostInService(asOf);
		if(last != null)
			return last.getStlsPost(getPlanyear(),simId);
		return new TreeSet<Stl>();
	}

	@Override
	public double getPRN(int simId) throws SQLException {
		return getSimSub(simId).getPRN();
	}

	@Override
	public double getNormPRN(int simId) throws SQLException {
		return getSimSub(simId).getNormPRN();
	}

	@Override
	public boolean isPRNEditable(int simId) throws SQLException {
		return getSimSub(simId).isPRNEditable();
	}

	@Override
	public double getAltPRN(int simId) throws SQLException {
		return getSimSub(simId).getAltPRN();
	}
	
	@Override
	public Abank getPrevInstance() throws SQLException {
		return getInstance(getPlanyear()-1,getAbankSubId());
	}
	public void insert() throws SQLException{
		if(isNewInstance()){
			super.insert();
			String table = Bbank.class.getAnnotation(Table.class).name();
			table = table.substring(0, table.length()-2);
			PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement("INSERT INTO MDI107_ABANK(PLANYEAR,ABANK_SUB_ID,Q_LOSS_NOTE,COND_NOTE,STL_FINALIZED,STL_APPROVED,VAR_NOTE) VALUES(?,?,?,?,?,?,?)");
			int x=1;
			ps.setInt(x++, getPlanyear());
			ps.setInt(x++, getSubId());
			ps.setString(x++, getQLossNote());
			ps.setString(x++, getCondNote());
			ps.setBoolean(x++, isStlFinalized());
			ps.setBoolean(x++, isStlApproved());
			ps.setString(x++, getVarNote());
			try{
				ps.executeUpdate();
			}finally{
				ps.close();
			}
		}
		insertChildren();
	}
	
	private Tbank tbank;
	
	public Tbank getTbank() {
		if(tbank==null)
			tbank = new Tbank(this);
		return tbank;
	}
	
	public static Collection<Tbank> getTbanks()throws java.sql.SQLException{
		Collection<Tbank> t = new LinkedList<Tbank>();
		Collection<Abank> a = Abank.getCollection(new String[]{"PLANYEAR","SUB_TYPE_ID"},Department.getActivePlanYear(), 11);
		for(Abank ab: a)
			t.add(ab.getTbank());		
		return t;
	}
	
	public static Collection<Abank> getFacilityObjects() throws SQLException{
		
		 Collection<Abank>  ab = Abank.getCollection(new String[]{"PLANYEAR"},Department.getActivePlanYear());
		 ab.removeAll(Abank.getCollection(new String[]{"PLANYEAR","SUB_TYPE_ID"},Department.getActivePlanYear(), SubType.T));
		 return ab;
	}
	
}
