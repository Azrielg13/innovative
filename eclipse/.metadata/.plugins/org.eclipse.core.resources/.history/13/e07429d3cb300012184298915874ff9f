/*
 * Copyright (c) 2002-2010 ESP Suite. All Rights Reserved.
 *
 *     
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Authors: Technology Integration Group, SCE
 * Developers: Eddie Mayfield, Frank Gonzales, Augustin Muniz,
 * Kate Suwan, Hiro Kushida, Andrew McNaughton, Brian Stonerock,
 * Russell Ragsdale, Patrick Ridge, Everett Aragon.
 * 
 */
package com.sce.esp.hst;

import java.io.Serializable;


/**
 * <p>Title: NeuralNetwork</p>
 * <p>Description: Neural Network for Forecasting.</p>
 * 
 * @author Distribution Staff Engineering
 * @version 2.0
 */
public class NeuralNetwork implements Serializable {	
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -6895624049690254056L;
	private int numberOfHiddenUnit;		 //Number of hidden units
	private int numberOfInputUnit;		 //Number of input units
	private int numberOfOutputUnit;		 //Number if output units
	private int outputActivationType;    //Output unit activation type
										 // 0 - linear activation function
										 // 1 -sigomid activation function

	private double rate          = 0.5;	  // Learning rate
	private double alpha         = 0.1;   // Momentum term
	private int    epochs        = 10000;  // Maximum Epochs
	private double errorTolerant = 0.001; // Quit if error drops this low

	public double[] inputs ;			  // Input values
	public double[] outputs;			  // Output Values
	public double[] targets = null;		  // Target Values
	public double[] hiddens = null;		  // Hidden values

	private double[][] weightLayer1;      //Weights of first layer
	private double[][] momentum1;		  //Momentums of first layer
	private double[][] weightLayer2;	  //Weights of first layer
	private double[][] momentum2;		  //Momentums of first layer

	private double maxInput[];
	private double minInput[];
	private double inputScaleMax=1;
	private double inputScaleMin=0;

	private double maxOutput[]= null;
	private double minOutput[]= null;
	private double outputScaleMax=1;
	private double outputScaleMin=0;

	private DataSet ds;

	/**
	 * 
	 * @param ds
	 * @param type
	 * @param nodes
	 * @param epochs
	 * @param rate
	 * @param alpha
	 * @param tolerant
	 */
	public NeuralNetwork(DataSet ds,int type, int nodes,int epochs,double rate,double alpha,double tolerant){
        	this.ds=ds;
			this.numberOfHiddenUnit = nodes;
        	this.outputActivationType = type;
        	this.epochs= epochs;
        	this.rate= rate;
			this.alpha=alpha;
        	this.numberOfInputUnit= ds.inputs;
        	this.numberOfOutputUnit= ds.outputs;
			this.errorTolerant=tolerant;
	}

    public double sigmoid(double x) {
        if (x >  50.) return 1.0;
        if (x < -50.) return 0.0;
        return 1.0 /(1.0+Math.exp(-x));
    }

	/**
	 * Sigmiod function derivative
	 */
    public double sigmoidDerivative(double x) {
		return x*(1.0-x);
    }

	/**
	 * Least-squared Error Function
	 */
    public double errorFunction (double[] x, double[] y) {
        double sum = 0.0;
        for (int i=0; i<x.length; i++) {
            sum += (x[i] - y[i])*(x[i] - y[i]);
        }
        return 0.5 * sum;
    }

	/**
	 * Feed-forward pass
	 */
    void feedforward() {
		//For hidden units
		for (int i = 0; i<numberOfHiddenUnit; i++) {
            double sum = 0.0;
            for (int j=0; j<numberOfInputUnit+1; j++) {
                if (j==numberOfInputUnit)
                    sum += weightLayer1[j][i]; // Include the Bias term
                else
                    sum += weightLayer1[j][i]*inputs[j];
            }
            hiddens[i] = sigmoid(sum);
        }
		//For output units
        for (int i = 0; i<numberOfOutputUnit; i++) {
            double sum =0.0;
            for (int j=0; j<numberOfHiddenUnit; j++) {
                sum += weightLayer2[j][i]*hiddens[j];
            }
            outputs[i] = sigmoid(sum);
        }
    }

    /**
     * Weight backpropagation
     */
    private void backpropagation(double rate, double alpha) {
        double[] delta1 = new double[numberOfHiddenUnit];
        double[] delta2 = new double[numberOfOutputUnit];

        for (int j=0; j<numberOfOutputUnit; j++) {
            delta2[j] = targets[j] - outputs[j];
        }

        for (int j=0; j<numberOfHiddenUnit; j++) {
            double sum = 0.0;
            for (int k=0; k<numberOfOutputUnit; k++) {
                double term = delta2[k] * weightLayer2[j][k];
                if (outputActivationType==1) term *=sigmoidDerivative(outputs[k]);
                sum += term;
            }
            delta1[j] = sum;
        }

		for (int i=0; i<numberOfHiddenUnit; i++) {
            for (int j=0; j<numberOfOutputUnit; j++) {
                double delta = delta2[j]*hiddens[i];
                if (outputActivationType==1) {
                    delta *= sigmoidDerivative(outputs[j]);
                }
				double weightChange = rate * delta +alpha*momentum2[i][j];
                weightLayer2[i][j] += weightChange;
                momentum2[i][j] = weightChange;
            }
        }

        for (int i=0; i<numberOfInputUnit+1; i++) {
            for (int j=0; j<numberOfHiddenUnit; j++) {
                if (i!=numberOfInputUnit && inputs[i]==0) {
                    momentum1[i][j] = 0.;
                }
                else {
                    double delta = delta1[j]*sigmoidDerivative(hiddens[j]);
                    if (i!=numberOfInputUnit) delta *= inputs[i];
					double weightChange = rate * delta +alpha*momentum1[i][j];
		            weightLayer1[i][j] += weightChange;
			        momentum1[i][j] = weightChange;
                }
            }
        }

    }

    public void train () {
        int allRows = ds.getRows();
        int nrows   = allRows;

        maxInput = new double[numberOfInputUnit+1];
        minInput    = new double[numberOfInputUnit+1];
        for (int i = 0; i<numberOfInputUnit ; i++) {
            maxInput[i] = ds.maxInput[i];
            minInput[i] = ds.minInput[i];
        }
        maxOutput = new double[numberOfOutputUnit];
        minOutput = new double[numberOfOutputUnit];
        for (int i = 0; i<numberOfOutputUnit ; i++) {
            maxOutput[i]    = ds.maxOutput[i];
            minOutput[i]    = ds.minOutput[i];
        }

        inputScaleMax = ds.inputScaleMax;
        inputScaleMin = ds.inputScaleMin;
        outputScaleMax = ds.outputScaleMax;
        outputScaleMin = ds.outputScaleMin;

        hiddens  = new double[numberOfHiddenUnit];
        outputs  = new double[numberOfOutputUnit];

        weightLayer1 = new double[numberOfInputUnit+1][numberOfHiddenUnit];
        momentum1 = new double[numberOfInputUnit+1][numberOfHiddenUnit];
        weightLayer2 = new double[numberOfHiddenUnit][numberOfOutputUnit];
        momentum2 = new double[numberOfHiddenUnit][numberOfOutputUnit];

        ds.scaledPredictValues = new double[allRows][numberOfOutputUnit];
        ds.predictValues = new double[allRows][numberOfOutputUnit];

        for (int i=0; i<numberOfHiddenUnit; i++) {
            for (int j =0; j <numberOfInputUnit+1; j++) weightLayer1[j][i] = randomWeight();
            for (int j =0; j <numberOfOutputUnit;  j++) weightLayer2[i][j] = randomWeight();
        }

        for (int i=0; i < epochs; i++) {
			ds.randomize(nrows);
             double error=0;
			 for (int j=0; j<nrows; j++) {
                inputs = ds.getScaledRandomInputRow(j);
                targets = ds.getScaledRandomOutputRow(j);
                feedforward();
				backpropagation(rate, alpha);
                for (int k = 0; k<numberOfOutputUnit; k++) {
                    ds.scaledPredictValues[j][k] = outputs[k];
                }
				error += errorFunction(targets,outputs);
            }
			error =error/nrows;
			//System.out.println("epoch:"+i+ "     error :"+error);//

			// Quit if error within the tolerant
			if(error<errorTolerant){
				//System.out.println("epoch:"+i);
				break;
			}
			//Print the epoch if it out of limit.
			if(i==epochs-1){
				//System.out.println("epoch:"+i);
				break;
			}

        }

        for (int j=0; j<allRows; j++) {
            inputs = ds.getScaledInputRow(j);
            feedforward();
            for (int k = 0; k<numberOfOutputUnit; k++) {
                ds.scaledPredictValues[j][k] = outputs[k];
            }
        }
        ds.unscalePrediction();
    }

    public void predict () {
        hiddens  = new double[numberOfHiddenUnit];
        outputs  = new double[numberOfOutputUnit];

        ds.maxInput = new double[numberOfInputUnit+1];
        ds.minInput  = new double[numberOfInputUnit+1];
        for (int i = 0; i<numberOfInputUnit+1 ; i++) {
            ds.maxInput[i]   = maxInput[i];
            ds.minInput[i]   = minInput[i];
        }
        ds.maxOutput = new double[numberOfOutputUnit];
        ds.minOutput = new double[numberOfOutputUnit];
        for (int i = 0; i<numberOfOutputUnit ; i++) {
            ds.maxOutput[i]  = maxOutput[i];
            ds.minOutput[i]  = minOutput[i];
        }
        ds.inputScaleMax = inputScaleMax;
        ds.inputScaleMin = inputScaleMin;
        ds.outputScaleMax = outputScaleMax;
        ds.outputScaleMin = outputScaleMin;
        ds.normalize(inputScaleMin, inputScaleMax,outputScaleMin,outputScaleMax);

		int allRows = ds.getRows();

        for (int j=0; j<allRows; j++) {
            inputs = ds.getScaledInputRow(j);
            feedforward();
            for (int k = 0; k<numberOfOutputUnit; k++) {
                ds.scaledPredictValues[j][k] = outputs[k];
            }
        }
        ds.unscalePrediction();
    }

    public double randomWeight() {
        return (double) (2.*Math.random() - 1.);
    }

    //Getter and Setters
	public int getNodes() {
		return numberOfHiddenUnit;
	}
	public int getType() {
		return outputActivationType;
	}
	public int getInputs() {
		return numberOfInputUnit;
	}
	public int getOutputs() {
		return numberOfOutputUnit;
	}
	public void setNodes(int i) {
		numberOfHiddenUnit = i;
	}
	public void setType(int i) {
		outputActivationType = i;
	}
	public void setInputs(int i) {
		numberOfInputUnit = i;
	}
	public void setOutputs(int i) {
		numberOfOutputUnit = i;
	}

	public void setDataSet(DataSet ds) {
		this.ds = ds;
	}

   	public void printTuning() {
        System.out.println("Weights:");
        for (int i=0; i<numberOfInputUnit+1; i++) {
            for (int j=0; j<numberOfHiddenUnit; j++) {
                System.out.println("weight for input "+i+" for hidden layer node "+j+" = "+weightLayer1[i][j]);
            }
        }
        for (int i=0; i<numberOfHiddenUnit; i++) {
            for (int j=0; j<numberOfOutputUnit; j++) {
                System.out.println("weight for hidden layer node "+i+" for output "+j+" = "+weightLayer2[i][j]);
            }
        }

        System.out.println("Scales:");
        System.out.println("Input Scale Maximum, Minimum "+inputScaleMax+","+inputScaleMin);
        for (int i =0; i<numberOfInputUnit+1 ; i++) {
            System.out.println("Input "+i+" Maximum, Minimum = "+maxInput[i]+","+minInput[i]);
        }

        System.out.println("Output Scale Maximum, Minimum "+outputScaleMax+","+outputScaleMin);
        for (int i =0; i<numberOfOutputUnit ; i++) {
            System.out.println("Output "+i+" Maximum, Minimum = "+maxOutput[i]+","+minOutput[i]);
        }
   }
}//END CLASS