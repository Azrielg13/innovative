/*
 * Copyright (c) 2002-2010 ESP Suite. All Rights Reserved.
 *
 *     
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Authors: Technology Integration Group, SCE
 * Developers: Eddie Mayfield, Frank Gonzales, Augustin Muniz,
 * Kate Suwan, Hiro Kushida, Andrew McNaughton, Brian Stonerock,
 * Russell Ragsdale, Patrick Ridge, Everett Aragon.
 * 
 */
package com.sce.esp.hst;

import java.sql.SQLException;
import java.util.Calendar;
import java.util.Vector;

import com.sce.esp.object.jpa.EntityManagerHelper;
import com.sce.esp.object.model.Department;
import com.sce.esp.object.model.ForecastHour;
import com.sce.esp.object.model.ForecastWeather;
import com.sce.esp.object.model.Sub;
import com.sce.esp.object.model.SubDaily;
import com.sce.esp.object.model.Weatherstation;
import com.sce.esp.util.Calculate;
import com.sce.esp.util.ESPProperties;
import com.sce.esp.util.FormatText;
import com.sce.esp.util.db.PDBConnection;

/**
 *
 *
 * @author Distribution Staff Engineering
 * @version 2.0
 */
public class ForecastSub extends NeuralNetForecast{
	private Sub sub;
	private Calendar cal;
	private Vector<Double> lrValues=null;
	private ForecastWeather[] day=null;

	public ForecastSub(Sub sub, Calendar cal){
		this.sub=sub;
		this.cal=cal;
	}
	public Sub getSub(){
		return sub;
	}
	
	public Calendar getDate(){
		return cal;
	}
	
	/**
	 * @see com.sce.mdi.hst.ann.nnf.NeuralNetForecast#runANN()
	 */
	@Override
	public void runANN() throws SQLException{
		
		String[][] trainingSet = new String[14][4];
		Calendar startDate  = (Calendar)cal.clone();
		startDate.add(Calendar.DATE, -14);
		for(int i = 0; i<14; i++){
			SubDaily d = SubDaily.getInstance(sub.getPlanyear(), sub.getSubId(), startDate);
			trainingSet[i][0] = FormatText.MYSQL_DATE.format(startDate.getTime());
			trainingSet[i][1] = d.getTemperature().getMinTemp()+"";
			trainingSet[i][2] = d.getTemperature().getMaxTemp()+"";
			trainingSet[i][3] = d.getActualPeak()*d.getLSE().getMVAFactor()+"";			
			startDate.add(Calendar.DATE, 1);
		}
		trainANN(new Effect(), trainingSet);		
		
		trainingSet = new String[15][4];
		startDate  = (Calendar)cal.clone();
		startDate.add(Calendar.DATE, -16);
		for(int i = 0; i<15; i++){
			SubDaily d = SubDaily.getInstance(sub.getPlanyear(), sub.getSubId(), startDate);
			trainingSet[i][0] = FormatText.MYSQL_DATE.format(startDate.getTime());
			trainingSet[i][1] = d.getTemperature().getMinTemp()+"";
			trainingSet[i][2] = d.getTemperature().getMaxTemp()+"";
			trainingSet[i][3] = d.getActualPeak()*d.getLSE().getMVAFactor()+"";
			startDate.add(Calendar.DATE, 1);
		}
		
		try {
			testTraining(new Effect(), trainingSet);
		} catch (Exception e) {			
			e.printStackTrace();
		}
		
		trainingSet = new String[5][4];
		getNoaaForecast();
		if(day!=null){
			Calendar c = Calendar.getInstance();
			for(int i = 0; i<day.length;i++){				
				trainingSet[i][0] = FormatText.MYSQL_DATE.format(c.getTime());				
				trainingSet[i][1] = day[i].getMinT()+"";
				trainingSet[i][2] = day[i].getEffTemp()+"";
				trainingSet[i][3] = getLRForecast().get(i)+"";//
				c.add(Calendar.DATE,1);
			}
			try {
				predict(new Effect(), trainingSet);
			} catch (Exception e) {			
				e.printStackTrace();
			}
		}		
	}


	//====================================================================
	//Linear Regression Forecast - Actual Model
	//====================================================================
	/**
	 * Need to complete/implement BJS algorithm
	 * 
	 * @return a collection of values in MVA
	 */
	public Vector<Double> getLRForecast() throws SQLException{
		if(lrValues==null)
			refreshLRForecast();

		if(cal.getTimeInMillis() < Calculate.getCal().getTimeInMillis()){
			//System.out.println("Calendar is less than today's calendar instance");
			lrValues = new Vector<Double>();			
			lrValues.add(getDayOne());
			lrValues.add(getDayTwo());
			lrValues.add(getDayThree());
			lrValues.add(getDayFour());
			lrValues.add(getDayFive());
			return lrValues;
		}
		return lrValues;		
	}
	
	private void refreshLRForecast() throws SQLException{
		System.out.println("refreshLRForecast called");
		lrValues = new Vector<Double>();
		getNoaaForecast();
		double calc=0;
		if(!(day==null)){
			Calendar c1 = (Calendar)cal.clone();
			Calendar c2= (Calendar)cal.clone();
			for(int dayNum=0;dayNum<5;dayNum++){

				c1.add(Calendar.DATE, -1+dayNum);
				c2.add(Calendar.DATE, 0+dayNum);

				if(dayNum==0){
					calc=(1+((day[dayNum].getEffTemp()-
							sub.getDailyPeak(c1).getTemperature().getEffTemp())*
								sub.getYear(0, FormatText.getCalendarYear(cal)).getSens()));
					//get yesterday's recorded peak	
					//System.out.println("Value:"+sub.getDailyPeak(c1).getRecordedPeak());
					lrValues.add(sub.getDailyPeak(c1).getRecordedPeak()*calc);
					//or else use a fake number
					//values.add(2000*calc);
					
					//System.out.println("Day "+(dayNum+1)+"=========>");
					//System.out.println(sub.getDailyPeak(c1).getRecordedPeak()*calc);
				}else{
					calc=(1+((day[dayNum].getEffTemp()- 
							day[dayNum-1].getEffTemp())*
							sub.getYear(0, FormatText.getCalendarYear(cal)).getSens()));
					//System.out.println("Day "+(dayNum+1)+"=========>");
					//System.out.println("calc=(1+("+day[dayNum].getEffTemp()+"- "+day[dayNum-1].getEffTemp()+")*"+sub.getYear(0, FormatText.getCalendarYear(cal)).getTempSens()+")) = "+calc);
							
					lrValues.add(lrValues.get(dayNum-1)*calc);
				}
			}
		}else{
			for(int dayNum=0;dayNum<5;dayNum++){
				lrValues.add(0.0);
			}
		}
	}

	private void getNoaaForecast() throws SQLException{
		//int count=0;
		for(Weatherstation w: sub.getWeatherStationsByInstance()){
			//System.out.println("Obtaining forecast for "+w);
			//if(count==0){
				if(w.getLatitude()>0 && w.getLongitude()<0){
					day = w.getNoaaForecast();
					//count++;					
				}
			//}
		}
	}

	//====================================================================
	//Linear Regression Forecast - Historical Test Model
	//====================================================================
	public double getDayOne() throws SQLException{
		Calendar c1 = (Calendar)cal.clone();
		Calendar c2= (Calendar)cal.clone();
		c1.add(Calendar.DATE, -1);
		c2.add(Calendar.DATE, 0);
		double calc=(1+((sub.getDailyPeak(c2).getTemperature().getEffTemp()-
				sub.getDailyPeak(c1).getTemperature().getEffTemp())*
				sub.getYear(0, FormatText.getCalendarYear(cal)).getSens()));

		return Math.round(sub.getDailyPeak(c1).getRecordedPeak())*calc;
	}

	public double getDayTwo() throws SQLException{
		Calendar c1 = (Calendar)cal.clone();
		Calendar c2= (Calendar)cal.clone();
		c1.add(Calendar.DATE, 0);
		c2.add(Calendar.DATE, 1);
		double calc=(1+((sub.getDailyPeak(c2).getTemperature().getEffTemp()-
				sub.getDailyPeak(c1).getTemperature().getEffTemp())*
				sub.getYear(0, FormatText.getCalendarYear(cal)).getSens()));

		return Math.round(getDayOne())*calc;
	}

	public double getDayThree() throws SQLException{
		Calendar c1 = (Calendar)cal.clone();
		Calendar c2= (Calendar)cal.clone();
		c1.add(Calendar.DATE, 1);
		c2.add(Calendar.DATE, 2);
		double calc=(1+((sub.getDailyPeak(c2).getTemperature().getEffTemp()-
				sub.getDailyPeak(c1).getTemperature().getEffTemp())*
				sub.getYear(0, FormatText.getCalendarYear(cal)).getSens()));	
		return Math.round(getDayTwo())*calc;
	}

	public double getDayFour() throws SQLException{
		Calendar c1 = (Calendar)cal.clone();
		Calendar c2= (Calendar)cal.clone();
		c1.add(Calendar.DATE, 2);
		c2.add(Calendar.DATE, 3);
		double calc=(1+((sub.getDailyPeak(c2).getTemperature().getEffTemp()-
				sub.getDailyPeak(c1).getTemperature().getEffTemp())*
				sub.getYear(0, FormatText.getCalendarYear(cal)).getSens()));

		return Math.round(getDayThree())*calc;
	}

	public double getDayFive() throws SQLException{
		Calendar c1 = (Calendar)cal.clone();
		Calendar c2= (Calendar)cal.clone();
		c1.add(Calendar.DATE, 3);
		c2.add(Calendar.DATE, 4);
		double calc=(1+((sub.getDailyPeak(c2).getTemperature().getEffTemp()-
				sub.getDailyPeak(c1).getTemperature().getEffTemp())*
				sub.getYear(0, FormatText.getCalendarYear(cal)).getSens()));

		return Math.round(getDayFour())*calc;
	}
	
	public String toString(){
		return sub.toString();
	}
	
	/* (non-Javadoc)
	 * @see com.sce.mdi.hst.NeuralNetForecast#getPLL()
	 */
	public double getPLL() throws SQLException {	
		return getSub().getDailyPeak(cal).getPLL();
	}
	
	public static void main(String[] args) {
		try {
			EntityManagerHelper.init(ESPProperties.getInstance().getDevDbUrl(), "gonzalf1", "edison");
			Sub s = Sub.getInstance(Department.getActivePlanYear(), 461, true);
			ForecastSub fs = new ForecastSub(s,Calendar.getInstance());
			System.out.println("Getting weather stations for "+s);
			for(Weatherstation w: fs.getSub().getYear(0, s.getPlanyear()).getWeatherStations()){
				System.out.println("Attempting connection for "+w);
				for(ForecastHour fh: w.getHourlyForecast(Calendar.getInstance()))
					System.out.println(fh);
			}			
		} catch (Exception e) {			
			e.printStackTrace();
		}
	}
}