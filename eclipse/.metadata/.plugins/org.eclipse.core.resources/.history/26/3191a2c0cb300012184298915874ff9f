/*
 * Copyright (c) 2002-2010 ESP Suite. All Rights Reserved.
 *
 *     
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Authors: Technology Integration Group, SCE
 * Developers: Eddie Mayfield, Frank Gonzales, Augustin Muniz,
 * Kate Suwan, Hiro Kushida, Andrew McNaughton, Brian Stonerock,
 * Russell Ragsdale, Patrick Ridge, Everett Aragon.
 * 
 */
package com.sce.esp.component;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;

import javax.swing.Icon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableModel;

import com.jidesoft.grid.HierarchicalTable;
import com.jidesoft.grid.HierarchicalTableComponentFactory;
import com.jidesoft.grid.TableModelWrapperUtils;
import com.jidesoft.swing.StyleRange;
import com.sce.esp.form.ESPForm;
import com.sce.esp.security.TopFlight;
import com.sce.esp.util.ESPRow.ESPCurrency;
import com.sce.esp.util.ESPDate;
import com.sce.esp.util.ESPMonth;
import com.sce.esp.util.ESPRow.ESPPercent;
import com.sce.esp.util.StringNoEdit;

public class ESPHierarchicalTable extends HierarchicalTable implements ESPTable {

	/**
	 * 
	 */
	private static final long serialVersionUID = -3776465389212494867L;
	private int userLevel;

	/**
	 * The Constructor.
	 * 
	 * @param model
	 *            the model
	 * @param tsp
	 *            the tsp
	 * @param tableType
	 *            the table type
	 */
	public ESPHierarchicalTable(int userLevel) {
		super();
		this.userLevel = userLevel;

		setAutoscrolls(true);
		setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
		setPreferredScrollableViewportSize(new Dimension(400, 400));

		// New Section
		setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		setHierarchicalColumn(-1);
		setSingleExpansion(false);
		setGridColor(Color.gray.brighter());
		setRowHeight(18);
		getSelectionModel().addListSelectionListener(
				new ListSelectionListener() {
					public void valueChanged(ListSelectionEvent e) {
						if (getSelectedRow() != -1) {
							expandRow(getSelectedRow());
						}
					}
				});
		setComponentFactory(new HierarchicalTableComponentFactory() {
			/*
			 * Hand off from ComponentFactory to Row for ESPHierarchicalTable
			 * through the ESPHierarchicalTableModel
			 */
			public Component createChildComponent(HierarchicalTable table,
					Object value, int row) {
				if (value instanceof Component)
					return (Component) value;
				return null;
			}
			public void destroyChildComponent(HierarchicalTable table,
					Component component, int row) {
			}
		});
		getSelectionModel().setAnchorSelectionIndex(0);
		getSelectionModel().setLeadSelectionIndex(0);

		setCellEditorManagerEnabled(false);
		setCellRendererManagerEnabled(false);

		setDefaultEditor(JButton.class, new ESPCellEditor(1));
		setDefaultEditor(JComponent.class, new ESPCellEditor(1));
		setDefaultEditor(String.class, new ESPCellEditor(2));
		setDefaultEditor(StringNoEdit.class, new ESPCellEditor(1));
		setDefaultEditor(ESPDate.class, new ESPCellEditor(2));
		setDefaultEditor(ESPMonth.class, new ESPCellEditor(2));
		setDefaultEditor(ESPCurrency.class, new ESPCellEditor(1));
		setDefaultEditor(ESPPercent.class, new ESPCellEditor(1));
		putClientProperty("terminateEditOnFocusLost", Boolean.TRUE);
	}

	/**
	 * 
	 */
	public void setValueAt(Object value, int row, int col) {
		if (getColumnClass(col) == Number.class
				|| getColumnClass(col).getSuperclass() == Number.class) {
			if (value == null)
				value = 0;
			double pvalue = 0;
			if (getValueAt(row, col) != null)
				pvalue = Double.parseDouble(getValueAt(row, col).toString());
			if (value.equals(pvalue))
				return;
		} else if (value == getValueAt(row, col)
				|| (value != null && getValueAt(row, col) != null && value
						.equals(getValueAt(row, col))))
			return;

		super.setValueAt(value, row, col);
	}

	/**
	 * Gets the wrapped row at.
	 * 
	 * @param row
	 *            the row
	 * 
	 * @return the wrapped row at
	 */
	public int getWrappedRowAt(int row) {
		return TableModelWrapperUtils.getActualRowAt(getModel(), row);
	}

	public Class<?> getColumnClass(int column) {
		return getHierarchicalTableModel().getColumnClass(
				convertColumnIndexToModel(column));
	}

	/**
	 * Gets the cell renderer.
	 * 
	 * @param col
	 *            the col
	 * @param row
	 *            the row
	 * 
	 * @return the cell renderer
	 */
	public TableCellRenderer getCellRenderer(int row, int col) {
		return ESPForm.cr;
	}

	/**
	 * Gets the column at.
	 * 
	 * @param col
	 *            the col
	 * 
	 * @return the column at
	 */
	public int getColumnAt(int col) {
		String name = getColumnName(col);
		TableModel model = getModel();
		for (int x = 0; x < model.getColumnCount(); x++)
			if (name.equals(model.getColumnName(x)))
				return x;
		return 0;
	}

	/**
	 * Gets the ESP Hierarchical table model.
	 * 
	 * @return the MDI <code>TreeTableModel</code>
	 */
	protected ESPHierarchicalTableModel getHierarchicalTableModel() {
		return (ESPHierarchicalTableModel) TableModelWrapperUtils
				.getActualTableModel(getModel(),
						ESPHierarchicalTableModel.class);
	}

	/**
	 * Gets the font.
	 * 
	 * @param col
	 *            the col
	 * @param row
	 *            the row
	 * 
	 * @return the font
	 */
	public Font getFont(int row, int col) {
		try {
			Font font = ((ESPHierarchicalRow) getHierarchicalTableModel()
					.getRowAt(getWrappedRowAt(row))).getFont(getColumnAt(col));
			if (font != null)
				return font;
		} catch (ClassCastException e) {
			e.printStackTrace();
		}
		return getFont();
	}

	/**
	 * Gets the foreground.
	 * 
	 * @param col
	 *            the col
	 * @param row
	 *            the row
	 * 
	 * @return the foreground
	 */
	public Color getForeground(int row, int col) {
		try {
			Color color = ((ESPHierarchicalRow) getHierarchicalTableModel()
					.getRowAt(getWrappedRowAt(row)))
					.getForeground(getColumnAt(col));
			if (color != null)
				return color;
		} catch (ClassCastException e) {
			e.printStackTrace();
		}
		return getForeground();
	}

	/**
	 * Gets the background.
	 * 
	 * @param col
	 *            the col
	 * @param row
	 *            the row
	 * 
	 * @return the background
	 */
	public Color getBackground(int row, int col) {
		try {
			Color color = ((ESPHierarchicalRow) getHierarchicalTableModel()
					.getRowAt(getWrappedRowAt(row)))
					.getBackground(getColumnAt(col));
			if (color != null)
				return color;
		} catch (ClassCastException e) {
			e.printStackTrace();
		}
		return getBackground();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.sce.mdi.component.MDITable#getIcon(int, int)
	 */
	public Icon getIcon(int row, int col) {
		int aRow = getWrappedRowAt(row);
		int aCol = getColumnAt(col);
		try {
			return ((ESPExpandableRow) getHierarchicalTableModel()
					.getRowAt(aRow)).getIcon(aCol);
		} catch (ClassCastException e) {
			e.printStackTrace();
		}
		return null;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.sce.mdi.component.MDITable#getToolTip(int, int)
	 */
	public String getToolTip(int row, int col) {
		int aRow = getWrappedRowAt(row);
		int aCol = getColumnAt(col);
		try {
			return ((ESPExpandableRow) getHierarchicalTableModel()
					.getRowAt(aRow)).getToolTip(aCol);
		} catch (ClassCastException e) {
			e.printStackTrace();
		}
		return null;
	}

	/**
	 * Gets the style.
	 * 
	 * @param col
	 *            the col
	 * @param row
	 *            the row
	 * 
	 * @return the style
	 */
	public StyleRange getStyle(int row, int col) {
		try {
			if (this.getHierarchicalTableModel().getRowAt(getWrappedRowAt(row)) instanceof ESPHierarchicalRow) {
				StyleRange sr = ((ESPHierarchicalRow) getHierarchicalTableModel()
						.getRowAt(getWrappedRowAt(row)))
						.getStyle(getColumnAt(col));
				if (sr != null)
					return sr;
			}
		} catch (ClassCastException e) {
			e.printStackTrace();
		}
		return null;
	}

	public boolean isCellEditable(int row, int col) {
		if (getColumnClass(col) != StringNoEdit.class
				&& getColumnClass(col) != JButton.class) {
			try {
				if (!TopFlight.getInstance().hasAccessRight(userLevel))
					return false;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		// Changed by BJS on 3/25
		// return getHierarchicalTableModel().isCellEditable(row, col);
		return super.isCellEditable(row, col);
	}

	public String getTitle() {
		return null;
	}

	public void setTitle() {

	}

	public ESPTableScrollPane getTableScrollPane() {
		return null;
	}

	// @Override
	public void invalidateCache() {
	}
}
