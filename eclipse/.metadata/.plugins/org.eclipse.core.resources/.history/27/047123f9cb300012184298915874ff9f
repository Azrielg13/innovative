/**
 *           | Master Data Interface Version 2.0 |                       
 * 
 * Copyright (c) 2006, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team. 					  
 * 	                   All rights reserved.
 * 
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
package com.sce.esp.object.model;
import java.io.Serializable;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Hashtable;

import javax.persistence.Entity;
import javax.persistence.NamedNativeQueries;
import javax.persistence.NamedNativeQuery;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;

import com.sce.esp.object.dao.DuctBankDAO;
@Entity
@Table(schema="MDI",name="MDI700_DUCT_BANK")
@NamedQueries({
	@NamedQuery(name = "findByID", query="SELECT o FROM DuctBank o WHERE o.PLANYEAR=?1 AND o.DB_ID=?2"),//AUTO-GENERATED
	@NamedQuery(name = "findAll", query="SELECT o FROM DuctBank o"),//AUTO-GENERATED
	@NamedQuery(name = "findAllActive", query="SELECT o FROM DuctBank o WHERE o.DELETED_TS IS NULL"),//AUTO-GENERATED
	@NamedQuery(name = "findByBbank", query="SELECT o FROM DuctBank o WHERE o.PLANYEAR=?1 AND o.BBANK_SUB_ID=?2 AND o.DELETED_TS IS NULL"),//AUTO-GENERATED
})
@NamedNativeQueries({
	@NamedNativeQuery(name = "refresh", query="SELECT o.* FROM MDI700_DUCT_BANK o WHERE o.PLANYEAR=? AND o.DB_ID=?"),//AUTO-GENERATED
})
public class DuctBank extends DuctBankDAO implements Serializable{
	
	private static final long serialVersionUID = -5056741682206381419L;

	/** The hot hash. */
	private Hashtable<String,double[]> hotHash = new Hashtable<String,double[]>();
	
	/** The rt temps. */
	private double[] rtTemps;
	
	/** The sim temps. */
	private double[] simTemps;
	
	/** The no trans temps. */
	private double[] noTransTemps;
	
	private double[] dailyTemps;
	
	public DuctBank(){
	}
	public DuctBank(int planyear) {
		super(planyear,0);
	}
	
	/**
	 * The Constructor.
	 * 
	 * @param dbId the db id
	 * @param bbankSubId 	 * @param planyear the planyear
	 * @param planyear the planyear
	 */
	public DuctBank(int planyear, int dbId){
		super(planyear,dbId);
	}
	
	public DuctBank(DuctBank ductBank) {
		super(ductBank);
	}

	/**
	 * To string.
	 * 
	 * @return the string
	 */
	public String toString(){
		return getDbStructure()+" ("+getWallDir()+")";
	}
	
	/**
	 * Gets the duct at.
	 * 
	 * @param col the col
	 * @param row the row
	 * 
	 * @return the duct at
	 * 
	 * @throws SQLException the SQL exception
	 */
	public Duct getDuctAt(int row, int col) throws SQLException{
		return Duct.getInstance(getPlanyear(),getDbId(),row,col);		
	}
	
	/**
	 * Inits the calc variables RT.
	 * 
	 * @throws SQLException the SQL exception
	 */
	public void initCalcVariablesRT() throws SQLException{
		double[] loads = new double[getDbCols()*getDbRows()];
		double[][] cableTypes = new double[loads.length][];
		for(int d=0; d< loads.length; d++){
			Duct duct = Duct.getInstance(getPlanyear(),getDbId(),d/getDbCols()+1,d%getDbCols()+1);
			duct.refreshRTLoad();
			loads[d] = duct.getRtLoadDs();  
			cableTypes[d]=duct.getCableParameters();
		}
		rtTemps = calculateTemperatures(loads,cableTypes);
	}
	
	
	/**
	 * Average load of all of the circuits in the duct bank
	 * @return
	 * @throws SQLException 
	 */
	public double getAvgDailyDsLoad(Calendar c) throws SQLException{
		double[] loads = new double[getDbCols()*getDbRows()];
		double avgSimLoad = 0;
		int circuitWithLoad = 0;
		for(int d=0; d< loads.length; d++){
			Duct duct = Duct.getInstance(getPlanyear(),getDbId(),d/getDbCols()+1,d%getDbCols()+1);
			loads[d] = duct.getDailyActualPeakDs(c);
			avgSimLoad += loads[d];
			if(loads[d]>0)
				circuitWithLoad++;
		}
		if(circuitWithLoad>0)
			avgSimLoad = avgSimLoad / circuitWithLoad;
		return avgSimLoad;
	}
	
	public double getAvgRTDsLoad() throws SQLException{
		double[] loads = new double[getDbCols()*getDbRows()];
		double avgSimLoad = 0;
		int circuitWithLoad = 0;
		for(int d=0; d< loads.length; d++){
			Duct duct = Duct.getInstance(getPlanyear(),getDbId(),d/getDbCols()+1,d%getDbCols()+1);
			loads[d] = duct.getRtLoadDs();
			avgSimLoad += loads[d];
			if(loads[d]>0)
				circuitWithLoad++;
		}
		if(circuitWithLoad>0)
			avgSimLoad = avgSimLoad / circuitWithLoad;
		return avgSimLoad;
	}
	
	public double getAvgSimDsLoad() throws SQLException{
		double[] loads = new double[getDbCols()*getDbRows()];
		double avgSimLoad = 0;
		int circuitWithLoad = 0;
		for(int d=0; d< loads.length; d++){
			Duct duct = Duct.getInstance(getPlanyear(),getDbId(),d/getDbCols()+1,d%getDbCols()+1);
			loads[d] = duct.getSimLoadDs();
			avgSimLoad += loads[d];
			if(loads[d]>0)
				circuitWithLoad++;
		}
		if(circuitWithLoad>0)
			avgSimLoad = avgSimLoad / circuitWithLoad;
		return avgSimLoad;
	}
	
	public double getAvgCProjDsLoad(int simId, int year) throws SQLException{
		double[] loads = new double[getDbCols()*getDbRows()];
		double avgSimLoad = 0;
		int circuitWithLoad = 0;
		for(int d=0; d< loads.length; d++){
			Duct duct = Duct.getInstance(getPlanyear(),getDbId(),d/getDbCols()+1,d%getDbCols()+1);
			loads[d] = duct.getCProjLoadDsAmps(simId, year);
			avgSimLoad += loads[d];
			if(loads[d]>0)
				circuitWithLoad++;
		}
		if(circuitWithLoad>0)
			avgSimLoad = avgSimLoad / circuitWithLoad;
		return avgSimLoad;
	}
	
	public int getCktCount() throws SQLException {
		int count = 0;
		for(Duct d:getDucts())
			if(d.getCkt()!=null)
				count++;
		return count;
	}
	
	
	/**
	 *  Used for HST Historical
	 */
	public void initCalcVariablesDaily(Calendar c) throws SQLException{
		double[] loads = new double[getDbCols()*getDbRows()];
		double[][] cableTypes = new double[loads.length][];
		for(int d=0; d< loads.length; d++){
			Duct duct = Duct.getInstance(getPlanyear(),getDbId(),d/getDbCols()+1,d%getDbCols()+1);
			loads[d] = duct.getDailyActualPeakDs(c);
			cableTypes[d]=duct.getCableParameters();
		}
		dailyTemps = calculateTemperatures(loads,cableTypes);
	}
	
	
	/**
	 * Calculates the cable temperature based on assigned ampacities and cable types
	 * based on simulation parameters.
	 * 
	 * @throws SQLException the SQL exception
	 */
	public void initCalcVariablesSim() throws SQLException{
		double[] loads = new double[getDbCols()*getDbRows()];
		double[][] cableTypes = new double[loads.length][];
		
		//For each duct:
		for(int d=0; d< loads.length; d++){
			Duct duct = Duct.getInstance(getPlanyear(),getDbId(),d/getDbCols()+1,d%getDbCols()+1);
			loads[d] = duct.getSimLoadDs();
			cableTypes[d]=duct.getSimCableParameters();
		}
		simTemps = calculateTemperatures(loads,cableTypes);//BME % ds added
	}
	
	/**
	 * Calculates the cable temperature based on assigned ampacities and cable types
	 * based on criteria projected loading values.
	 * 
	 * @param year the year
	 * @param simId the sim id
	 * 
	 * @throws SQLException the SQL exception
	 */
	public void initCalcVariablesCProj(int simId, int year) throws SQLException{
		double[] loads = new double[getDbCols()*getDbRows()];
		double[][] cableTypes = new double[loads.length][];
		//For each duct:
		for(int d=0; d< loads.length; d++){
			Duct duct = Duct.getInstance(getPlanyear(),getDbId(),d/getDbCols()+1,d%getDbCols()+1);
			loads[d] = duct.getCProjLoadDsAmps(simId, year);
			cableTypes[d]=duct.getCableParameters();
		}
		hotHash.put(simId+"-"+year,calculateTemperatures(loads,cableTypes));
	}
	
	/**
	 * Calculates the cable temperature based on assigned ampacities and cable types
	 * based on criteria projected loading values with no circuit transfers.
	 * 
	 * @param cktYear the ckt year
	 * 
	 * @throws SQLException the SQL exception
	 */
	public void initCalcVariablesCProjNoTrans(CktYear cktYear) throws SQLException{
		double[] loads = new double[getDbCols()*getDbRows()];
		double[][] cableTypes = new double[loads.length][];
		//For each duct:
		for(int d=0; d< loads.length; d++){
			Duct duct = Duct.getInstance(getPlanyear(),getDbId(),d/getDbCols()+1,d%getDbCols()+1);
			loads[d] = duct.getCProjLoadDsAmpsNoTrans(cktYear);
			cableTypes[d]=duct.getCableParameters();
		}
		noTransTemps = calculateTemperatures(loads,cableTypes);
	}
	
	/**
	 * Gets the duct temp RT.
	 * 
	 * @param col the col
	 * @param row the row
	 * 
	 * @return the duct temp RT
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getDuctTempRT(int row, int col) throws SQLException{
		if(rtTemps == null)
			initCalcVariablesRT();
		return rtTemps[(row-1)*getDbCols()+(col-1)];
	}
	
	/**
	 * Gets the duct temp sim.
	 * 
	 * @param col the col
	 * @param row the row
	 * 
	 * @return the duct temp sim
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getDuctTempSim(int row, int col) throws SQLException{
		if(simTemps == null)
			initCalcVariablesSim();
		try{//BME FTT need to figure out how to dynamically handle changing ductbank col/rows
			//I NEED to reinitialize simTemps
			return simTemps[(row-1)*getDbCols()+(col-1)];
		}catch(java.lang.ArrayIndexOutOfBoundsException e){
			e.printStackTrace();
		}
		return 0;
	}
	
	
	/**
	 * Gets the duct temp sim.
	 * 
	 * @param col the col
	 * @param row the row
	 * 
	 * @return the duct temp sim
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getDuctTempDailyPeak(int row, int col, Calendar c) throws SQLException{
		if(dailyTemps == null)
			initCalcVariablesDaily(c);
		try{
			return dailyTemps[(row-1)*getDbCols()+(col-1)];
		}catch(java.lang.ArrayIndexOutOfBoundsException e){
			e.printStackTrace();
		}
		return 0;
	}
	
	/**
	 * Gets the duct temp C proj.
	 * 
	 * @param col the col
	 * @param year the year
	 * @param simId the sim id
	 * @param row the row
	 * 
	 * @return the duct temp C proj
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getDuctTempCProj(int simId, int year, int row, int col) throws SQLException {
		if(hotHash.get(simId+"-"+year)==null)
			initCalcVariablesCProj(simId, year);
		double[] doubleArray = hotHash.get(simId+"-"+year);		
		if((row-1)*getDbCols()+(col-1)>=doubleArray.length){
			 return 0;
		 }
		 return doubleArray[(row-1)*getDbCols()+(col-1)];
	}
	
	/**
	 * Gets the duct temp C proj no trans.
	 * 
	 * @param col the col
	 * @param row the row
	 * @param cktYear the ckt year
	 * 
	 * @return the duct temp C proj no trans
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getDuctTempCProjNoTrans(CktYear cktYear, int row, int col) throws SQLException {
		if(noTransTemps==null)
			initCalcVariablesCProjNoTrans(cktYear);
		return noTransTemps[(row-1)*getDbCols()+(col-1)];
	}
	
	/**
	 * Calculate the temperatures of each cable in a duct bank based on
	 * cable loading and adjacent duct heating contributions.
	 * 
	 * @param loads the loads
	 * 
	 * @return Tn			The temperatures of each cable in a <code>Ductbank</code>.
	 * 
	 * @throws SQLException the SQL exception
	 */
public double[] calculateTemperatures(double loads[], double[][] cableType) throws SQLException{
		double Gb = .76;
		int dc=getDbRows()*getDbCols();
		double[] temperature = new double[dc];
		double[] Wc = new double[dc];
		double[] qs = new double[dc];
		double[][] dPkn = new double[dc][dc];
		double[][] dkn = new double[dc][dc];
		double[][] Re = new double[dc][dc];
		double[][] Ti = new double[dc][dc];
		double[] Tn = new double[dc];
		
		for(int d=0; d<dc; d++){
			int ROW1 = d/getDbCols(), COL1 = d%getDbCols();
			Duct duct = Duct.getInstance(getPlanyear(),getDbId(),d/getDbCols()+1,d%getDbCols()+1);
			double[] Vars = calculate(loads[d],duct,cableType[d],getSoilTemp());
			temperature[d] = Vars[0];
			Wc[d] = Vars[1];
			qs[d] = Vars[2];
			for(int i=0; i<dc; i++){
				int ROW2=i/getDbCols(), COL2=i%getDbCols();
				if(d != i){
					dPkn[d][i] = Math.sqrt(Math.pow(36*2+getDbThickness()*2+
							((ROW2-ROW1+1)*getVertSpacing()),2)+Math.pow((COL2-COL1)*getHorizSpacing(),2));
					dkn[d][i] = Math.sqrt(Math.pow((COL2-COL1)*7,2)+Math.pow(((ROW2-ROW1)*5.5),2));
					Re[d][i] = (0.00522*getFillRho())*(Math.log(dPkn[d][i]/dkn[d][i])/Math.log(10))+
					0.00522*(getSoilRho()-getFillRho())*Gb;
					Ti[d][i] = (3 * Wc[d] * qs[d] * Re[d][i] * duct.getLoadFactor()) + (3 * Re[d][i] * .0221);
				}//end if
				else{
					Ti[d][i] = 0;
				}//end else
			}//end for
		}//end for
		for(int c=0; c<dc; c++){
			Tn[c] = temperature[c];
			for(int j=0; j<dc; j++){
				if(loads[j] > 0){
					Tn[c] += Ti[j][c];
				}
			}
		}
		return Tn;
	}
	
	/**
	 * Calculate the temperature of an underground cable based on ampacity
	 * using the Neher-McGrath Algorithm.
	 * 
	 * @param duct  	    Duct Object.
	 * @param load  		cable load.
	 * 
	 * @return Tc			The calc'ed temperature of each cable in a duct.
	 * 
	 * @throws SQLException the SQL exception
	 */ 
	public double[] calculate(double load, Duct duct, double[] cableType, double ta) throws SQLException {
		
		//Global Parameters
		double Dc = cableType[0];			//diameter of conductor
		double Rdc25 = cableType[1];		//dc resistance of conductor @ 25 C
		double Tcs = cableType[2];			//Thickness of conductor shield
		double Tin = cableType[3];			//Thickness of insulation
		double Tis = cableType[4];			//Thickness of insulation shield
		double Tj = cableType[5];			//thickness of jacket
		
		double d = cableType[6];			//Diameter of concentric wires
		double n = cableType[7];			//Number of concentric wires
		double Lf = cableType[8];			//Lay factor of concentric neutral
		
		double ks = cableType[9];			//Skin effect factor of conductor
		double kp = cableType[10];			//Proximity effect factor of conductor		
		
		double Ta = ta;
		
		double Nprime = cableType[12];		//# of cables in a stated diameter
		double Volts = cableType[13];		//Operating voltage phase to phase (kV)
		
		double pi = cableType[14];			//thermal resistivity of insulation
		double pj = cableType[15];			//thermal resistivity of jacket
		
		double pe = getSoilRho();			//thermal resistivity of earth
		
		double er = cableType[23];			//SIC of insulation
		double cos0 = cableType[24];		//dissipation factor
		
		double Ts = cableType[25];			//Shield temperature
		double lf = duct.getLoadFactor();	//load factor
		double a = cableType[29];			//Constant for qs
		double S = getHorizSpacing(); 		//spacing between conductors
		double L = getDbDepth(); 			//Depth of burial
		
		//**********************************************************
		//Cable Parameter calculations

		double Dcs = Dc + 2*Tcs;	//Diameter of conductor shield
		double Di = Dcs + 2*Tin;	//Diameter of insulation
		double Dis = Di + 2*Tis;	//Diameter of insulation shield
		double Dshld = Dis + 2*d;	//Diameter of wire shield
		double Dsm = (Dshld + Dis)/2;   //Mean shield diameter
		double Dj = Dshld + 2*Tj;	//Diameter of jacket
		
		double De = Dj;                 //Diameter where earth starts
				
		//**********************************************************
		//Operating and Installation Parameter
		//(Thickness & diameters are in inches and temperatures
		// are in degrees C)
		
		double Tc;                      //Conductor temperature
		
		double E = Volts/Math.sqrt(3);  //Voltage phase to ground
		
		double LF = .3*lf+.7*lf*lf;	//Loss factor //Neher eq. (3)
		
		//**********************************************************
		//Electrical Resistance calculations
		double Rdc = 0.0;
		
		
		//=================================================================================
		if(duct.getCable()!=null && duct.getCable().getMaterial()!=null){
			if(duct.getCable().getMaterial().equalsIgnoreCase("AL")){
				Rdc = Rdc25*((75 + 228.1)/(25 + 228.1));	//dc resistance of cond. @ 25 C		
			}else if(duct.getCable().getMaterial().equalsIgnoreCase("CU")){
				Rdc = Rdc25*((75 + 234.5)/(25 + 234.5));	//dc resistance of cond. @ 25 C		
			}
		//=================================================================================
		}else{//original
			Rdc = Rdc25*((75 + 228.1)/(25 + 228.1));	//dc resistance of cond. @ 25 C		
		}
		//=================================================================================
		
		double Rs = ((10.575*Lf)/(n*d*d))*((Ts+234.5)/(25+234.5)); // dc resist.
		//of shld. @ 25 C
		double xs = Rdc/ks;
		
		double Fxs = 11.0/(Math.pow((xs+(4/xs)-(2.56/(xs*xs))),2));//Calc. of
		//conductor skin effect
		double Ycs = Fxs;
		
		double xp = Rdc/kp;
		
		double Fxp = 11.0/(Math.pow((xp+(4/xp)-(2.56/(xp*xp))),2));//Calc. of
		//conductor proximity effect
		
		double Ycp = Fxp*(Dc/S)*(Dc/S)*(((1.18/(Fxp+0.27))+(0.312)*(Dc/S)*(Dc/S)));
		
		double Yc = Ycs + Ycp;
		
		double Xm = 52.92*((Math.log((2*S)/Dsm))/(Math.log(10)));
		
		double Y = Xm + a;
		double Z = Xm - (a/3);
		double P = Rs/Y;
		double Q = Rs/Z;
		
		double qs1 = 1 +(((P*P+3*Q*Q)+2*1.732*(P-Q)+4)/(4*(P*P+1)*(Q*Q+1)))*
		Rs/(Rdc*(1+Yc));
		
		double qs2 = 1 +(1/(Q*Q+1))*(Rs/(Rdc*(1+Yc)));
		
		double qs3 = 1 +(((P*P+3*Q*Q)-2*1.732*(P-Q)+4)/(4*(P*P+1)*(Q*Q+1)))*
		Rs/(Rdc*(1+Yc));
		
		//**********************************************************
		//Thermal resistance calculations
		
		double Rd = 0;
		double Rsd = 0;
		
		double Dx = 1.02*Math.sqrt((104/Math.pow(pe,0.8))*24);
		
		double Ri = 0.012*pi*((Math.log(Dis/Dc)/Math.log(10)));
		//thermal res. of insulation
		
		double Rj = 0.012*pj*((Math.log(Dj/Dis)/Math.log(10)));
		//thermal res. of jacket
		
		double F = ((Math.sqrt((S*S+((2*L)*(2*L))))/S)*
				(Math.sqrt((S*S+((2*L)*(2*L))))/S));
		
		double F21 = (Math.sqrt((S*S+((2*L)*(2*L))))/S);
		
		double F23 = F21;
		
		double Re1 = 0.012*pe*Nprime*((Math.log(Dx/De)/Math.log(10)));
		
		double Re2 = 0.012*pe*Nprime*LF*((Math.log((4*L)/Dx)/Math.log(10)));
		
		double R21 = 0.012*pe*Nprime*LF*((Math.log(F21)/Math.log(10)));
		
		double R23 = 0.012*pe*Nprime*LF*((Math.log(F23)/Math.log(10)));
		
		double calc1 = Dx/De;
		double calc2 = ((4*L)/Dx)*F;
		
		double Red2 = 0.012*pe*Nprime*((Math.log(calc1)/Math.log(10)) +
				(1*(Math.log(calc2)/Math.log(10))));
		
		double Rda2 = 0.5*Ri+Rj+Rd+Rsd+Red2;
		double Rse = Rj+Rsd+Rd;
		
		double Rca2 = Ri+(qs2*(Rse+Re1+Re2))+qs1*R21+qs3*R23;
		
		//**********************************************************
		//dialectric losses
		
		double Wd = (0.00276*E*E*er*cos0)/((Math.log(Di/Dcs))/(Math.log(10)));
		
		double deltaTd2 = Wd * Rda2;
		
		//**********************************************************
		//Temperature Calculation
		
		load/=1000;
		
		//Conductor Temperature
		Tc = load*load*Rdc*(1+Yc)*Rca2+Ta+deltaTd2;
		
		double Wc2 = load * load * Rdc*(1 + Yc);  //watts/conductor foot
		//double Tcs2 = Tc - (Wc2*Ri + Wd*0.5*Ri);	//temp. of the metallic shield
		
		return new double[] {Tc,Wc2,qs1};
		//**********************************************************
	}//end calculate

}
