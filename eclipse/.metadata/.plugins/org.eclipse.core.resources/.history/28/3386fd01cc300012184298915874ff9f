/**
 *           | Master Data Interface Version 2.0 |
 *
 * Copyright (c) 2006, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team.
 * 	                   All rights reserved.
 *
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package com.sce.esp.object.dao;
import java.io.FileInputStream; 
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Reader;
import java.io.Writer;
import java.sql.Clob;
import java.sql.DatabaseMetaData;
<<<<<<< .working
=======
import java.sql.Date;
import java.sql.PreparedStatement;
>>>>>>> .merge-right.r11245
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Vector;

import javax.persistence.Column;

import oracle.sql.CLOB;

import com.sce.esp.object.jpa.AICache;
import com.sce.esp.object.jpa.AutoInsertable;
import com.sce.esp.object.jpa.Change;
import com.sce.esp.object.jpa.ChangeLog;
import com.sce.esp.object.jpa.Entity;
import com.sce.esp.object.jpa.EntityManagerHelper;
import com.sce.esp.object.jpa.PrimaryKey;
import com.sce.esp.object.model.User;
import com.sce.esp.util.Calculate;
import com.sce.esp.util.ESPProperties;
import com.sce.esp.util.FormatText;
import java.util.Observable;
import com.sce.esp.util.db.PDBConnection;


/**
 * The MDIObject Object.
 *
 * @author Distribution Staff Engineering
 * @version 2.0
 */
public abstract class DataAccessObject extends Observable implements Comparable<Object>, ChangeLog, Entity{
	private static Vector<Class<DataAccessObject>> allClasses;
	private static Vector<Class<DataAccessObject>> allSpiClasses;
	
	
	/** The Constant DEPARTMENT. */
	public final static int DEPARTMENT=0;

<<<<<<< .working
	private static AICache aiCache=new AICache();
	public static boolean AG_CACHE_ENABLED=true;
	private Map<String,Object> valueCache;
	private Vector<DataAccessObject> watchers;
	
=======
	/** The Constant ZONE. */
	public final static int ZONE=1;

	/** The Constant REGION. */
	public final static int REGION=2;

	/** The Constant DISTRICT. */
	public final static int DISTRICT=3;
	
	/** The Constant SYSTEM. */
	public final static int SYSTEM=4;

	/** The Constant ABANK. */
	public final static int ABANK=5;

	/** The Constant BBANK. */
	public final static int BBANK=6;

	/** The Constant CIRCUIT. */
	public final static int CIRCUIT=7;

	/** The Constant STL. */
	public final static int STL=8;
	
	/** The Constant WEATHERSTATION. */
	public final static int WEATHERSTATION=9;
	
	/** The new instance. */
	protected boolean newInstance=true;

>>>>>>> .merge-right.r11245
	protected boolean prevInstanceRead=false;
<<<<<<< .working
	protected Calendar insertTs; //INSERT_DATE
	protected Integer insertUserId; //INSERT_USER_ID
	protected Calendar modifiedTs; //MODIFIED_DATE
	protected Integer modifiedUserId; //MODIFIED_USER_ID
	protected Calendar deletedTs; //DELETED_DATE
	protected Integer deletedUserId; //DELETED_USER_ID
	
	private HashMap<String,Change> changes;
	
=======
	
	protected Calendar insertTs; //INSERT_DATE
	protected int insertUserId; //INSERT_USERNAME_ID
	protected Calendar modifiedTs; //MODIFIED_DATE
	protected int modifiedUserId; //MODIFIED_USERNAME_ID
	protected Calendar deletedTs; //DELETE_DATE
	protected int deleteUserId; //DELETE_USERNAME_ID

>>>>>>> .merge-right.r11245
    /**
     * Creates a new instance of DBObject.
     */
    public DataAccessObject() {
    }

    public DataAccessObject(DataAccessObject orig){
	}

	/**
     * Checks if is new instance.
     *
     * @return true, if is new instance
     */
    public boolean isNewInstance(){
    	return !EntityManagerHelper.getEntityManager().contains(this);
    }
<<<<<<< .working
    
//    protected void setNewInstance(boolean newInstance) {
//		this.newInstance = newInstance;
//	}
    
    public int isAutoInsertable(){
    	return 0;
    }

    /**
=======

    /**
>>>>>>> .merge-right.r11245
     * Compare to.
     *
     * @param o the o
     *
     * @return the int
     */
    public int compareTo(Object o){
    	//If this is the same exact object in memory then just say so
    	if(this == o)
    		return 0;
    	if(o instanceof DataAccessObject)
    		return (toString()+getHashKey()).compareTo(o.toString()+((DataAccessObject)o).getHashKey());
        return 0;
    }

    /**
     * Gets the hash key.
     *
     * @return the hash key
     */
    public abstract String getHashKey();

    /**
     * Refresh.
     *
     * @return true, if refresh
     *
     * @throws SQLException the SQL exception
     */
    public void refresh()throws SQLException{
    	EntityManagerHelper.getEntityManager().refresh(this);
    }
    
    @Column(name="INSERT_TS",nullable=true,length=7)
    /**
	 * Returns the insertDate
	 * @return The insertDate
	 */
	public Calendar getInsertTs(){
		if(isNewInstance() && insertTs==null)
			return Calendar.getInstance();
		return insertTs;
	}
	
	/**
	 * Sets the insertDate
	 * @param The new insertDate
	 */
	public void setInsertTs(Calendar insertDate)throws SQLException{
		if(isSame(insertDate,getInsertTs())) return;
		setProperty("INSERT_TS",insertDate,getInsertTs());
		this.insertTs = insertDate;
	}

	@Column(name="INSERT_USER_ID",nullable=true,length=9)
	/**
	 * Returns the insertUserId
	 * @return The insertUserId
	 */
	public Integer getInsertUserId(){
		if(isNewInstance() && insertUserId==null && User.getActiveUser()!=null)
			return User.getActiveUser().getUsernameId();
		return insertUserId;
	}

	/**
	 * Sets the insertUserId
	 * @param The new insertUserd
	 */
	public void setInsertUserId(Integer insertUserId)throws SQLException{
		if(isSame(insertUserId,getInsertUserId())) return;
		setProperty("INSERT_USER_ID",insertUserId,getInsertUserId());
		this.insertUserId = insertUserId;
	}

	@Column(name="MODIFIED_TS",nullable=true,length=7)
	/**
	 * Returns the modifiedDate
	 * @return The modifiedDate
	 */
	public Calendar getModifiedTs(){
		return modifiedTs;
	}

<<<<<<< .working
	/**
	 * Sets the modifiedDate
	 * @param The new modifiedDate
	 */
	public void setModifiedTs(Calendar modifiedDate)throws SQLException{
		if(isSame(modifiedDate,getModifiedTs())) return;
		setProperty("MODIFIED_TS",modifiedDate,getModifiedTs());
		this.modifiedTs = modifiedDate;
	}

	@Column(name="MODIFIED_USER_ID",nullable=true,length=9)
	/**
	 * Returns the modifiedUserId
	 * @return The modifiedUserId
	 */
	public Integer getModifiedUserId(){
		return modifiedUserId;
	}
=======
    /**
     * Refresh.
     *
     * @return true, if refresh
     *
     * @throws SQLException the SQL exception
     */
    public boolean refresh()throws SQLException{
    	boolean ret=true;
        Connection con = PDBConnection.getInstance().getConnection();
        PreparedStatement ps =  con.prepareStatement("SELECT * FROM "+getDBTable()+" "+getWhereClause());
        setPSKeys(ps,1);
        ResultSet rs = ps.executeQuery();
        if(rs.next())
            refresh(rs);
        else
        	ret=false;
        rs.close();
        ps.close();
        return ret;
    }
>>>>>>> .merge-right.r11245
    
<<<<<<< .working
	/**
	 * Sets the modifiedUsernameId
	 * @param The new modifiedUsernameId
	 */
	public void setModifiedUserId(Integer modifiedUserId)throws SQLException{
		if(isSame(modifiedUserId,getModifiedUserId())) return;
		setProperty("MODIFIED_USER_ID",modifiedUserId,getModifiedUserId());
		this.modifiedUserId = modifiedUserId;
	}
=======
    /**
	 * Returns the insertDate
	 * @return The insertDate
	 */
	public Calendar getInsertTs(){
		if(isNewInstance() && insertTs==null)
			return Calendar.getInstance();
		return insertTs;
	}
>>>>>>> .merge-right.r11245

<<<<<<< .working
	@Column(name="DELETED_TS",nullable=true,length=7)
	/**
	 * Returns the deleteDate
	 * @return The deleteDate
	 */
	public Calendar getDeletedTs(){
		return deletedTs;
	}
=======
	/**
	 * Sets the insertDate
	 * @param The new insertDate
	 */
	public void setInsertTs(Calendar insertDate)throws SQLException{
		if(isSame(insertDate,getInsertTs())) return;
		setProperty("INSERT_TS",insertDate);
		this.insertTs = insertDate;
	}
>>>>>>> .merge-right.r11245

<<<<<<< .working
	/**
	 * Sets the deleteDate
	 * @param The new deleteDate
	 */
	public void setDeletedTs(Calendar deleteDate)throws SQLException{
		if(isSame(deleteDate,getDeletedTs())) return;
		setProperty("DELETED_TS",deleteDate,getDeletedTs());
		this.deletedTs = deleteDate;
	}
=======
	/**
	 * Returns the insertUsernameId
	 * @return The insertUsernameId
	 */
	public int getInsertUserId(){
		if(isNewInstance() && insertUserId==0)
			return User.getActiveUser().getUsernameId();
		return insertUserId;
	}
>>>>>>> .merge-right.r11245

<<<<<<< .working
	@Column(name="DELETED_USER_ID",nullable=true,length=9)
	/**
	 * Returns the deleteUserId
	 * @return The deleteUserId
	 */
	public Integer getDeletedUserId(){
		return deletedUserId;
	}

	/**
	 * Sets the deleteUsernameId
	 * @param The new deleteUsernameId
	 */
	public void setDeletedUserId(Integer deletedUserId)throws SQLException{
		if(isSame(deletedUserId,getDeletedUserId())) return;
		setProperty("DELETED_USER_ID",deletedUserId,getDeletedUserId());
		this.deletedUserId = deletedUserId;
	}

//	public abstract Map<String,Object> getPropertyValues();

//	public void setPropertyValues(Map<String,Object> pc) throws SQLException{
//		insertTs = (Calendar)pc.get("INSERT_TS");
//		insertUserId = (Integer)pc.get("INSERT_USER_ID");
//		modifiedTs = (Calendar)pc.get("MODIFIED_TS");
//		modifiedUserId = (Integer)pc.get("MODIFIED_USER_ID");
//		deletedTs = (Calendar)pc.get("DELETED_TS");
//		deletedUserId = (Integer)pc.get("DELETED_USER_ID");
//	}
	public User getInsertUser()throws SQLException{
		return User.getInstance(getInsertUserId());
	}
	public void setInsertUser(User user)throws Exception{
		if(user==null)
			setInsertUserId(0);
		else
			setInsertUserId(user.getUsernameId());
	}
	public User getModifiedUser() throws SQLException {
		return User.getInstance(getModifiedUserId());
	}
	public void setModifiedUser(User user2)throws Exception{
		if(user2==null)
			setModifiedUserId(0);
		else
			setModifiedUserId(user2.getUsernameId());
	}
	public User getDeletedUser()throws SQLException{
		return User.getInstance(getDeletedUserId());
	}
	public void setDeletedUser(User user3)throws SQLException{
		if(user3==null)
			setDeletedUserId(0);
		else
			setDeletedUserId(user3.getUsernameId());
	}
	
	public Collection<Change> getChanges(){
		return changes.values();
	}
	
	public void addChange(String prop, Object newValue, Object oldValue){
		if(changes == null)
			changes = new HashMap<String,Change>();
		changes.put(prop, new Change(prop,newValue,oldValue));
	}

	protected void setProperty(String prop, Object newValue, Object oldValue) throws SQLException{
		if(prop==null)return;
		if(getClass().getAnnotation(AutoInsertable.class)!=null && isNewInstance()){
			insert();
			return;
		}
		if(isNewInstance()) return;
		modifiedTs = Calendar.getInstance();
		modifiedUserId = User.getActiveUser().getUsernameId();
		addChange(prop, newValue,oldValue);
		addChange("MODIFIED_TS", modifiedTs, getModifiedTs());
		addChange("MODIFIED_USER_ID", modifiedUserId, getModifiedUserId());
		save();
	}

	public void delete() throws SQLException{
		deletedTs = Calendar.getInstance();
		deletedUserId = User.getActiveUser().getUsernameId();
		addChange("DELETED_TS", deletedTs, getDeletedTs());
		addChange("DELETED_USER_ID", deletedUserId, getDeletedUserId());
		save();
	}
	
	public void restore() throws SQLException{
		deletedTs = null;
		deletedUserId = null;
		addChange("DELETED_TS", deletedTs, getDeletedTs());
		addChange("DELETED_USER_ID", deletedUserId, getDeletedUserId());
		save();
	}
	
	/**
	 * This does not insert into the database.  This call EntityManager merge.
	 */
	public void save(){
		if(changes!=null){
			EntityManagerHelper.getEntityManager().merge(this);
			changes.clear();
		}
	}

	public void deleteDB() throws SQLException{
		EntityManagerHelper.getEntityManager().remove(this);
	}	
	
	public boolean isDeleted(){
		return getDeletedTs()!=null;
	}

=======
	/**
	 * Sets the insertUsernameId
	 * @param The new insertUsernameId
	 */
	public void setInsertUserId(int insertUserId)throws SQLException{
		if(isSame(insertUserId,getInsertUserId())) return;
		if(insertUserId == 0)
			setProperty("INSERT_USER_ID",null);
		else
			setProperty("INSERT_USER_ID",insertUserId);
		this.insertUserId = insertUserId;
	}

	/**
	 * Returns the modifiedDate
	 * @return The modifiedDate
	 */
	public Calendar getModifiedTs(){
		return modifiedTs;
	}

	/**
	 * Sets the modifiedDate
	 * @param The new modifiedDate
	 */
	public void setModifiedTs(Calendar modifiedDate)throws SQLException{
		if(isSame(modifiedDate,getModifiedTs())) return;
		setProperty("MODIFIED_TS",modifiedDate);
		this.modifiedTs = modifiedDate;
	}

	/**
	 * Returns the modifiedUsernameId
	 * @return The modifiedUsernameId
	 */
	public int getModifiedUserId(){
		return modifiedUserId;
	}

	/**
	 * Sets the modifiedUsernameId
	 * @param The new modifiedUsernameId
	 */
	public void setModifiedUserId(int modifiedUserId)throws SQLException{
		if(isSame(modifiedUserId,getModifiedUserId())) return;
		if(modifiedUserId == 0)
			setProperty("MODIFIED_USER_ID",null);
		else
			setProperty("MODIFIED_USER_ID",modifiedUserId);
		this.modifiedUserId = modifiedUserId;
	}

	/**
	 * Returns the deleteDate
	 * @return The deleteDate
	 */
	public Calendar getDeletedTs(){
		return deletedTs;
	}

	/**
	 * Sets the deleteDate
	 * @param The new deleteDate
	 */
	public void setDeletedTs(Calendar deleteDate)throws SQLException{
		if(isSame(deleteDate,getDeletedTs())) return;
		setProperty("DELETED_TS",deleteDate);
		this.deletedTs = deleteDate;
	}

	/**
	 * Returns the deleteUsernameId
	 * @return The deleteUsernameId
	 */
	public int getDeletedUserId(){
		return deleteUserId;
	}

	/**
	 * Sets the deleteUsernameId
	 * @param The new deleteUsernameId
	 */
	public void setDeletedUserId(int deleteUserId)throws SQLException{
		if(isSame(deleteUserId,getDeletedUserId())) return;
		if(deleteUserId == 0)
			setProperty("DELETED_USER_ID",null);
		else
			setProperty("DELETED_USER_ID",deleteUserId);
		this.deleteUserId = deleteUserId;
	}


	public void refresh(ResultSet rs) throws SQLException{
		insertTs = getCalendar(rs.getTimestamp("INSERT_TS"));
		insertUserId = rs.getInt("INSERT_USER_ID");
		modifiedTs = getCalendar(rs.getTimestamp("MODIFIED_TS"));
		modifiedUserId = rs.getInt("MODIFIED_USER_ID");
		deletedTs = getCalendar(rs.getTimestamp("DELETED_TS"));
		deleteUserId = rs.getInt("DELETED_USER_ID");
	}
	public User getInsertUser()throws SQLException{
		return User.getInstance(getInsertUserId());
	}
	public void setInsertUser(User user)throws SQLException{
		if(user==null)
			setInsertUserId(0);
		else
			setInsertUserId(user.getUsernameId());
	}
	public User getModifiedUser() throws SQLException {
		return User.getInstance(getModifiedUserId());
	}
	public void setModifiedUser(User user2)throws SQLException{
		if(user2==null)
			setModifiedUserId(0);
		else
			setModifiedUserId(user2.getUsernameId());
	}
	public User getDeletedUser()throws SQLException{
		return User.getInstance(getDeletedUserId());
	}
	public void setDeletedUser(User user3)throws SQLException{
		if(user3==null)
			setDeletedUserId(0);
		else
			setDeletedUserId(user3.getUsernameId());
	}

	public int setProperty(String col, Object value) throws SQLException{
		if(isNewInstance())
			return 0;
		Connection con = PDBConnection.getInstance().getConnection();
		String valStr = ""+value;
		if(value != null && value instanceof Calendar)
			valStr = FormatText.USER_DATETIME.format(((Calendar)value).getTime());
		if(ESPProperties.getInstance().getRunningInstance() != ESPProperties.WEB_APP)
			System.out.println("DATABASE UPDATE: "+getDBTable()+" "+getHashKey()+" "+col+" "+valStr);
		Calendar mDate = Calendar.getInstance();
		PreparedStatement ps = con.prepareStatement("UPDATE "+getDBTable()+" SET "+col+"=?, MODIFIED_TS=?, MODIFIED_USER_ID=? "+getWhereClause());
		setPSValue(ps,1,value);
		ps.setTimestamp(2,new Timestamp(mDate.getTimeInMillis()));
		ps.setInt(3,User.getActiveUser().getUsernameId());
		setPSKeys(ps,4);
		int c = ps.executeUpdate();
		ps.close();
		if(c==0){
			if(getRealRecord() != this)
				c = simCopy(col,value);
			if(c <= 0){
				if(isAutoInsertable())
					c = insert(col,value);
				else/* Update attempted but record does not exist and not auto insertable*/
					throw new SQLException("Database Entry Not Found");
			}
		}
		modifiedTs = mDate;
		modifiedUserId = User.getActiveUser().getUsernameId();
		return c;
	}

	/**
	 * Insert.
	 *
	 * @param col the col
	 * @param value the value
	 *
	 * @return c
	 *
	 * @throws SQLException the SQL exception
	 */
	public int insert(String col, Object value)throws SQLException{
		int pc = getPKSet().length;
		String insert = "INSERT INTO "+getDBTable()+" ("+col+",INSERT_TS,INSERT_USER_ID,"+getInsertPKs()+") VALUES(?,?,?";
		for(int p=0; p<pc; p++)
			insert += ",?";
		insert += ")";
		Connection con = PDBConnection.getInstance().getConnection();
		if(ESPProperties.getInstance().getRunningInstance() != ESPProperties.WEB_APP)
			System.out.println("DATABASE INSERT: "+insert);
		PreparedStatement ps = con.prepareStatement(insert);
		setPSValue(ps,1,value);
		ps.setTimestamp(2,new Timestamp(Calendar.getInstance().getTimeInMillis()));
		ps.setInt(3,User.getActiveUser().getUsernameId());
		setPSKeys(ps,4);
		int c = ps.executeUpdate();
		ps.close();
		if(!isRealRecord())
			refresh();
		refreshParents();
		return c;
	}

	public boolean delete() throws SQLException{
		Connection con = PDBConnection.getInstance().getConnection();
		Calendar mDate = Calendar.getInstance();
		System.out.println("UPDATE "+getDBTable()+" SET DELETED_TS=?, DELETED_USER_ID=? "+getWhereClause());
		PreparedStatement ps = con.prepareStatement("UPDATE "+getDBTable()+" SET DELETED_TS=?, DELETED_USER_ID=? "+getWhereClause());
		ps.setTimestamp(1,new Timestamp(mDate.getTimeInMillis()));
		ps.setInt(2,User.getActiveUser().getUsernameId());
		setPSKeys(ps,3);
		boolean ret = ps.executeUpdate() > 0;
		ps.close();
		postDelete();
		setDeletedTs(mDate);
		return ret;
	}

	public boolean deleteDB() throws SQLException{
		Connection con = PDBConnection.getInstance().getConnection();
		System.out.println("DATABASE DELETE: "+getDBTable()+" "+getWhereClause());
		PreparedStatement ps = con.prepareStatement("DELETE FROM "+getDBTable()+" "+getWhereClause());
		setPSKeys(ps,1);
		boolean ret = ps.execute();
		ps.close();
		postDelete();
		return ret;
	}

	public void restore() throws SQLException{
		setDeletedTs(null);
		setDeletedUserId(0);
		refreshParents();
	}
	
	public boolean isDeleted(){
		return getDeletedTs()!=null;
	}

>>>>>>> .merge-right.r11245
    /**
     * Gets the real record.
     *
     * @return the real record
     */
    public DataAccessObject getRealRecord(){
    	return this;
    }

    /**
     * Checks if is real record.
     *
     * @return true, if is real record
     */
    public boolean isRealRecord(){
    	return getRealRecord() == this;
    }


    /**
     * Pre Insert.
     *
     * @return true, if insert
     *
     * @throws SQLException the SQL exception
     */
    public boolean preSimCopy()throws Exception{
        return true;
    }

    /**
     * Insert.
     *
     * @return true, if insert
     *
     * @throws SQLException the SQL exception
     */
    public void insert()throws SQLException{
    	if(isNewInstance()){
    		EntityManagerHelper.getEntityManager().persist(this);
    		this.insertTs=Calendar.getInstance();
    		if(User.getActiveUser() != null)
    			this.insertUserId=User.getActiveUser().getUsernameId();
    	}
    	insertChildren();
    }
<<<<<<< .working
    
    public void insertChildren()throws SQLException{ 	
    }
=======

    /**
     * Sim copy.
     *
     * @param col the col
     * @param value the value
     *
     * @return the int
     *
     * @throws SQLException the SQL exception
     */
    public int simCopy(String col, Object value)throws SQLException{
    	int count=0;
    	DataAccessObject real = getRealRecord();
    	if(real != this && preSimCopy()){
			PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement("SELECT * FROM "+getDBTable()+" "+getWhereClause());
			real.setPSKeys(ps,1);
			ResultSet rs = ps.executeQuery();
			if(rs.next()){
				String columns="";
				String values="";
				ResultSetMetaData rsmd = rs.getMetaData();
				for(int c=1; c<rsmd.getColumnCount()+1; c++){
					if(c > 1){
						columns+=",";
						values+=",";
					}
					columns+=rsmd.getColumnName(c);
					values+="?";
				}
				PreparedStatement ps2 = PDBConnection.getInstance().getConnection().prepareStatement("INSERT INTO "+getDBTable()+"("+columns+") VALUES("+values+")");
				Vector<String> keys = new Vector<String>();
				for(String key:getPKSet())
					keys.add(key);
				for(int c=1; c<rsmd.getColumnCount()+1; c++){
					String colName = rsmd.getColumnName(c); 
					if(keys.contains(colName)){
						try {
							ps2.setObject(c, getClass().getMethod("get"+FormatText.toUpperCamel(colName), (Class[])null).invoke(this, (Object[])null));
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					else if(col != null && col.equalsIgnoreCase(colName)){
						if(value instanceof Calendar)
							ps2.setTimestamp(c,new Timestamp(((Calendar)value).getTimeInMillis()));
						else
							ps2.setObject(c,value,rsmd.getColumnType(c));
					}else
						ps2.setObject(c,rs.getObject(c),rsmd.getColumnType(c));
				}
				count = ps2.executeUpdate();
				ps2.close();
				refresh();
				refreshParents();
			}
			rs.close();
			ps.close();
		}
    	return count;
    }
>>>>>>> .merge-right.r11245
    
    /**
<<<<<<< .working
=======
     * Post delete.
     *
     * @throws SQLException the SQL exception
     */
    public void postDelete()throws SQLException{
    	try {
    		((Hashtable<?,?>)getClass().getMethod("getHashtable", new Class[]{}).invoke(null, (Object[])null)).remove(getHashKey());
    	}catch(Exception e) {
    		e.printStackTrace();
    	}
    	refreshParents();
    }

    /**
     * Refresh parents.
     *
     * @throws SQLException the SQL exception
     */
    public void refreshParents()throws SQLException{
    }
    
    /**
     * Sets the PS value.
     *
     * @param index the index
     * @param value the value
     * @param ps the ps
     *
     * @throws SQLException the SQL exception
     */
    public static void setPSValue(PreparedStatement ps, int index, Object value)throws SQLException{
    	if(value instanceof Integer)
        	ps.setInt(index,(Integer)value);
        else if(value instanceof Double)
        	ps.setDouble(index,(Double)value);
        else if(value instanceof Boolean)
        	ps.setBoolean(index,(Boolean)value);
        else if(value instanceof Calendar){
        	if(value == null)
        		ps.setTimestamp(index,null);
        	else
        		ps.setTimestamp(index,new Timestamp(((Calendar)value).getTimeInMillis()));
//        		ps.setTimestamp(si++,new Timestamp(getPriorityTs().getTimeInMillis()));
        }
        else if(value instanceof Time)
        	ps.setTime(index,(Time)value);
        else if(value instanceof String)
        	ps.setString(index,(String)value);
        else
        	ps.setObject(index,value);
    }
    
    public static boolean isSame(Object o, Object o2){
    	return Calculate.isSame(o, o2);
    }

    /**
>>>>>>> .merge-right.r11245
     * Returns a string hash code of an object of this type with the
     * specified parameters. The hash code would be used to find the
     * object in a hash table.
     *
     * @param id - id for the object
     * @param planyear - planYear for the object
     * @param k1 the k1
     *
     * @return a string hash code of an object of this type with the specified parameters.
     */
    
    public static String getHashKey(Object[] keys){
    	return PrimaryKey.getHashKey(keys);
    }
    
    public static String getHashKey(Object key){
    	return PrimaryKey.getHashKey(key);
    }

<<<<<<< .working
    public static boolean isNull(Object... keys){
    	for(Object k:keys)
    		if(Calculate.isNull(k))
=======
    public static boolean isNull(Object[] keys){
    	for(Object k:keys)
    		if(Calculate.isNull(k))
>>>>>>> .merge-right.r11245
    			return true;
    	return false;
    }
    
    public static boolean isNull(Object o){
    	return Calculate.isNull(o);
    }

    /**
     * To string.
     *
     * @return the string
     */
    public String toString(){
    	return getHashKey();
    }

    @SuppressWarnings("unchecked")
	public static Class<DataAccessObject> getClassByDBTable(String table){
    	try{
    		return (Class<DataAccessObject>)Class.forName("com.sce.esp.object."+FormatText.toUpperCamel(table.substring(table.indexOf('_')+1)));
    	}catch(Exception e){
    		//e.printStackTrace();
    	}
		return null;
	}
<<<<<<< .working
    
    
    public static Vector<Class<DataAccessObject>> getAllObjects(String tableSearch) throws SQLException{
		if(allClasses == null){
=======
    
    private static Vector<Class<DataAccessObject>> allClasses;

    public static Vector<Class<DataAccessObject>> getAllObjects(String tableSearch) throws SQLException{
    	if(allClasses == null){
>>>>>>> .merge-right.r11245
    		allClasses = new Vector<Class<DataAccessObject>>();
    		DatabaseMetaData dbmd = PDBConnection.getInstance().getConnection().getMetaData();
    		ResultSet rs = dbmd.getTables(null,PDBConnection.SCHEMA,tableSearch,new String[]{"TABLE"});
    		while(rs.next()){
				String table = rs.getString("TABLE_NAME");
				if(table.charAt(6) == '_' && !table.startsWith("MDI005_") && !table.contains("REPORT")){
					Class<DataAccessObject> c = getClassByDBTable(table);
					if(c !=null)
						allClasses.add(c);
				}
    		}
    		rs.close();
    	}
    	return allClasses;
    }
<<<<<<< .working
    
    public static Vector<Class<DataAccessObject>> getAllSpiObjects() throws SQLException{
    	if(allSpiClasses == null){
    		allSpiClasses = new Vector<Class<DataAccessObject>>();
    		DatabaseMetaData dbmd = PDBConnection.getInstance().getConnection().getMetaData();
    		ResultSet rs = dbmd.getTables(null,PDBConnection.SCHEMA,"MDIS%_%",new String[]{"TABLE"});
    		while(rs.next()){
				String table = rs.getString("TABLE_NAME");
				if(table.charAt(6) == '_' && !table.startsWith("MDI005_") && !table.contains("REPORT")){
					Class<DataAccessObject> c = getClassByDBTable(table);
					if(c !=null)
						allSpiClasses.add(c);
				}
    		}
    		rs.close();
    	}
    	return allClasses;
    }
    
    public static Object getId(int id){
    	if(id == 0)
    		return null;
    	return id;
    }
    public static void sleep(int millis){
    	try {
			Thread.sleep(millis);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
    }
    public Vector<String> getDifference(DataAccessObject dao){
    	return new Vector<String>();
    }
    public void copyChildrenTo(DataAccessObject cp){
    }

//	public abstract void cache(String[] props) throws SQLException;
//	
//	public abstract String[] getProperties();
//	
//	public abstract String[] getKeyProperties();
//	
//	public abstract Object getPropertyValue(String property);
	
//	public abstract void setPropertyValue(String property, Object value)throws SQLException;

	//public abstract Object[] getKeyValues();
	
	/**
     * Always treat de-serialization as a full-blown constructor, by
     * validating the final state of the de-serialized object.
     */
     private void readObject(ObjectInputStream aInputStream) throws ClassNotFoundException, IOException {
       //always perform the default de-serialization first
       aInputStream.defaultReadObject();

//       //make defensive copy of the mutable Date field
//       fDateOpened = new Date( fDateOpened.getTime() );

       //ensure that object state has not been corrupted or tampered with maliciously
       validateState();
    }

      /**
      * This is the default implementation of writeObject.
      * Customise if necessary.
      */
      private void writeObject(ObjectOutputStream aOutputStream) throws IOException {
        //perform the default serialization for all non-transient, non-static fields
        aOutputStream.defaultWriteObject();
      }
      
      /**
       * Verify that all fields of this object take permissible values; that is,
       * this method defines the class invariant.
       *
       * In this style of implementation, both the entire state of the object
       * and its individual fields can be validated without repeating or
       * duplicating code.
       * Each condition is defined in one place. Checks on the entire
       * object are performed at the end of object construction, and at
       * the end of de-serialization. Checks on individual fields are
       * performed at the start of the corresponding setXXX method.
       * As well, this style replaces the if's and throwing
       * of exceptions at the start of a setXXX, with a simple call to validateXXX.
       * Validation is separated from the regular path of execution,
       * which leads to improved legibility.
       *
       * @throws IllegalArgumentException if any field takes an unpermitted value.
       */
       private void validateState() {
//          validateAccountNumber(fAccountNumber);
//          validateName(fFirstName);
//          validateName(fLastName);
//          validateDateOpened(fDateOpened);
       }

       /**
   	 * De-serialize the Object from the file
   	 */
   	public Object deserialize(String fileName) {

   		Object deserializedObject = null;
   		try {
   			ObjectInputStream in = new ObjectInputStream(new FileInputStream(
   					fileName));
   			deserializedObject = in.readObject();
   			in.close();
   		} catch (Exception ex) {
   			System.out.println("Error Reading Object to File :"
   					+ ex.getMessage());
   			ex.printStackTrace();

   		}
   		return deserializedObject;
   	}

   	/**
   	 * Serializes the object to a file
   	 * 
   	 * @param objToSerialize
   	 */
   	public void serialize(Object objToSerialize,String fileName) {
   		try {
   			ObjectOutputStream out = new ObjectOutputStream(
   					new FileOutputStream(fileName));
   			out.writeObject(objToSerialize);
   			out.close();
   		} catch (Exception ex) {
   			System.out.println("Error Saving Object to File :"+ ex.getMessage());
   			ex.printStackTrace();
   		}
   	}
   	
    
//    public void valueChanged() {
//    	notify(this);
//    	setDirtyBit(true);
//    }
    
   // protected boolean isDirtybit=true;
    public void setDirtyBit(boolean dirtyBit) {
		//isDirtybit=dirtyBit;
	}
    
    public static AICache getAICache(){
    	return aiCache;
    }
    protected Map<String,Object> getValueCache(){
    	if(valueCache==null)
    		valueCache = Collections.synchronizedMap(new HashMap<String,Object>());
    	return valueCache;
    }
	public Object getCachedValue(String method, Object... params){
		if(!AG_CACHE_ENABLED)return null;
		return getValueCache().get(getMethodKey(method,params));
	}
	public void setCachedValue(Object value, String method, Object... params){
		if(AG_CACHE_ENABLED)
			getValueCache().put(getMethodKey(method,params), value);
	}
	public void invalidateCache(String method, Object... params){
		getValueCache().remove(getMethodKey(method,params));
	}
	public Vector<DataAccessObject> getWatchers(){
		return watchers;
	}
	public void addWatcher(DataAccessObject w){
		if(watchers==null)
			watchers = new Vector<DataAccessObject>();
		watchers.add(w);
	}
	public void removeWatcher(DataAccessObject w){
		if(watchers==null)return;
		watchers.remove(w);
	}
	public void invalidateAllCache(){
		getValueCache().clear();
		Vector<DataAccessObject> watchers = getWatchers();
		if(watchers!=null)
			for(DataAccessObject w:watchers)
				w.invalidateAllCache();
	}
	public String getMethodKey(String method, Object... params){
		String key = method+"("+PrimaryKey.getHashKey(params)+")";
		//EspLogger.message(this, key);
		return key;
	}
	
	public static String clob2String(Clob clob) throws SQLException{
		String data=null;
		Reader is=null;
		if(clob!=null){
			int length = (int) clob.length();
			if(length>0){
				is = clob.getCharacterStream();
				char[] buffer = new char[length];
				@SuppressWarnings("unused")
				int count = 0;
				try {
					StringBuffer sb = new StringBuffer();
					while ((count = is.read(buffer)) != -1)
						sb.append(buffer);
					// Assign StringBuffer to String.
					data = new String(sb); 
				}
				catch (Exception e) {

				} 
				finally{
					if(is!=null)
						try {
							is.close();
						} catch (IOException e) {
							e.printStackTrace();
						}
//					if(clob!=null)
//						clob.free();
				}
			}
		}
		return data;
	}

	public static Clob string2Clob(String data) throws SQLException {
		CLOB tempClob = null;
		try
		{
			// If the temporary CLOB has not yet been created, create new
			tempClob = CLOB.createTemporary(PDBConnection.getInstance().getConnection(), true, CLOB.DURATION_SESSION);
			// Open the temporary CLOB in readwrite mode to enable writing
			tempClob.open(CLOB.MODE_READWRITE);
			// Get the output stream to write
			Writer tempClobWriter = tempClob.getCharacterOutputStream();
			// Write the data into the temporary CLOB
			tempClobWriter.write(data);
			// Flush and close the stream
			tempClobWriter.flush();
			tempClobWriter.close();
			// Close the temporary CLOB
			tempClob.close();
		}
		catch (SQLException sqlexp)
		{
			tempClob.freeTemporary();
			sqlexp.getMessage();
		}
		catch (Exception exp)
		{
			tempClob.freeTemporary();
			exp.getMessage();
		}
		return tempClob;
	}
=======
    
    private static Vector<Class<DataAccessObject>> allSpiClasses;
    
    public static Vector<Class<DataAccessObject>> getAllSpiObjects() throws SQLException{
    	if(allSpiClasses == null){
    		allSpiClasses = new Vector<Class<DataAccessObject>>();
    		DatabaseMetaData dbmd = PDBConnection.getInstance().getConnection().getMetaData();
    		ResultSet rs = dbmd.getTables(null,PDBConnection.SCHEMA,"MDIS%_%",new String[]{"TABLE"});
    		while(rs.next()){
				String table = rs.getString("TABLE_NAME");
				if(table.charAt(6) == '_' && !table.startsWith("MDI005_") && !table.contains("REPORT")){
					Class<DataAccessObject> c = getClassByDBTable(table);
					if(c !=null)
						allSpiClasses.add(c);
				}
    		}
    		rs.close();
    	}
    	return allClasses;
    }
    
    public static Date getDate(Calendar cal) {
		if(cal == null)
			return null;
		return new Date(cal.getTimeInMillis());
	}
    
    public static Calendar getCalendar(Date date){
    	if(date == null)
    		return null;
    	Calendar cal = Calendar.getInstance();
		cal.setTime(date);
    	return cal;
    }
    
    public static Calendar getCalendar(Timestamp ts){
    	if(ts == null)
    		return null;
    	Calendar cal = Calendar.getInstance();
		cal.setTime(ts);
    	return cal;
    }
    
    public static Timestamp getTimestamp(Calendar cal){
    	if(cal == null)
    		return null;
    	return new Timestamp(cal.getTimeInMillis());
    }
    
    public static Object getId(int id){
    	if(id == 0)
    		return null;
    	return id;
    }
    public static void sleep(int millis){
    	try {
			Thread.sleep(millis);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
    }
    public Vector<String> getDifference(DataAccessObject dao){
    	return new Vector<String>();
    }
    public void copyChildrenTo(DataAccessObject cp){
    }
>>>>>>> .merge-right.r11245
}
