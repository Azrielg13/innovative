/**
 *           | Master Data Interface Version 2.0 |                       
 * 
 * Copyright (c) 2006, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team. 					  
 * 	                   All rights reserved.
 * 
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
package com.sce.esp.object.model;

import java.io.Serializable;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Collection;
import java.util.TreeSet;
import java.util.Vector;

import javax.persistence.Entity;
import javax.persistence.NamedNativeQueries;
import javax.persistence.NamedNativeQuery;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;
import javax.swing.Icon;

import com.sce.esp.object.dao.DepartmentDAO;
import com.sce.esp.util.Calculate;
import com.sce.esp.util.IconsFactory;
@Entity
@Table(schema="MDI",name="MDI010_DEPARTMENT")
@NamedQueries({
	@NamedQuery(name = "findByID", query="SELECT o FROM Department o WHERE o.PLANYEAR=?1"),//AUTO-GENERATED
	@NamedQuery(name = "findAll", query="SELECT o FROM Department o"),//AUTO-GENERATED
	@NamedQuery(name = "findAllActive", query="SELECT o FROM Department o WHERE o.DELETED_TS IS NULL"),//AUTO-GENERATED
})
@NamedNativeQueries({
	@NamedNativeQuery(name = "refresh", query="SELECT o.* FROM MDI010_DEPARTMENT o WHERE o.PLANYEAR=?"),//AUTO-GENERATED
})
public class Department extends DepartmentDAO implements Serializable{	

	/**
	 * 
	 */
	private static final long serialVersionUID = 5857597257043484577L;

	/** The prev instance. */
	private Department prevInstance;

	/** The prev instance read. */
	private boolean prevInstanceRead;
	
	/** The act plan year. */
    private static int actPlanYear=-1;
	
	public static Department getInstance(int planyear)throws SQLException{
		if(planyear > getActivePlanYear() || planyear < getMinPlanYear()) return null;
		return getInstance(planyear, true);
	}
	
	public static int getMinPlanYear() throws SQLException{
		int minPlanYear=Integer.MAX_VALUE;
    	for(Department d:getAll())
    		if(d.getPlanyear()<minPlanYear)
    			minPlanYear = d.getPlanyear();
    	return minPlanYear;
	}

	/**
	 * The Constructor.
	 * 
	 * @param planyear the planyear
	 */
	public Department(){
	}
	public Department(int planyear){
		super(planyear);
	}
	
	public Department(Department department) {
		super(department);
	}

	public int getId(){
		return getPlanyear();
	}
	
	public int getCoTypeId(){
		return CoType.DEPARTMENT;
	}
	/**
	 * Gets the years hist.
	 * 
	 * @return a vector containing <code>Integer</code> objects.
	 */
	public Vector<Integer> getYearsHist(){
		Vector<Integer> yearsHist = new Vector<Integer>();
		for(int i=getPlanyear()-1; i >= getPlanyear()-10; i--)
			yearsHist.add(i);
		return yearsHist;
	}

	/*
	 * (non-Javadoc)
	 * @see com.sce.mdi.object.MDIObject#toString()
	 */
	public String toString(){
		return "SCE ("+getPlanyear()+") - \""+getTitle()+"\"";
	}

	/**
	 * Gets the instance.
	 * 
	 * @param planyear the planyear
	 * 
	 * @return the instance
	 * 
	 * @throws SQLException the SQL exception
	 * 
	 * @see com.sce.esp.object.model.CoreObject#getSpecificInstance(int)
	 */
	public Department getSpecificInstance(int planyear)throws SQLException{
		return getInstance(planyear);
	}

	/**
	 * Gets the name.
	 * 
	 * @return the name
	 * 
	 * @see com.sce.esp.object.model.CoreObject#getName()
	 */
	public String getName(){
		return toString();
	}

	/**
	 * Retrives the first layor of bbanks ever under object in the current planyear.
	 * 
	 * @param simId the sim id
	 * 
	 * @return TreeSet<BBank> containing the first layor of bbanks
	 * 
	 * @throws SQLException the SQL exception
	 * 
	 * @see com.sce.esp.object.model.CoreObject#getBbanks(int)
	 */
	public TreeSet<Bbank> getBbanks(int simId)throws SQLException{
		TreeSet<Bbank> bBanks = new TreeSet<Bbank>();
		for(Zone zone:getZones())
			bBanks.addAll(zone.getBbanks(simId));
		return bBanks;
	}

	/**
	 * Gets the weatherstations by instance.
	 * 
	 * @return the weatherstations by instance
	 * 
	 * @throws SQLException the SQL exception
	 * 
	 * @see com.sce.esp.object.model.CoreObject#getWeatherStations()
	 */
	public Vector<Weatherstation> getWeatherStationsByInstance()throws SQLException{
		Vector<Weatherstation> weatherstations = new Vector<Weatherstation>();
		for(Zone zone:getZones())
			weatherstations.addAll(zone.getWeatherStationsByInstance());
		return weatherstations;
	}

	/**
	 * Gets the syss.
	 * 
	 * @param simId the sim id
	 * 
	 * @return the syss
	 * 
	 * @throws SQLException the SQL exception
	 * 
	 * @see com.sce.esp.object.model.CoreObject#getSyss()
	 */
	public Collection<Sys> getSyss(int simId)throws SQLException{
		return getSyss();
	}

	public TreeSet<Sys> getSyssSCE(int simId)throws SQLException{
		TreeSet<Sys> syss = new TreeSet<Sys>();
		for(Sys sys:getSyss(simId))
			if(!sys.isForeignSys())
				syss.add(sys);
		return syss;
	}
    
    /**
     * Gets the daily peak.
     * 
     * @param date the date
     * 
     * @return the daily peak
     * 
     * @throws SQLException the SQL exception
     */
    public AgDailyPeak getDailyPeak(Calendar date)throws SQLException{
        return new AgDailyPeak(this,date);
    }
    
    /**
     * Gets the year.
     * 
     * @param simId the sim id
     * @param year the year
     * 
     * @return the year
     * 
     * @throws SQLException the SQL exception
     */
    public DepartmentYear getYear(int simId, int year)throws SQLException{
        return DepartmentYear.getInstance(getPlanyear(),year);
    }

    /**
     * Gets the user filtered syss.
     * 
     * @param simId the sim id
     * 
     * @return the user filtered syss
     * 
     * @throws SQLException the SQL exception
     */
    public Collection<Sys> getUserFilteredSyss(int simId) throws SQLException{
    	if(User.getActiveUser().getUserSelect().getMultSys().size() == 0)
    		return getSyss(simId);
        Vector<Sys> syss = new Vector<Sys>();
        for(Sys sys:getSyss(simId))
            if(User.getActiveUser().getUserSelect().getMultSys().contains(sys.getSysId()))
                syss.add(sys);
        return syss;
    }
    
    /**
     * Gets the active plan year.
     * 
     * @return the active plan year
     * 
     * @throws SQLException the SQL exception
     */
    public static int getActivePlanYear(){
    	if(actPlanYear==-1)
			try {
				refreshActivePlanYear();
			} catch (SQLException e) {
				e.printStackTrace();
			}
    	return actPlanYear;
    }
    
    /**
     * Refresh active plan year.
     * 
     * @throws SQLException the SQL exception
     */
    private static void refreshActivePlanYear()throws SQLException{
    	actPlanYear=-1;
    	for(Department d:getCollection(new String[]{"ACTIVE"},true))
    		if(d.getPlanyear()>actPlanYear)
    			actPlanYear = d.getPlanyear();
    }
    
	/**
	 * Gimme percent instance.
	 * 
	 * @param ws the ws
	 * 
	 * @return the double
	 * 
	 * @throws SQLException the SQL exception
	 * 
	 * @see com.sce.esp.object.model.CoreObject#getPercentInstance(com.sce.esp.object.model.Weatherstation)
	 */
	public double getPercentInstance(Weatherstation ws) throws SQLException {			
		double pi = 0;
		for(Weatherstation ws2: getWeatherStationsByInstance())
			if(ws == ws2)
				pi++;   		
		return Calculate.round(pi/getWeatherStationsByInstance().size()*100,1);
	}
	
	/**
	 * Gets the level.
	 * 
	 * @return the level
	 */
	public int getLevel() {
		return DEPARTMENT;
	}
	
	/**
	 * Gets the prev instance.
	 * 
	 * @return the prev instance
	 * 
	 * @throws SQLException the SQL exception
	 */
	public Department getPrevInstance()throws SQLException{
		if(!prevInstanceRead){
			prevInstance = getInstance(getPlanyear()-1);
			prevInstanceRead = true;
		}
		return prevInstance;
	}
	
	public Icon getIcon(){
		return IconsFactory.ICON_DEPARTMENT;
	}
	
	public int compareTo(Object o){
		if(o instanceof Department){
			if(getPlanyear()>((Department)o).getPlanyear())
				return -1;
			if(getPlanyear()<((Department)o).getPlanyear())
				return 1;
			return 0;
		}
		return super.compareTo(o);
	}

	public Collection<Zone> getChildren(int simId) throws SQLException {
		TreeSet<Zone> zones = new TreeSet<Zone>();
		for(Zone zone:getZones())
			if(zone.getZoneId() != Zone.OTHER)
				zones.add(zone);
		return zones;
	}
	
	public Department getPlanYearInstance(int planyear)throws SQLException{
		return getInstance(planyear);
	}
	
	public AgObject getParent()throws SQLException {
		return null;
	}

	/*
	 * (non-Javadoc)
	 * @see com.sce.mdi.object.AgObject#isDownStreamOf(com.sce.mdi.object.CoreObject)
	 */
	public boolean isDownStreamOf(CoreObject co)throws SQLException{
		if(co == null)
			return true;//BJS changed for reports
		return false;
	}
	
	/**
	 * Returns the growth rate based on the planFor unless
	 * the lse does not have load in the first year.
	 * 
	 * @return - Growth Rate
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getESMGrowthRate(int simId)throws SQLException{
		double sp = getYear(simId, getEsmGrowthRateStartYear()).getEsmForecast();		   
		double f = getYear(simId, getEsmGrowthRateStartYear()+getESMGrowthRateRange(simId)).getEsmForecast();   
		if(sp!=0)
			return Math.pow(f/sp,1.0/(getESMGrowthRateRange(simId)))-1;
		return 0;
	}
	
	/**
	 * Returns the first year the lse has load for the growth rate.
	 * 
	 * @return - Growth Rate Start Year
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getEsmGrowthRateStartYear()throws SQLException{
		return getPlanyear()-1;
	}
	
	/**
	 * Returns the number of years used for the growth rate.
	 * 
	 * @return Growth Rate Range
	 * 
	 * @throws SQLException the SQL exception
	 */	    
	public int getESMGrowthRateRange(int simId)throws SQLException{
		int y=0;
		
		if(getYear(simId, getEsmGrowthRateStartYear()).getEsmForecast()==0)
			return y;
		
		for(y = 0; y <= 10;y++)
			if(getYear(simId, getEsmGrowthRateStartYear()+y).getEsmForecast() > 0 && getYear(simId, getEsmGrowthRateStartYear()+y+1).getEsmForecast() == 0)
				return y;
		
		return y;
	}
	
	/**
	 * Returns the first year the lse has load for the growth rate.
	 * @return - Growth Rate Start Year
	 * @throws SQLException the SQL exception
	 */
	public int getMeterGrowthRateStartYear()throws SQLException{
		return getPlanyear()-1;
	}
	
	public double getMeterGrowthRate(int simId)throws SQLException{
		
		double sp = getYear(simId, getMeterGrowthRateStartYear()).getEsmMeterForecast();		   
		double f = getYear(simId, getMeterGrowthRateStartYear()+getMeterGrowthRateRange(simId)).getEsmMeterForecast();	   
		
		if(sp!=0)
			return Math.pow(f/sp,1.0/(getMeterGrowthRateRange(simId)))-1;
		return 0;
	}
	
	public int getMeterGrowthRateRange(int simId)throws SQLException{
		int y=0;
		
		if(getYear(simId, getMeterGrowthRateStartYear()).getEsmMeterForecast()==0)
			return y;
		
		for(y = 0; y <= 10;y++)
			if(getYear(simId, getMeterGrowthRateStartYear()+y).getEsmMeterForecast() > 0 && getYear(simId, getMeterGrowthRateStartYear()+y+1).getEsmMeterForecast() == 0)
				return y;
		
		return y;
	}
	
	public TreeSet<Double> getVoltages() throws SQLException{
		TreeSet<Double> voltages = new TreeSet<Double>();
		for(MvaFactor mf:getMvaFactors())
			voltages.add(mf.getVoltageKv());
		return voltages;
	}	
	
	public TreeSet<PifBudget> getPifBudgets()throws SQLException{
		TreeSet<PifBudget> pifBudgets = new TreeSet<PifBudget>();
		for(PifCategory pc:getPifCategorys()){
			for(int year=getPlanyear(); year<getPlanyear()+getPlanFor(); year++){
				pifBudgets.add(PifBudget.getInstance(getPlanyear(), year, pc.getCategoryId(), PifBi.BI_350));//350
				pifBudgets.add(PifBudget.getInstance(getPlanyear(), year, pc.getCategoryId(), PifBi.BI_353));//353
			}
		}
		return pifBudgets;
	}
	
	public TreeSet<Sub> getSubs()throws SQLException{
		TreeSet<Sub> subs = new TreeSet<Sub>(getBbanks());
		subs.addAll(getAbanks());
		return subs;
	}
	
	public Collection<User> getUsers() throws SQLException{
		return User.getAll();
	}
	
	/*
	 */
	public Collection<TimeCrisis> getTimeCrisiss()throws SQLException{
		return TimeCrisis.getAll();
	}
	
	/**
	 * This method overrides the native DAO method
	 * thats auto created;  an error will be crated
	 * when the department object is auto created.
	 * We need to consider when to add Delete_TS to
	 * the object creator for certain objects such as LgProj.
	 * 
	 * @return a new TreeSet each time
	 * @throws SQLException
	 */
	public TreeSet<LgProj> getLgProjs()throws SQLException{
		TreeSet<LgProj>	lgProjs = new TreeSet<LgProj>();
		for(LgProj lgp: super.getLgProjs())
			if(lgp.getDeletedTs()==null)
				lgProjs.add(lgp);
		return lgProjs;
	}
	
	public CoType getCoType() throws SQLException{
		return CoType.getInstance(CoType.DEPARTMENT);
	}

	public Calendar getCutOverDate() {
		return getInsertTs();
	}
	
	/**
	 * You would think an important business logic
	 * decision like this one would be documented.
	 * 
	 * @return a DROP date
	 * @throws SQLException
	 */
	public Calendar getDropDate() throws SQLException{
		Calendar cal = Calendar.getInstance();
		cal.add(Calendar.DATE, 1);
		if(Department.getActivePlanYear() == getPlanyear())
			return cal;
		Department d = Department.getInstance(getPlanyear()+1);
		if(d == null)
			return cal;
		cal = (Calendar)d.getCutOverDate().clone();
		cal.add(Calendar.DATE, -1);
		return cal;
	}

	public static Department getActiveInstance() throws SQLException {
		return Department.getInstance(getActivePlanYear());
	}

	public static int getPlanYear(Calendar date) throws SQLException {
		for(Department d:getAll())
			if(d.getCutOverDate().compareTo(date) < 0)
				return d.getPlanyear();
		return 0;
	}
	
	public double getPrimaryKv() throws SQLException {
		return 500;
	}
}
