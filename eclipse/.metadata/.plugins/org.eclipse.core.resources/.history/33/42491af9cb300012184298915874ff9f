/**
 *           | Master Data Interface Version 2.0 |                       
 * 
 * Copyright (c) 2006, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team. 					  
 * 	                   All rights reserved.
 * 
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
package com.sce.esp.object.model;

import java.sql.SQLException;
import java.util.Vector;

import javax.swing.JOptionPane;


/**
 * The Class OptimalBbankTie.
 * 
 * @author Distribution Staff Engineering
 * @version 2.0
 */
public class OptimalBbankTie {
	
	/** The tie. */
	private BbankTie tie;
	
	/** The tie bbank. */
	private Bbank tieBbank;
	
	/** True if tieBbank is the toSub. */
	private boolean toSub;
	
	/** The plan for. */
	private int planFor;
	
	/** The transfers. */
	private double[] transfers;
	
	/** The plan year. */
	private int planYear;
	
	/**
	 * The Constructor.
	 * 
	 * @param tie the tie
	 * @param toSub the to sub
	 * @param true if tiebbank is tosub
	 * @param planFor the plan for
	 * @param tieBbank the tie bbank
	 */
	public OptimalBbankTie(BbankTie tie,Bbank tieBbank,boolean toSub,int planFor) {
		this.tie=tie;
		this.tieBbank=tieBbank;
		this.toSub=toSub;
		this.planFor=planFor;
		this.transfers=new double[planFor];
		this.planYear=tieBbank.getPlanyear();
	}
	
	/**
	 * Gets the tie.
	 * 
	 * @return the tie
	 */
	public BbankTie getTie() {
		return tie;
	}
	
	/**
	 * Gets the tie bbank.
	 * 
	 * @return the tie bbank
	 */
	public Bbank getTieBbank() {
		return tieBbank;
	}
	
	/**
	 * Gets the to sub.
	 * 
	 * @return the to sub
	 */
	public boolean isToSub() {
		return toSub;
	}
	
	/**
	 * Gets the transfers.
	 * 
	 * @return the transfers
	 */
	public double[] getTransfers() {
		return transfers;
	}
	
	/**
	 * Gets the transfer.
	 * 
	 * @param year the year
	 * 
	 * @return the transfer
	 */
	public double getTransfer(int year) {
		return transfers[year-planYear];
	}
	
	/**
	 * Gets the optimal transfers for the current tie.
	 * 
	 * @param year the year
	 * 
	 * @return the total transfers up until the year that is passed
	 */
	public double getTotalOptTransfers(int year) {
		double transTot=0;
		int dir=toSub?1:-1;
		for(int i=0; i<year+1-planYear; i++)
			transTot+=transfers[i]*dir;
		return transTot;
	}
	
	/**
	 * Sets the transfer.
	 * 
	 * @param transAmount the trans amount
	 * @param year the year
	 */
	public void setTransfer(int year, double transAmount) {
		transfers[year-planYear] = transAmount;
	}
	
	/**
	 * Gets the plan year.
	 * 
	 * @return the plan year
	 */
	public int getPlanYear() {
		return planYear;
	}
	
	/**
	 * Gets the plan for.
	 * 
	 * @return the plan for
	 */
	public int getPlanFor() {
		return planFor;
	}
	
	/**
	 * Gets the real transfers for the current tie;.
	 * 
	 * @param year the year
	 * 
	 * @return the total root transfers
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getTotalRealTransfers(int year) throws SQLException{
		double rootTrans=0;
		int dir=toSub?1:-1;
		for(int i=0; i<year+1-planYear; i++)
			rootTrans+=tie.getTransfer(i+planYear).getTransfer()*dir;
		return rootTrans;
	}
	
	/**
	 * Calculates the reserve by removing the real transfers and
	 * adding in the optimal transfers.
	 * 
	 * @param year the year
	 * 
	 * @return the reserve
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getCritReserve(int year) throws SQLException{
		BbankYear by = tieBbank.getYear(tie.getSimId(),year);
		double res = by.getPLLBizLogic()-((1+by.getDRF())*(by.getProjLoad()-getTotalRealTransfers(year)+getTotalOptTransfers(year)));
		return res;
	}
	
	/**
	 * Calculates the reserve by removing the real transfers and
	 * adding in the optimal transfers.
	 * 
	 * @param year the year
	 * 
	 * @return the reserve
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getCritReserveHC(int year) throws SQLException{
		BbankYear by = tieBbank.getYear(tie.getSimId(),year);
		double res = by.getPLLBizLogic()-((1+by.getDRF())*(by.getProjLoadHC()-getTotalRealTransfers(year)+getTotalOptTransfers(year)));
		return res;
	}
	
	/**
	 * Calculates the reserve by removing the real transfers and
	 * adding in the optimal transfers.
	 * 
	 * @param year the year
	 * 
	 * @return the reserve
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getCritReserveLC(int year) throws SQLException{
		BbankYear by = tieBbank.getYear(tie.getSimId(),year);
		double res = by.getPLLBizLogic()-((1+by.getDRF())*(by.getProjLoadLC()-getTotalRealTransfers(year)+getTotalOptTransfers(year)));
		return res;
	}
	
	/**
	 * Constructor that does not take startyear or endyear.
	 * It will default 0 for startyear and endyear.
	 * 
	 * @param bbank the bbank
	 * @param updateDb the update db
	 * @param planYear the plan year
	 * @param simId the sim id
	 * @param planFor the plan for
	 * 
	 * @return the vector< optimal bbank tie>
	 */
	public static Vector<OptimalBbankTie> setupOptimizer(int planYear,int simId,int planFor,Bbank bbank,boolean updateDb) {
		return setupOptimizer(planYear,simId,planFor,bbank,0,0,updateDb);
	}
	
	/**
	 * This method sets up the optimizer by setting all the controllable variables.
	 * 
	 * @param endYear the end year
	 * @param bbank the bbank
	 * @param maxTransferAmount the max transfer amount
	 * @param updateDb the update db
	 * @param startYear the start year
	 * @param planYear the plan year
	 * @param simId the sim id
	 * @param planFor the plan for
	 * 
	 * @return the vector< optimal bbank tie>
	 */
	public static Vector<OptimalBbankTie> setupOptimizer(int planYear,int simId,int planFor,Bbank bbank,int startYear,int endYear,boolean updateDb) {
		try {
			String startMessage = "This will remove any existing outgoing transfers\n and add new outgoing transfers in an attempt to\n eliminate negative reserves for this substation.\n\n  Do you wish to continue?";
			if(JOptionPane.showConfirmDialog(null,startMessage,"Overwrite Confirmation",JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION)
				return null;
			double maxTrans=0;
			double minTrans=0;
			boolean error;
			do {
				error=false;
				String max = JOptionPane.showInputDialog(null,"Input maximum transfer allowed","Max Transfer",JOptionPane.QUESTION_MESSAGE);
				if(max==null) return null;
				maxTrans = Double.parseDouble(max);
				if(maxTrans<0) {
					JOptionPane.showMessageDialog(null,"Please input a positive value for the maximum transfer","Optimizer Error",JOptionPane.ERROR_MESSAGE);
					error=true;
				}
				if(!error) {
					String min = JOptionPane.showInputDialog(null,"Input minimum transfer increment desired","Min Transfer",JOptionPane.QUESTION_MESSAGE);
					if(min==null) return null;
					minTrans = Double.parseDouble(min);
					if(minTrans<0) {
						JOptionPane.showMessageDialog(null,"Please input a positive value for the minimum transfer increment","Optimizer Error",JOptionPane.ERROR_MESSAGE);
						error=true;
					}
				}
				if(!error && minTrans>maxTrans) {
					JOptionPane.showMessageDialog(null,"You entered a minimum transfer increment that is greater than the maximum transfer","Optimizer Error",JOptionPane.ERROR_MESSAGE);
					error=true;
				}
			} while(error);
			Vector<Integer> years = new Vector<Integer>();
			for(int x=0; x<planFor; x++)
				years.add(planYear+x);
			if(startYear==0) {
				Object sYear = JOptionPane.showInputDialog(null,"Select the first year to optimize","Start Year",JOptionPane.QUESTION_MESSAGE,null,years.toArray(),planYear);
				if(sYear==null) return null;
				startYear = (Integer)sYear;
			}
			if(endYear==0) {
				Object eYear = JOptionPane.showInputDialog(null,"Select the last year to optimize","End Year",JOptionPane.QUESTION_MESSAGE,null,years.toArray(),startYear);
				if(eYear==null) return null;
				endYear = (Integer)eYear;
			}
	    	if(startYear>endYear)
	    		endYear=startYear;
	    	String message = "Optimizer will run with a max transfer of "+Math.round(maxTrans)+"(A) and a minimum transfer increment of "+Math.round(minTrans)+"(A) from "+startYear+" to "+endYear;
	    	JOptionPane.showMessageDialog(null,message,"Optimizer Summary",JOptionPane.INFORMATION_MESSAGE);
	    	return createOptimalTies(planYear,simId,planFor,bbank,minTrans,maxTrans,startYear,endYear,updateDb,true);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}
	
	/**
	 * Creates the optimal ties.
	 * 
	 * @param bbank the bbank
	 * @param planYear the plan year
	 * @param simId the sim id
	 * @param planFor the plan for
	 * 
	 * @return the vector< optimal bbank tie>
	 */
	public static Vector<OptimalBbankTie> createOptimalTies(int planYear,int simId,int planFor,Bbank bbank) {
		return createOptimalTies(planYear,simId,planFor,bbank,0,0,planYear,planYear+planFor-1,false,false);
	}
	
	/**
	 * This method will create the optimalbbanktie objects
	 * and remove incoming transfers if the tie sub has adequate reserve.
	 * 
	 * @param optimize the optimize
	 * @param bbank the bbank
	 * @param endYear the end year
	 * @param startYear the start year
	 * @param updateDb the update db
	 * @param planYear the plan year
	 * @param maxTrans the max trans
	 * @param simId the sim id
	 * @param planFor the plan for
	 * @param minTrans the min trans
	 * 
	 * @return the vector< optimal bbank tie>
	 */
	public static Vector<OptimalBbankTie> createOptimalTies(int planYear,int simId,int planFor,Bbank bbank,double minTrans,double maxTrans,int startYear,int endYear,boolean updateDb,boolean optimize) {
		Vector<OptimalBbankTie> optTies = new Vector<OptimalBbankTie>();
		try {
    		for(BbankTie tie : bbank.getActiveFromTies(simId)) {
				Bbank tieBB = (Bbank)tie.getToSub();
				OptimalBbankTie ot = new OptimalBbankTie(tie,tieBB,true,planFor);
				for(int y=planYear; y<planYear+planFor; y++) {
					double transVal = tie.getTransfer(y).getTransfer();
					if(y>=startYear && y<=endYear) {
						if(transVal<0) {
							if(tieBB.getYear(simId,y).getCriteriaReserve()>-1*transVal*(1+tieBB.getYear(simId,y).getDRF()))
								ot.setTransfer(y,0);
							else
								ot.setTransfer(y,transVal);
						}
					} else
						ot.setTransfer(y,transVal);
				}
				optTies.add(ot);
			}
    		for(BbankTie tie : bbank.getActiveToTies(simId)) {
				Bbank tieBB = (Bbank)tie.getFromSub();
				OptimalBbankTie ot = new OptimalBbankTie(tie,tieBB,false,planFor);
				for(int y=planYear; y<planYear+planFor; y++) {
					double transVal = tie.getTransfer(y).getTransfer(); 
					if(y>=startYear && y<=endYear) {
						if(transVal>0) {
							if(tieBB.getYear(simId,y).getCriteriaReserve()>transVal*(1+tieBB.getYear(simId,y).getDRF()))
								ot.setTransfer(y,0);
							else
								ot.setTransfer(y,transVal);
						}
					} else
						ot.setTransfer(y,transVal);
				}
				optTies.add(ot);
			}
    		if(optimize)
    			return optimizeTransfers(simId,optTies,bbank,minTrans,maxTrans,startYear,endYear,updateDb);
    		else
    			return optTies;
		} catch(Exception e) {
			e.printStackTrace();
		}
		return null;
	}
	
	/**
	 * This method loops through the desired years and sorts the optimal ties
	 * by their reserve descending.  Transfers are then made to the optimal ties
	 * until the home bbank's reserve > 0 or until the ties have depleted their reserves.
	 * 
	 * @param bbank the bbank
	 * @param endYear the end year
	 * @param startYear the start year
	 * @param updateDb the update db
	 * @param maxTrans the max trans
	 * @param simId the sim id
	 * @param optTies the opt ties
	 * @param minTrans the min trans
	 * 
	 * @return the vector< optimal bbank tie>
	 */
	private static Vector<OptimalBbankTie> optimizeTransfers(int simId,Vector<OptimalBbankTie> optTies,Bbank bbank,double minTrans,double maxTrans,int startYear,int endYear,boolean updateDb) {
		try {
    		for(int year=startYear; year<endYear+1; year++) {
				double reserve=0;
				BbankYear by = bbank.getYear(simId,year);
				double optTransTot=0;
				for(OptimalBbankTie obt : optTies)
					optTransTot+=obt.getTotalOptTransfers(year);
				reserve = by.getPLLBizLogic()-((by.getProjLoad()-by.getDirectTransferTotal()-optTransTot)*(1+by.getDRF()));
				if(reserve<0) {
					for(int i=0; i<optTies.size(); i++) {
						if(reserve<0) {
							OptimalBbankTie opt=null;
							double tieReserve=0;
							for(OptimalBbankTie optTie : optTies) {
								if(optTie.getTie().isStrong() && optTie.getCritReserve(year)>0 && optTie.getCritReserve(year)>tieReserve && optTie.getTransfer(year)==0) {
									opt=optTie;
									tieReserve=opt.getCritReserve(year);
								}
							}
							if(opt!=null) {
								int dir=-1;
								if(opt.isToSub())
									dir=1;
								double need = Math.round(reserve/(1+by.getDRF())*-1*by.getSub().getMVAFactor());
								double avail = Math.round(tieReserve/(1+by.getDRF())*by.getSub().getMVAFactor());
								double transAmount=getOptimalTransAmount(need,avail,maxTrans,minTrans,by);
								opt.setTransfer(year, transAmount*dir);
								reserve += transAmount*(1+by.getDRF());
							}
						}
					}
				}
			}
			if(updateDb)
				setOptimalTransfers(optTies);
			return optTies;
    	} catch (Exception e) {
    		e.printStackTrace();
    	}
    	return null;
    }
	
	/**
	 * This method calculates the transfer amount by taking into
	 * account what is needed, what is available and what the
	 * user has stated is the max and min transfers.
	 * 
	 * @param need the need
	 * @param min the min
	 * @param max the max
	 * @param by the by
	 * @param avail the avail
	 * @param minInc the min inc
	 * 
	 * @return the optimal trans amount
	 */
	private static double getOptimalTransAmount(double need,double avail,double max,double min,BbankYear by) {
		double transAmount=0;
		max = (int)Math.floor(max/min)*min;
		need = (int)Math.ceil(need/min)*min;
		avail = (int)Math.floor(avail/min)*min;
		try {
			if(avail < min)
				return 0;
			else {
				if(need < min)
					need = min;
				if(need < max) {
					if(need < avail)
						transAmount=need;
					else
						transAmount=avail;
				} else {
					if(max < avail)
						transAmount=max;
					else
						transAmount=avail;
				}
			}
			transAmount/=by.getSub().getMVAFactor();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return transAmount;
	}
	
	/**
	 * This method will update the database with the new transfers.
	 * 
	 * @param optTies the opt ties
	 */
	public static void setOptimalTransfers(Vector<OptimalBbankTie> optTies) {
		try {
			for(OptimalBbankTie ot : optTies) {
				int planYear = ot.getPlanYear();
				for(int y=planYear; y<planYear+ot.getPlanFor(); y++)
					ot.getTie().getTransfer(y).setTransfer(ot.getTransfer(y));
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
