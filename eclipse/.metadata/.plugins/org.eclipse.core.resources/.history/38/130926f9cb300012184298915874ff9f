package com.sce.esp.object.model;

import java.io.Serializable;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Collection;
import java.util.Hashtable;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.Vector;

import javax.persistence.Entity;
import javax.persistence.NamedNativeQueries;
import javax.persistence.NamedNativeQuery;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;

import com.sce.esp.object.dao.SceProjElemCostDAO;
import com.sce.esp.util.Calculate;
import com.sce.esp.util.FormatText;
import com.sce.esp.util.StringPool;
import com.sce.esp.util.StringUtils;
@Entity
@Table(schema="MDI",name="MDIS80_SCE_PROJ_ELEM_COST")
@NamedQueries({
	@NamedQuery(name = "findByID", query="SELECT o FROM SceProjElemCost o WHERE o.COST_ID=?1"),//AUTO-GENERATED
	@NamedQuery(name = "findAll", query="SELECT o FROM SceProjElemCost o"),//AUTO-GENERATED
	@NamedQuery(name = "findAllActive", query="SELECT o FROM SceProjElemCost o WHERE o.DELETED_TS IS NULL"),//AUTO-GENERATED
	@NamedQuery(name = "findBySceProjRev", query="SELECT o FROM SceProjElemCost o WHERE o.SCE_PROJ_REV_ID=?1 AND o.DELETED_TS IS NULL"),//AUTO-GENERATED
	@NamedQuery(name = "findByFacility", query="SELECT o FROM SceProjElemCost o WHERE o.CO_TYPE_ID=?1 AND o.FACILITY_ID=?2 AND o.DELETED_TS IS NULL"),
	@NamedQuery(name = "findBySub", query="SELECT o FROM SceProjElemCost o WHERE o.CO_TYPE_ID=?1 AND o.FACILITY_ID=?2"),
})
@NamedNativeQueries({
	@NamedNativeQuery(name = "refresh", query="SELECT o.* FROM MDIS80_SCE_PROJ_ELEM_COST o WHERE o.COST_ID=?"),//AUTO-GENERATED
})
public class SceProjElemCost extends SceProjElemCostDAO implements CostObject, Serializable{

	private static final long serialVersionUID = 8086072592730099249L;

	public final static int COST_SEARCH_RANGE=10;

	//PEC Stage Arch.========================================================================
	public final static int APPROVED = 0;
	public final static int PLAN_EST = 1;
	public final static int PWEE_COST = 2;
	public final static int WO_COST = 3;
	public final static String[] STAGE_NAME = StringPool.STAGE_NAME;
	public final static int[] COST_STAGES = {APPROVED,PLAN_EST,PWEE_COST,WO_COST};

	public final static String INFO_FIELDS = StringPool.INFO_FIELDS;
	public final static String BSS_FIELDS = StringPool.BSS_FIELDS;
	public final static String ALWAYS_FIELDS = StringPool.ALWAYS_FIELDS;

	private static int tempId = 0;

	public synchronized static int getTempId(){
		return --tempId;
	}

	public SceProjElemCost() throws SQLException{
		super(getTempId());
	}

	public SceProjElemCost(int costId) throws SQLException {
		super(costId);
	}

	public SceProjElemCost(SceProjElemCost sceProjElemCost) {
		super(sceProjElemCost);
		try {
			setCostId(getTempId());
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public SceProjElemCostYear getSceProjElemCostYear(int year) throws SQLException {
		return SceProjElemCostYear.getInstance(getCostId(), year);
	}

	public Vector<String> getInsertStatus(){
		Vector<String> errors = new Vector<String>();
		if(isNull(getSceProjRevId())) errors.add("SCE PROJ REV ID is Required.");
		if(isNull(getSceElemId())) errors.add("SCE ELEM ID is Required.");
		if(isNull(getProposedOd())) errors.add("PROPOSED OD is Required.");
		return errors;
	}

	public String getStageTitle() throws SQLException{
		if(getTitle() != null && getTitle().length() > 0)	
			return getTitle();
		return "Miscellaneous";
	}	

	public String getScopeWithStage() throws SQLException{
		String s="N/A";
		if(getScopeDesc()!=null)
			s=getScopeDesc();
		//Temporarily removed this logic until necessary HiK
		//if(getCostStageId() != PLAN_EST)
		s += " ("+getSapOrderNumBl()+")";

		return s;
	}

	public String getSapWbsBl() {
		String s="SAP Seq N/A";
		try {
			if(getSceProjRev().getProjNum()!=null && getSapWbs()!=null) //seq = 0 allowed?
				s = getSapWbs()+"-"+getSceProjRev().getProjNum()+"-"+getSapWbsSeq();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return s;
	}

	private String getSapOrderNumBl() {
		String s="SAP Order # ";
		if(getSapOrderNum()!=null) 
			s += getSapOrderNum();
		else 
			s += "N/A";
		return s;
	}

	//
	public int getPriorCost()throws SQLException{
		if(!isEnabled())
			return 0;
		int prior=0;
		int curYear = Calendar.getInstance().get(Calendar.YEAR);
		if(isUseUnitCost()){
			for(ScopeItem si:getScopeItems())
				prior += si.getPriorCost();
		}else
			for(SceProjElemCostYear pecy:getSceProjElemCostYears())
				if(pecy.getYear() < curYear)
					prior += pecy.getCost();
		return prior;
	}


	// 
	public int getSubTotalCost()throws SQLException{
		if(getCostStage().getCostType()==CostStage.Type.Proposed.ordinal() && !isEnabledBl())
			return getPriorCost();
		int total=0;
		if(isUseUnitCost()){
			for(ScopeItem si:getScopeItems())
				if(si.isEnabled())
					total += si.getSubTotalCost();
		}else
			for(SceProjElemCostYear pecy:getSceProjElemCostYears())
				total += pecy.getCost();
		return total;
	}

	//
	public int getCost(int year)throws SQLException{
		if(isUseUnitCost()){
			int cost=0;
			int curYear = Calendar.getInstance().get(Calendar.YEAR);
			for(ScopeItem si:getScopeItems())
				if(si.isEnabled() || year < curYear)
					cost += si.getCost(year);
			return cost;
		}
		for(SceProjElemCostYear specy: getSceProjElemCostYears())
			if(specy.getYear() == year)
				return specy.getCost();
		return 0;
	}

	public SapWbs getSapWbs() throws SQLException {
		return SapWbs.getInstance(getSapWbsId());
	}

	public void setSapWbs(SapWbs sapWbs) throws SQLException {
		setSapWbsId(sapWbs.getSapWbsId());
	}

	public int getCalendarYear(){
		if(getModelDate()!=null)
			return getModelDate().get(Calendar.YEAR);
		return 0;
	}

	public int getPeakYear(int planyear) throws SQLException{
		return Department.getEffYear(planyear, getModelDate());
	}

	public int getFiscalYear(){
		if(getModelDate()!=null)
			return getModelDate().get(Calendar.YEAR);
		return 0;
	}

	/**
	 * Arch. allows multiple priorities, this method returns the most recent (current)
	 * 
	 * @return collection of Current SceProjElemPriority
	 * @throws SQLException
	 */
	public TreeSet<SceProjElemPriority> getCurrentSceProjElemPrioritys() throws SQLException {
		TreeSet<SceProjElemPriority> speps  = new TreeSet<SceProjElemPriority>();
		for(SceProjElemPriority spep: getSceProjElemPrioritys())
			if(speps.isEmpty() || speps.last().getCostId() != spep.getCostId() || speps.last().getYear()!= spep.getYear())
				speps.add(spep);
		return speps;
	}

	public void setProposedOd(Calendar proposedOd, boolean escalate)throws SQLException{
		setCostStageId(CostStage.PLAN_EST);
		int curYear = Calendar.getInstance().get(Calendar.YEAR);
		int delta = proposedOd.get(Calendar.YEAR) - getProposedOd().get(Calendar.YEAR);
		setNeedDate(proposedOd);
		if(escalate){
			escalateProjElemCostYears(curYear,delta);
			escalateScopeItemCostYears(curYear,delta);
		}

	}
	private void escalateProjElemCostYears(int curYear, int delta) throws SQLException{
		TreeSet<SceProjElemCostYear> newCosts = new TreeSet<SceProjElemCostYear>();
		SceProjElemCostYear firstYear=null;
		for(SceProjElemCostYear specy:new TreeSet<SceProjElemCostYear>(getSceProjElemCostYears())){
			if(specy.getYear() >= curYear){
				if(specy.getYear() + delta <= curYear){
					if(firstYear == null)
						firstYear = new SceProjElemCostYear(getCostId(),curYear);
					firstYear.setCost(firstYear.getCost() + specy.getCost(curYear));
				}
				else{
					SceProjElemCostYear copy = specy.copy();
					copy.setYear(specy.getYear()+delta);
					copy.setCost(specy.getCost(copy.getYear()));
					newCosts.add(copy);
				}
				specy.deleteDB();
			}
		}
		for(SceProjElemCostYear specy:newCosts)
			specy.insert();
		if(firstYear != null)
			firstYear.insert();
	}
	private void escalateScopeItemCostYears(int curYear, int delta) throws SQLException{
		for(ScopeItem si:getScopeItems()){
			TreeSet<ScopeItemCostYear> newCosts = new TreeSet<ScopeItemCostYear>();
			ScopeItemCostYear firstYear=null;
			for(ScopeItemCostYear sicy:new TreeSet<ScopeItemCostYear>(si.getScopeItemCostYears())){
				if(sicy.getYear() >= curYear){
					if(sicy.getYear() + delta <= curYear){
						if(firstYear == null)
							firstYear = new ScopeItemCostYear(getCostId(),curYear);
						firstYear.setCost(firstYear.getCost() + sicy.getCost(curYear));
					}
					else{
						ScopeItemCostYear copy = sicy.copy();
						copy.setYear(sicy.getYear()+delta);
						copy.setCost(sicy.getCost(copy.getYear()));
						newCosts.add(copy);
					}
					sicy.deleteDB();
				}
			}
			for(ScopeItemCostYear sicy:newCosts)
				sicy.insert();
			if(firstYear != null)
				firstYear.insert();
		}
	}

	public String toString(){
		StringBuffer buffer = new StringBuffer("");
		try {
			buffer.append(getStageTitle()).append(" (").
			append(getCalendarYear()).append(")");

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return buffer.toString();
	}

	/**
	 * isEnabled and ProjRev isEnabledBl
	 */
	public boolean isEnabledBl() throws SQLException {
		return isEnabled() && (getSceProjRev() == null || getSceProjRev().isEnabledBl());
	}

	public boolean isUseUnitCost() throws SQLException{
		return getCostStage().isUnitCostable() && isUseCalc();
	}

	public void setUseUnitCost(boolean useUnitCost) throws SQLException{
		setUseCalc(useUnitCost);
	}
	public FacilityObject getFacilityObject(int planyear) throws SQLException{
		return getFacilityObject(planyear, getSimId());
	}
	public FacilityObject getFacilityObject(int planyear, int simId) throws SQLException{
		if(getCoTypeId() != 0)
			return CoType.getInstance(getCoTypeId()).getFacilityObject(planyear,simId,getFacilityId());
		return null;
	}
	public SceProjElemCost getPriorSceProjElemCost(int planyear,int simId) throws SQLException{
		if(getFacilityObject(planyear) != null){
			SortedSet<SceProjElemCost> headSet = getFacilityObject(planyear).getSceProjElemCosts().headSet(this);
			if(headSet.size() > 0){
				if(headSet.last().isActiveBl(planyear,simId))
					return headSet.last();
				return headSet.last().getPriorSceProjElemCost(planyear,simId);
			}
		}
		return null;
	}
	//Circuit Functions
	public TreeSet<Ckt> getCktsPre(int planyear,int simId,Collection<SceProjElemCost> without)throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getCktsPost(planyear,simId,without);
		return new TreeSet<Ckt>();
	}
	public TreeSet<Ckt> getCktsAdd(int planyear)throws SQLException{
		TreeSet<Ckt> ckts = new TreeSet<Ckt>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() > 0 && si.getModelingObject(planyear) instanceof Ckt)
				ckts.add((Ckt)si.getModelingObject(planyear));
		return ckts;
	}
	public TreeSet<Ckt> getCktsRem(int planyear)throws SQLException{
		TreeSet<Ckt> ckts = new TreeSet<Ckt>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() < 0 && si.getModelingObject(planyear) instanceof Ckt)
				ckts.add((Ckt)si.getModelingObject(planyear));
		return ckts;
	}
	public TreeSet<Ckt> getCktsPost(int planyear,int simId,Collection<SceProjElemCost> without)throws SQLException{
		TreeSet<Ckt> ckts = getCktsPre(planyear,simId,without);
		if(without == null || !without.contains(this)){
			ckts.addAll(getCktsAdd(planyear));
			ckts.removeAll(getCktsRem(planyear));
		}
		return ckts;
	}
	//Subtrans Lines Functions
	public TreeSet<Stl> getStlsPre(int planyear,int simId)throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getStlsPost(planyear,simId);
		return new TreeSet<Stl>();
	}
	public TreeSet<Stl> getStlsAdd(int planyear)throws SQLException{
		TreeSet<Stl> ckts = new TreeSet<Stl>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() > 0 && si.getModelingObject(planyear) instanceof Stl)
				ckts.add((Stl)si.getModelingObject(planyear));
		return ckts;
	}
	public TreeSet<Stl> getStlsRem(int planyear)throws SQLException{
		TreeSet<Stl> ckts = new TreeSet<Stl>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() < 0 && si.getModelingObject(planyear) instanceof Stl)
				ckts.add((Stl)si.getModelingObject(planyear));
		return ckts;
	}
	public TreeSet<Stl> getStlsPost(int planyear, int simId)throws SQLException{
		TreeSet<Stl> ckts = getStlsPre(planyear,simId);
		ckts.addAll(getStlsAdd(planyear));
		ckts.removeAll(getStlsRem(planyear));
		return ckts;
	}

	//Bank Functions
	public TreeSet<Bank> getBanksPre(int planyear,int simId,Collection<SceProjElemCost> without)throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getBanksPost(planyear,simId,without);
		return new TreeSet<Bank>();
	}
	public TreeSet<Bank> getBanksAdd(int planyear)throws SQLException{
		TreeSet<Bank> banks = new TreeSet<Bank>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() > 0 && si.getModelingObject(planyear) instanceof Bank)
				banks.add((Bank)si.getModelingObject(planyear));
		return banks;
	}
	public TreeSet<Bank> getBanksRem(int planyear)throws SQLException{
		TreeSet<Bank> banks = new TreeSet<Bank>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() < 0 && si.getModelingObject(planyear) instanceof Bank)
				banks.add((Bank)si.getModelingObject(planyear));
		return banks;
	}
	public TreeSet<Bank> getBanksPost(int planyear,int simId,Collection<SceProjElemCost> without)throws SQLException{
		TreeSet<Bank> banks = getBanksPre(planyear,simId,without);
		if(without == null || !without.contains(this)){
			banks.addAll(getBanksAdd(planyear));
			banks.removeAll(getBanksRem(planyear));
		}
		return banks;
	}
	public TreeSet<Bank> getBanksEverAddedPre(int planyear,int simId)throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getBanksEverAddedPost(planyear,simId);
		return new TreeSet<Bank>();
	}
	public TreeSet<Bank> getBanksEverAddedPost(int planyear,int simId)throws SQLException{
		TreeSet<Bank> banks = getBanksEverAddedPre(planyear,simId);
		banks.addAll(getBanksAdd(planyear));
		return banks;
	}

	//Transformer Functions
	public TreeSet<Xfmr> getXfmrsPre(int planyear,int simId)throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getXfmrsPost(planyear,simId);
		return new TreeSet<Xfmr>();
	}
	public TreeSet<Xfmr> getXfmrsAdd(int planyear)throws SQLException{
		TreeSet<Xfmr> banks = new TreeSet<Xfmr>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() > 0 && si.getModelingObject(planyear) instanceof Xfmr)
				banks.add((Xfmr)si.getModelingObject(planyear));
		return banks;
	}
	public TreeSet<Xfmr> getXfmrsRem(int planyear)throws SQLException{
		TreeSet<Xfmr> banks = new TreeSet<Xfmr>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() < 0 && si.getModelingObject(planyear) instanceof Xfmr)
				banks.add((Xfmr)si.getModelingObject(planyear));
		return banks;
	}
	public TreeSet<Xfmr> getXfmrsPost(int planyear,int simId)throws SQLException{
		TreeSet<Xfmr> banks = getXfmrsPre(planyear,simId);
		banks.addAll(getXfmrsAdd(planyear));
		banks.removeAll(getXfmrsRem(planyear));
		return banks;
	}

	//Low Side Sub Var Functions
	public TreeSet<SubVar> getSubVarsLowSidePre(int planyear,int simId)throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getSubVarsLowSidePost(planyear,simId);
		return new TreeSet<SubVar>();
	}
	public TreeSet<SubVar> getSubVarsLowSideAdd(int planyear)throws SQLException{
		TreeSet<SubVar> subVars = new TreeSet<SubVar>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() > 0 && si.getModelingObject(planyear) instanceof SubVar && !si.isHighSide())
				subVars.add((SubVar)si.getModelingObject(planyear));
		return subVars;
	}
	public TreeSet<SubVar> getSubVarsLowSideRem(int planyear)throws SQLException{
		TreeSet<SubVar> subVars = new TreeSet<SubVar>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() < 0 && si.getModelingObject(planyear) instanceof SubVar && !si.isHighSide())
				subVars.add((SubVar)si.getModelingObject(planyear));
		return subVars;
	}
	public TreeSet<SubVar> getSubVarsLowSidePost(int planyear,int simId)throws SQLException{
		TreeSet<SubVar> subVars = getSubVarsLowSidePre(planyear,simId);
		subVars.addAll(getSubVarsLowSideAdd(planyear));
		subVars.removeAll(getSubVarsLowSideRem(planyear));
		return subVars;
	}
	public int getKvarLowSidePre(int planyear,int simId)throws SQLException{
		int varAdd = 0;
		for(SubVar subVar:getSubVarsLowSidePre(planyear,simId))
			varAdd += subVar.getKvar();
		return varAdd;
	}
	public int getKvarLowSideAdd(int planyear) throws SQLException{
		int varAdd = 0;
		for(SubVar subVar:getSubVarsLowSideAdd(planyear))
			varAdd += subVar.getKvar();
		return varAdd;
	}
	public int getKvarLowSideRem(int planyear) throws SQLException{
		int varAdd = 0;
		for(SubVar subVar:getSubVarsLowSideRem(planyear))
			varAdd += subVar.getKvar();
		return varAdd;
	}
	public int getKvarLowSidePost(int planyear,int simId)throws SQLException{
		int varAdd = 0;
		for(SubVar subVar:getSubVarsLowSidePost(planyear,simId))
			varAdd += subVar.getKvar();
		return varAdd;
	}
	public int getKvarLowSideDelta(int planyear)throws SQLException{
		return getKvarLowSideAdd(planyear) - getKvarLowSideRem(planyear);
	}
	//Low Side Sub Var Functions
	public TreeSet<SubVar> getSubVarsHighSidePre(int planyear,int simId)throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getSubVarsHighSidePost(planyear,simId);
		return new TreeSet<SubVar>();
	}
	public TreeSet<SubVar> getSubVarsHighSideAdd(int planyear)throws SQLException{
		TreeSet<SubVar> subVars = new TreeSet<SubVar>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() > 0 && si.getModelingObject(planyear) instanceof SubVar && si.isHighSide())
				subVars.add((SubVar)si.getModelingObject(planyear));
		return subVars;
	}
	public TreeSet<SubVar> getSubVarsHighSideRem(int planyear)throws SQLException{
		TreeSet<SubVar> subVars = new TreeSet<SubVar>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() < 0 && si.getModelingObject(planyear) instanceof SubVar && si.isHighSide())
				subVars.add((SubVar)si.getModelingObject(planyear));
		return subVars;
	}
	public TreeSet<SubVar> getSubVarsHighSidePost(int planyear,int simId)throws SQLException{
		TreeSet<SubVar> subVars = getSubVarsHighSidePre(planyear,simId);
		subVars.addAll(getSubVarsHighSideAdd(planyear));
		subVars.removeAll(getSubVarsHighSideRem(planyear));
		return subVars;
	}
	public int getKvarHighSidePre(int planyear,int simId)throws SQLException{
		int varAdd = 0;
		for(SubVar subVar:getSubVarsHighSidePre(planyear,simId))
			varAdd += subVar.getKvar();
		return varAdd;
	}
	public int getKvarHighSideAdd(int planyear) throws SQLException{
		int varAdd = 0;
		for(SubVar subVar:getSubVarsHighSideAdd(planyear))
			varAdd += subVar.getKvar();
		return varAdd;
	}
	public int getKvarHighSideRem(int planyear) throws SQLException{
		int varAdd = 0;
		for(SubVar subVar:getSubVarsHighSideRem(planyear))
			varAdd += subVar.getKvar();
		return varAdd;
	}
	public int getKvarHighSidePost(int planyear,int simId)throws SQLException{
		int varAdd = 0;
		for(SubVar subVar:getSubVarsHighSidePost(planyear,simId))
			varAdd += subVar.getKvar();
		return varAdd;
	}
	public int getKvarHighSideDelta(int planyear)throws SQLException{
		return getKvarHighSideAdd(planyear) - getKvarHighSideRem(planyear);
	}



	public void setFacilityObject(FacilityObject fo) throws SQLException {
		if(fo!=null){
			setCoTypeId(fo.getCoTypeId());
			setFacilityId(fo.getId());
		}else{
			setCoTypeId(0);
			setFacilityId(0);
		}
	}

	public void setCost(int year, int cost) throws SQLException {
		getSceProjElemCostYear(year).setCost(cost);
	}

	public double getNameplatePre(int planyear,int simId) throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getNameplatePost(planyear,simId,null);
		return 0;
	}
	/**
	 * FIXME eddie null op date
	 * 
	 * Substation Nameplate day after the project
	 * 
	 * @return double Substation Nameplate day after the project
	 * @throws SQLException 
	 * @throws SQLException
	 */
	public double getNameplatePost(int planyear,int simId,Collection<SceProjElemCost> without) throws SQLException {
		if(getModelDate()!=null){
			double np = 0;
			Calendar post = (Calendar)getModelDate().clone();
			post.add(Calendar.DATE, 1);
			for(Bank b:getBanksPost(planyear,simId,without))
				if(!b.isSpare())
					np += b.getNameplate(post,without);
			return np;
		}
		return 0;
	}

	public double getNameplateDelta(int planyear, int simId)throws SQLException{
		return getNameplatePost(planyear,simId,null) - getNameplatePre(planyear,simId);
	}
	public double getPLLFactorPre(int planyear,int simId) throws SQLException{
		return getPLLFactorPre(planyear,simId,null);
	}
	public double getPLLFactorPre(int planyear,int simId,Collection<SceProjElemCost> without) throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getPLLFactorPost(planyear,simId,without);
		return 0;
	}
	public double getPLLFactorPost(int planyear,int simId) throws SQLException{
		return getPLLFactorPost(planyear,simId,null);
	}

	//FIXME
	public double getPLLFactorPost(int planyear,int simId,Collection<SceProjElemCost> without) throws SQLException {
		if(without == null || !without.contains(this)){
			double pll = -1;
			for(ScopeItem si:getScopeItems())
				if(si.isEnabledBl() && si.getScopeType().getModelingCoTypeId() == CoType.PLL_SUB)
					pll = si.getQuantity()/100.0;
			if(pll != -1)
				return pll;
		}
		return getPLLFactorPre(planyear,simId,without);
	}
	public double getELLFactorPre(int planyear,int simId) throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getELLFactorPost(planyear,simId);
		return 0;
	}
	public double getELLFactorPost(int planyear,int simId) throws SQLException {
		double ell = -1;
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getScopeType().getModelingCoTypeId() == CoType.ELL_SUB)
				ell = si.getQuantity()/100.0;
		if(ell != -1)
			return ell;
		return getELLFactorPre(planyear,simId);
	}
	public double getN1FactorPre(int planyear,int simId) throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getN1FactorPost(planyear,simId);
		return 0;
	}
	public double getN1FactorPost(int planyear,int simId) throws SQLException {
		double n1 = -1;
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getScopeType().getModelingCoTypeId() == CoType.N1_BBANK)
				n1 = si.getQuantity()/100.0;
		if(n1 != -1)
			return n1;
		return getN1FactorPre(planyear,simId);
	}

	/**
	 * Method to check if a Bank is being assigned in the ScopeItems, due to potential SI Bank/FO assignment not matching Cost FO
	 * @return boolean True = getScopeItems contains Xfmr
	 * @throws SQLException
	 */
	public boolean isContainingBankScopeItem()throws SQLException{
		for(ScopeItem s: getScopeItems()){
			if(s.getCoTypeId() == CoType.BANK)
				return true;
		}
		return false;
	}

	public boolean isInService() throws SQLException {
		return getInServiceDate() != null && isEnabledBl();
	}

	/**
	 * Returns a decoded text representation of the elem 
	 * scope based on default title selection.
	 * 
	 * @return the decoded element scope
	 */
	public String getScopeDesc(){
		return decodeVariables(getScopeActual());
	}


	/**
	 * Returns the elemtn scope encoded for preprocessors
	 * or it returns the stored database scope (based on default
	 * title selection).
	 * 
	 * @return the derived default title based on scope items.
	 */
	public String getScopeActual() {
		if(isUseDefaultScope() || getScope()==null || getScope().length()==0){
			try {
				return getActualDefaultScope();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		return getScope();
	}
	
	/**
	 * Decodes VARIABLES used in Project Title and GRC Testimony 
	 * 
	 * @param input
	 * @return String
	 * @throws SQLException 
	 */
	public String decodeVariables(String titleText) {
		//return the original title text if null
		if(titleText!=null && titleText.length()>0) {
			try {//FYI - this is the actual decode method call
				titleText = deriveExpression(titleText);
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		return titleText;
	}

	//FIXME use buffer
	//FIXME use buffer
	private String deriveExpression(String preprocessorTest) throws SQLException{
		if(preprocessorTest!=null && preprocessorTest.length()>0 && preprocessorTest.contains("&")) {
			//			Hashtable<Integer, LinkedList<ScopeItem>> hash = new Hashtable<Integer, LinkedList<ScopeItem>>();

			int pY=0;
			if(getSceProjRev()==null)
				pY = Department.getActivePlanYear();
			else
				pY = getSceProjRev().getPlanYear();

			//===============================================
			//iterate through my unique list
			//===============================================
			for(ScopeItem scopeItem: getScopeItems()){
				if(scopeItem.isEnabledBl() ){
					FacilityObject fo = scopeItem.getFacilityObject(pY); 
					//@Facility
					preprocessorTest=preprocessorTest.replaceAll("&Facility:"+scopeItem.getScopeSummaryIdentifier(), ""+fo);
					if(fo != null){
						//&PrimaryKv
						preprocessorTest=preprocessorTest.replaceAll("&PrimaryKv:"+scopeItem.getScopeSummaryIdentifier(), fo.getPrimaryKv()+"");
						//&SecondaryKv
						preprocessorTest=preprocessorTest.replaceAll("&SecondaryKv:"+scopeItem.getScopeSummaryIdentifier(), fo.getSecondaryKv()+"");
					}
					//&CktCountAfter
					preprocessorTest=preprocessorTest.replaceAll("&CktCountAfter:"+scopeItem.getScopeSummaryIdentifier(), ""+getCktsPost(pY, getSimId(),null).size());
					//&CktCountBefore
					preprocessorTest=preprocessorTest.replaceAll("&CktCountBefore:"+scopeItem.getScopeSummaryIdentifier(), ""+getCktsPre(pY, getSimId(),null).size());

					//&capAdd	
					if(scopeItem.getScopeType().getModelingCoTypeId()==CoType.TRANSFORMER ){

						preprocessorTest=preprocessorTest.replaceAll("&CapAdd:"+scopeItem.getScopeSummaryIdentifier(), ""+Calculate.round(scopeItem.getQuantity(),1));
						//if(scopeItem.getSceProjElemCost()!=null)
						preprocessorTest=preprocessorTest.replaceAll("&CapAddPre:"+scopeItem.getScopeSummaryIdentifier(), 
								""+Calculate.round(getNameplatePre(pY, getSimId()),1));
						//if(scopeItem.getSceProjElemCost()!=null)
						preprocessorTest=preprocessorTest.replaceAll("&CapAddPost:"+scopeItem.getScopeSummaryIdentifier(), 
								""+Calculate.round(getNameplatePost(pY, getSimId(), null),1));
					}

					//&CktAdd || &CktRemove
					if(scopeItem.getScopeType().getModelingCoTypeId()==CoType.CIRCUIT){
						preprocessorTest=preprocessorTest.replaceAll("&CktAdd:"+scopeItem.getScopeSummaryIdentifier(), ""+Math.round(scopeItem.getQuantity()));
						preprocessorTest=preprocessorTest.replaceAll("&CktRemove:"+scopeItem.getScopeSummaryIdentifier(), ""+Math.round(scopeItem.getQuantity()));
					}

					//&VarAdd || &VarRemove
					if(scopeItem.getScopeType().getModelingCoTypeId()==CoType.SUB_VAR){
						preprocessorTest=preprocessorTest.replaceAll("&VarAdd:"+scopeItem.getScopeSummaryIdentifier(), ""+Calculate.round(scopeItem.getQuantity(),1));
						preprocessorTest=preprocessorTest.replaceAll("&VarRemove:"+scopeItem.getScopeSummaryIdentifier(), ""+Calculate.round(scopeItem.getQuantity(),1));
					}
				}
			}

		}
		return preprocessorTest;
	}

	private String getActualDefaultScope() throws SQLException {
		StringBuffer defaultScope = new StringBuffer();

		//===============================================
		//iterate through my unique list
		//===============================================
		for(ScopeItem s: getScopeItems()){
			if(s.isEnabledBl() ){

				//Remove a Transformer
				if(s.getScopeType().getModelingCoTypeId()==CoType.TRANSFORMER && s.getScopeType().getDefaultQuantity()==-1){
					defaultScope.append("Decrease transformer capacity from &CapAddPre:").
					append(s.getScopeSummaryIdentifier()).append(" to &CapAddPost:").append(s.getScopeSummaryIdentifier())
					.append(" MVA.");
				}

				//"Add a Circuit"
				if(s.getScopeType().getModelingCoTypeId()==CoType.CIRCUIT && s.getScopeType().getDefaultQuantity()==1){

					defaultScope.append("Add &CktAdd:").append(s.getScopeSummaryIdentifier()).
						append(" -&SecondaryKv:").append(s.getScopeSummaryIdentifier()).
						append(" kV circuit(s) for a total of &CktCountAfter:").append(
									s.getScopeSummaryIdentifier()).append(".");

				}
				//Remove a Circuit
				if(s.getScopeType().getModelingCoTypeId()==CoType.CIRCUIT && s.getScopeType().getDefaultQuantity()==-1){
					defaultScope.append("Remove &CktRemove:").append(s.getScopeSummaryIdentifier()).
					append("-&SecondaryKv:").append(s.getScopeSummaryIdentifier()).
					append(" kV circuit(s) for a total of &CktCountBefore:").
					append(s.getScopeSummaryIdentifier()).append(".");
				}

				//Add a Capacitor Bank
				if(s.getScopeType().getModelingCoTypeId()==CoType.SUB_VAR && s.getScopeType().getDefaultQuantity()==1){
					defaultScope.append("Add &VarAdd:").append(s.getScopeSummaryIdentifier()).
					append(" MVAR of capacitors.");
				}
				//Remove a Capacitor Bank
				if(s.getScopeType().getModelingCoTypeId()==CoType.SUB_VAR && s.getScopeType().getDefaultQuantity()==-1){
					defaultScope .append("Remove &VarAdd:").append(s.getScopeSummaryIdentifier()).append(" MVAR of capacitors.");
				}
			}//end while
			defaultScope.append("\n");
		}

		return defaultScope.toString();

	}

	/**
	 * TreeSet of all of the unique ScopeTypes from the Scope Items assigned to this ProjElemCost 
	 * @return
	 * @throws SQLException
	 */
	public TreeSet<ScopeItem> getScopeItemSummary(int planyear) throws SQLException{
		Hashtable<String,ScopeItem> hash = new Hashtable<String,ScopeItem>();
		for(ScopeItem si: getScopeItems()){
			if(si.isEnabledBl() ){
				ScopeItem temp = hash.get(si.getScopeType().getHashKey()+getCoType().getHashKey()+getFacilityId());
				if(temp == null){
					temp = new ScopeItem(0);
					temp.setScopeTypeId(si.getScopeTypeId());
					temp.setFacilityObject(getFacilityObject(planyear));
					hash.put(temp.getScopeType().getHashKey()+getCoType().getHashKey()+getFacilityId(), temp);
				}
				//BME finish math for summary table, no bank PLL/ELL, get last Sub PLL,ELL,N-1
				temp.setQuantity(temp.getQuantity() + si.getQuantityBl(planyear));
			}
		}
		return new TreeSet<ScopeItem>(hash.values());
	}

	public boolean wouldBeInService(Calendar asOf) throws SQLException {
		if(getModelDate() == null || asOf == null) return false;
		return asOf.getTimeInMillis()+Calculate.ONE_DAY > getModelDate().getTimeInMillis();
	}

	/**
	 * Evaluates cost is Enabled, is Current Rev, and Not Cancelled
	 * @return
	 * @throws SQLException
	 */
	public boolean isActiveBl(int planyear, int simId) throws SQLException{
		return isEnabledBl() && (getSceProjRev() == null || getSceProjRev().isActiveBl(planyear,simId));
	}
	public boolean isCurRev(int planyear, int simId)throws SQLException{
		return getSceProjRev() == null || getSceProjRev().isCurRev(planyear, simId);
	}
	public int compareTo(Object o){
		if(o instanceof SceProjElemCost){
			SceProjElemCost pec = (SceProjElemCost)o;
			if(getModelDate() != null && pec.getModelDate() != null){
				if(getModelDate().getTimeInMillis() < pec.getModelDate().getTimeInMillis())
					return -1;
				if(getModelDate().getTimeInMillis() > pec.getModelDate().getTimeInMillis())
					return 1;
			}
		}
		return super.compareTo(o);
	}
	
	//
	public TreeSet<Referee> getFlags(int simId) throws SQLException{
		TreeSet<Referee> flags = new TreeSet<Referee>(); //super.getFlags(simId);

		//		int flagId = getInterSysTransFlag(simId);		
		//		if(flagId > 0)
		//		flags.add(new Referee(this,Flag.getInstance(getPlanyear(), flagId)));

		//		int flagId = getACLFlag(simId);
		//		if(flagId > 0)
		//		flags.add(new Referee(this,Flag.getInstance(getPlanyear(), flagId)));

		//				for(SceProjElemCost pec: getSceProjElemCosts())
		//				flags.addAll(pec.getFlags(simId));

		return flags;		
	}


	public int getPlanyear() throws SQLException {
		if(getSceProjRev()==null)
			return 0;
		return getSceProjRev().getPlanYear();
	}

	public int getSimId() throws SQLException {
		if(getSceProjRev()==null)
			return 0;
		return getSceProjRev().getSimId();
	}

	public void setSubPLLPercent(double pllPercent) throws SQLException{
		ScopeItem si=null;
		for(ScopeItem si2:getScopeItems()){
			if(si2.getScopeType().getModelingCoTypeId() == CoType.PLL_SUB){
				si = si2;
				break;
			}
		}
		if(si == null){
			si = new ScopeItem();
			si.setTitle("Sub PLL Set");
			si.setDescription("Auto Generated Sub PLL Set");
			si.setScopeType(ScopeType.getAddInstance(CoType.PLL_SUB));
			addScopeItem(si);
		}
		si.setQuantity(pllPercent);
	}
	public void setSubELLPercent(double ellPercent) throws SQLException{
		ScopeItem si=null;
		for(ScopeItem si2:getScopeItems()){
			if(si2.getScopeType().getModelingCoTypeId() == CoType.ELL_SUB){
				si = si2;
				break;
			}
		}
		if(si == null){
			si = new ScopeItem();
			si.setTitle("Sub ELL Set");
			si.setDescription("Auto Generated Sub ELL Set");
			si.setScopeType(ScopeType.getAddInstance(CoType.ELL_SUB));
			addScopeItem(si);
		}
		si.setQuantity(ellPercent);
	}
	public void setSubN1Percent(double n1Percent) throws SQLException{
		ScopeItem si=null;
		for(ScopeItem si2:getScopeItems()){
			if(si2.getScopeType().getModelingCoTypeId() == CoType.N1_BBANK){
				si = si2;
				break;
			}
		}
		if(si == null){
			si = new ScopeItem();
			si.setTitle("Sub N-1 Set");
			si.setDescription("Auto Generated Sub N-1 Set");
			si.setScopeType(ScopeType.getAddInstance(CoType.N1_BBANK));
			addScopeItem(si);
		}
		si.setQuantity(n1Percent);
	}
	public int getStatus() throws SQLException {
		int status = getStatusActiveDetails();
		if(!isEnabledBl()){
			if(status == SceProjRev.NEW)
				return SceProjRev.ABORTED;
			return SceProjRev.CANCELLED;
		}
		if(getInServiceDate() == null || getInServiceDate().getTimeInMillis() > Calendar.getInstance().getTimeInMillis())
			return SceProjRev.ACTIVE_STATUS;
		return SceProjRev.COMPLETE;
	}
	public int getStatusFull() throws SQLException{
		switch(getStatus()){
			case SceProjRev.ABORTED: return SceProjRev.ABORTED;
			case SceProjRev.CANCELLED: return SceProjRev.CANCELLED;
			case SceProjRev.COMPLETE: return SceProjRev.COMPLETE;
		}
		return getStatusActiveDetails();
	}
	public int getStatusActiveDetails()throws SQLException{
		if(getSceProjRev() == null)
			return SceProjRev.NEW;
		return getSceProjRev().getProjStatusActiveDetails();

	}
	//XXX ELLFactorPost does not exist with a without project
	public double getELLPost(int planyear, int simId, TreeSet<SceProjElemCost> without) throws SQLException {
		return getELLFactorPost(planyear, simId)*getNameplatePost(planyear, simId, without);
	}
	public double getPLLPost(int planyear, int simId, Collection<SceProjElemCost> without) throws SQLException {
		//		EspLogger.debug(this, "getPLLFactorPost: "+ getPLLFactorPost(planyear, simId, without));
		//		EspLogger.debug(this, "SceProjElemCoist: "+ toString());
		//		EspLogger.debug(this, "getNameplatePost: "+ getNameplatePost(planyear, simId, without));
		return getPLLFactorPost(planyear, simId, without)*getNameplatePost(planyear, simId, without);
	}
	public void setInServiceDate(Calendar inServiceDate) throws SQLException{
		super.setInServiceDate(inServiceDate);
		resortFacilities();
	}
	public void resortFacilities() throws SQLException{
		if(getFacilityId() != 0){
			FacilityObject fo = getFacilityObject(Department.getActivePlanYear());
			if(fo != null)
				fo.invalidateCache("getSceProjElemCosts");
			for(ScopeItem si:getScopeItems()){
				if(si.getFacilityId() != 0){
					FacilityObject fo2 = si.getFacilityObject(Department.getActivePlanYear());
					if(fo2 != null)
						fo.invalidateCache("getSceProjElemCosts");
				}
			}
		}
	}

	public int getBadProjectFlag(int planyear, int simId) throws SQLException {
		Flag flag = Flag.getInstance(planyear, Flag.PROJ_BAD_FLAG);
		FacilityObject fo = getFacilityObject(planyear);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && getNameplateDelta(planyear, simId)>0 && getSceProjRev().isDEProject() && getStatus() == Proj.ACTIVE) {
			if(fo instanceof Sub){
				Sub sub = (Sub)fo;
				double areaReserve = sub.getYear(getSimId(),getPeakYear(planyear)).getReserveNoProj(getSceProjRev());
				double areaPLL = sub.getYear(getSimId(),getPeakYear(planyear)).getPLLNoProj(getSceProjRev());

				if(sub instanceof Bbank){
					for(BbankTie bt:((Bbank)sub).getActiveFromTies(getSimId())){
						if(bt.getStrength().equals(BbankTie.STRONG)){
							areaReserve += bt.getToSub().getYear(getSimId(),getPeakYear(planyear)).getReserveNoProj(getSceProjRev());
							areaPLL += bt.getToSub().getYear(getSimId(),getPeakYear(planyear)).getPLLNoProj(getSceProjRev());
						}
					}
					for(BbankTie bt:((Bbank)sub).getActiveToTies(getSimId())){
						if(bt.getStrength().equals(BbankTie.STRONG)){
							areaReserve += bt.getFromSub().getYear(getSimId(),getPeakYear(planyear)).getReserveNoProj(getSceProjRev());
							areaPLL += bt.getFromSub().getYear(getSimId(),getPeakYear(planyear)).getPLLNoProj(getSceProjRev());
						}
					}
				}
				if(areaReserve/areaPLL>flag.getValue())
					return flag.getFlagId();
			}
		}
		return 0;
	}

	public double getImpedanceDelta(int planyear, int simId){
		//TODO EMM 1 Write this method
		return 0;
	}

	public int getZFlag(int planyear, int simId) throws SQLException {
		// TODO EMM 1 Create flag logic for impedance
		Flag flag = Flag.getInstance(planyear, Flag.PROJ_Z_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() &&  isActiveBl(planyear, simId))
			if(getNameplateDelta(planyear, simId) > 0 && getImpedanceDelta(planyear,simId)<flag.getValue())
				return flag.getFlagId();
		return 0;
	}

	public int getYearAheadCostFlag(int planyear, int simId) throws SQLException {
		Flag flag = Flag.getInstance(planyear, Flag.PROJ_NO_PLAN_COST_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && getSceProjRev().isDEProject() && getStatus() == Proj.ACTIVE)
			if(getCost((getCalendarYear()-1) ) < getTotalCost()*flag.getValue())
				return flag.getFlagId();
		return 0;
	}

	public int getTotalCostFlag(int planyear, int simId) throws SQLException {
		Flag flag = Flag.getInstance(planyear, Flag.PROJ_NO_COST_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && getSceProjRev().isDEProject() && getStatus() == Proj.ACTIVE )
			if(getTotalCost()<=flag.getValue())
				return flag.getFlagId();
		return 0;
	}
		

	public int getTotalCostDeltaFlag(int planyear, int simId) throws SQLException {
		return getSceProjRev().getTotalCostDeltaFlag(planyear);
	}

	public int getYearOfCostFlag(int planyear, int simId) throws SQLException {
		Flag flag = Flag.getInstance(planyear, Flag.PROJ_YEAR_OF_COST_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && getSceProjRev().isCurRev(planyear, simId) && getSceProjRev().isDEProject() && getStatus() == Proj.ACTIVE){
			//if(getCost(getCalendarYear()-1) < getTotalCost()*flag.getValue())
			if(getCost(getCalendarYear()) < getTotalCost()*flag.getValue()){		
				return flag.getFlagId();
			}}
		return 0;
	}

	public int getPLLDeltaFlag(int planyear, int simId) throws SQLException {
		return getSceProjRev().getPLLDeltaFlag();
	}
	public int getELLDeltaFlag(int planyear, int simId) throws SQLException {
		return getSceProjRev().getELLDeltaFlag();
	}
	public int getN1DeltaFlag(int planyear, int simId) throws SQLException {
		return getSceProjRev().getN1DeltaFlag();
	}

	public int getFutureActOpDateFlag(int planyear, int simId) throws SQLException {
		Flag flag = Flag.getInstance(planyear, Flag.PROJ_ACT_OP_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()&& (getSceProjRev().getProjectStatus()==SceProjRev.ACTIVE_STATUS) )
			if(getInServiceDate()!=null && getInServiceDate().getTimeInMillis() > Calendar.getInstance().getTimeInMillis() + (flag.getValue() * 24 * 60 * 60 * 1000))
				return flag.getFlagId();
		return 0;
	}

	public int getOpDatePassedFlag(int planyear, int simId) throws SQLException {
		Flag flag = Flag.getInstance(planyear, Flag.PROJ_OP_DATE_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && getSceProjRev().isDEProject() && getSceProjRev().isCurRev(planyear, simId) && getSceProjRev().getProjectStatus() == SceProjRev.ACTIVE_STATUS && !getSceProjRev().isRetracted() )
			if(getInServiceDate()==null && getModelDate().getTimeInMillis() < Calendar.getInstance().getTimeInMillis() + (flag.getValue() * 24 * 60 * 60 * 1000) )
				return flag.getFlagId();
		return 0;
	}

	public int getAddInconsistentFlag(int planyear, int simId) throws SQLException {
		return getSceProjRev().getAddInconsistentFlag();
	}

	//===================================================================================================

	private TreeSet<SceProjElemCost> findHistoryKeys(SceProjElemCost keyRequestor) throws SQLException {

		if(keyRequestor==null) return null;

		TreeSet<SceProjElemCost> keys = new TreeSet<SceProjElemCost>();

		//establish the previous publication calendar date
		Calendar previousPublication = Calendar.getInstance();
		previousPublication.set(Calendar.DAY_OF_MONTH, 1);

		//if a previous version exists
		if(keyRequestor.getSceProjRev()!=null && keyRequestor.getSceProjRev().getPrevRev(SceProjRev.APPROVED)!=null)
			//now compare keyRequester to the previous version's approved spec's
			for(SceProjElemCost specOld : keyRequestor.getSceProjRev().getPrevRev(SceProjRev.APPROVED).getSceProjElemCosts()){

				//Look for matches of the same type
				if(specOld.getSceElemId() == keyRequestor.getSceElemId()){

					if(specOld.getTitle()==null&&keyRequestor.getTitle()==null)
						keys.add(specOld);

					else 
						if((specOld.getTitle()==null||keyRequestor.getTitle()==null))
							continue;

						else if((specOld.getTitle().equals(keyRequestor.getTitle())))						
							keys.add(specOld);
				}
			}
		return keys;
	}

	public String getPubPrintStatus(IWPStatus status){
		if(status.equals(IWPStatus.NEW_PROJECT))
			return "New Project";
		if(status.equals(IWPStatus.NEW_SCOPE_CHANGE))
			return "New Scope Change";
		if(status.equals(IWPStatus.NEW_OD_CHANGE))
			return "New OD Change";
		if(status.equals(IWPStatus.NEW_BUDGET_CHANGE))
			return "New Budget Change";
		if(status.equals(IWPStatus.NEW_CHANGE))
			return "New Change";
		if(status.equals(IWPStatus.NEW_WORK_ELEMENT))
			return "New Work Element";

		return "";
	}

	/**
	 * TODO complete logic and test and move to specy
	 * 
	 * 
	 * @return the status if any changes in last month.
	 * 
	 * @throws SQLException 
	 */
	public String getPublicationStatus() throws SQLException{
		StringBuffer buffer = new StringBuffer();

		//establish the previous publication calendar date
		Calendar previousPublication = Calendar.getInstance();
		previousPublication.set(Calendar.DAY_OF_MONTH, 1);

		//first of all, see if this a new project since last publication:
		//project insert timestamp field is null in some cases. 
		//inserted check to verify is not null (null exception 
		//occurs when running IWP reports (HiK).
		if(getSceProjRev().getSceProj().getInsertTs() != null && this.getSceProjRev().getSceProj().getInsertTs().getTimeInMillis()>previousPublication.getTimeInMillis())
			return getPubPrintStatus(IWPStatus.NEW_PROJECT);


		//look for matching spec's in previous version
		TreeSet<SceProjElemCost> matchSet = findHistoryKeys(this);

		if(matchSet.size()>0){
			for(SceProjElemCost match: matchSet){
				//DO NOT INCLUDE APPROVED OR BUDGET SPEC'S
				if(getCostStage().getCostType()==CostStage.Type.Proposed.ordinal()){
					//check within the last 30 days....
					//Null pointer exception fix for IWP master list report (HiK)
					if(!isSame(getScopeDesc(),match.getScopeDesc())){//: java.lang.NullPointerException
						setPubDiffDetails(StringUtils.difference(getScopeDesc(), match.getScopeDesc()));
						return getPubPrintStatus(IWPStatus.NEW_SCOPE_CHANGE);
					}
					//for approved/canceled projects
					if(match.getProposedOd()!=null && getProposedOd()!=null && !getProposedOd().equals(match.getProposedOd())){
						setPubDiffDetails("OD changed from "+FormatText.USER_DATE.format(match.getProposedOd().getTime())+" to "+FormatText.USER_DATE.format(getProposedOd().getTime()));
						return getPubPrintStatus(IWPStatus.NEW_OD_CHANGE);
					}
					if(this.getTotalCost()!=match.getTotalCost()){
						setPubDiffDetails("Cost changed from $"+match.getTotalCost()+" to "+getTotalCost());
						return getPubPrintStatus(IWPStatus.NEW_BUDGET_CHANGE);
					}
				}
			}			
		}	
		if(this.getInsertTs().getTimeInMillis()>previousPublication.getTimeInMillis())
			return getPubPrintStatus(IWPStatus.NEW_WORK_ELEMENT);

		return buffer.toString();
	}	

	private StringBuffer diffDetails = new StringBuffer();

	public void setPubDiffDetails(String details){
		diffDetails.append(details);
	}

	public String getPubDiffDetails(){
		return diffDetails.toString();
	}

	public Sub getSub(int planyear) throws SQLException{
		FacilityObject fo = getFacilityObject(planyear);
		if(fo instanceof Sub)
			return (Sub)fo;
		else if(fo instanceof Bank)
			return ((Bank)fo).getSub();
		else if(fo instanceof Ckt)
			return ((Ckt)fo).getBbank(getSimId());
		return null;
	}

	public Sys getSys(int planyear)throws SQLException{
		FacilityObject fo = getFacilityObject(planyear);
		if(fo instanceof Sys)
			return (Sys)fo;
		Sub s = getSub(planyear);
		if(s != null && s.getYear(getSimId(), getPeakYear(planyear))!=null)
			return s.getYear(getSimId(), getPeakYear(planyear)).getSys();
		return null;	
	}

	public District getDistrict(int planyear)throws SQLException{
		FacilityObject fo = getFacilityObject(planyear);
		if(fo instanceof District)
			return (District)fo;
		Sub s = getSub(planyear);
		if(s != null)
			return s.getDistrict();
		return null;
	}

	public Region getRegion(int planyear)throws SQLException{
		FacilityObject fo = getFacilityObject(planyear);
		if(fo instanceof Region)
			return (Region)fo;
		Sys s = getSys(planyear);
		if(s != null)
			return s.getRegion();
		return null;
	}

	public Zone getZone(int planyear)throws SQLException{
		FacilityObject fo = getFacilityObject(planyear);
		if(fo instanceof Zone)
			return (Zone)fo;
		Region r = getRegion(planyear);
		if(r != null)
			return r.getZone();
		return null;	
	}
	@Override
	public void addScopeItem(ScopeItem scopeItem)throws SQLException{
		if(getCostStage().getCostType()!=CostStage.Type.Proposed.ordinal())
			throw new SQLException("Scope Items can only be added to proposed costs");
		super.addScopeItem(scopeItem);
	}

	public String getWoNum(){
		String wo = getWo();
		if(wo != null && wo.contains("-"))
			return wo.substring(wo.indexOf("-")+1, wo.length());
		return null;
	}

	public String getLoc() throws SQLException{
		String wo = getWo();
		if(wo != null && wo.contains("-"))
			return wo.substring(0, wo.indexOf("-"));
		return null;
	}

	public String getSharedCostNumSeq() {
		return "SHARED_COST_NUM_SEQ";
	}

	public LastModified getLastModified() throws SQLException {
		LastModified specLm = new LastModified(getModifiedUser(), getModifiedTs());
		for(SceProjElemCostYear specy:new TreeSet<SceProjElemCostYear>(getSceProjElemCostYears())){
			LastModified specyLm = specy.getLastModified();
			if(specyLm.getModifiedTs()!=null && (specLm.getModifiedTs()==null || specyLm.getModifiedTs().getTimeInMillis()>specLm.getModifiedTs().getTimeInMillis())){
				specLm = specyLm;
			}
		}

		if(specLm.getModifiedTs() == null)
			specLm = new LastModified(getInsertUser(), getInsertTs());

		return specLm;

	}

	//TODO use regular expression
	public boolean isEditable(int simId, String field) throws SQLException{
		if(isNewInstance()) return true;
		if(getSceProjRev() != null){
			if(INFO_FIELDS.contains(field))return getSceProjRev().isInfoEditable(simId);
			if(BSS_FIELDS.contains(field))return getSceProjRev().isBSSEditable(simId);
			if(ALWAYS_FIELDS.contains(field))return getSceProjRev().isAlwaysEditable(simId);
		}
		else
			return true;
		throw new SQLException("Unknown Field: "+field);
	}


//	//	@Override
//	//	public void setSceProjRevId(int sceProjRevId) throws SQLException{
//	//		if(getSceProjRev().getCurrentSceProjElemCosts().size()==1 && isEnabled())
//	//			throw new SQLException("A project must have atleast one proposed enabled Proj Elem Cost");
//	//		super.setSceProjRevId(sceProjRevId);
//	//	}
	@Override
	public void setEnabled(boolean enabled) throws SQLException{
		//if(!isNewInstance() && !enabled && getSceProjRev().getCurrentSceProjElemCostsNoBudget().size()==1)
			//throw new SQLException("A project must have atleast one proposed enabled Proj Elem Cost");
		super.setEnabled(enabled);
	}
	@Override
	public void delete() throws SQLException{
		//only apply condition to non approved and non budget cost elements
		if(getCostStage().getCostType()==CostStage.Type.Proposed.ordinal() && getSceProjRev().getSceProjElemCosts(CostStage.Type.Proposed).size()==1)
			throw new SQLException("A project must have atleast one proposed enabled Proj Elem Cost");
		super.delete();
	}
	

	/**
	 * This method is to set the WO field to identify if this is a blanket cost element.
	 * If the value is true then "-Blanket" is written into the WO field other wise left blank.
	 * 
	 * @param value - boolean to signify whether this spec is a blanket or not
	 * @throws SQLException
	 */
	public void setBlanket(boolean value) throws SQLException {
		if((Boolean)value) {
			  String wo = getWo();
			  if(wo != null && wo.contains("-"))
				  setWo(getWo().substring(0, wo.indexOf("-")+1)+"Blanket");
			  else
			  	  setWo("-Blanket");
		  }
		  else
			  setWo("");
	}
	
	/**
	 * returns if this spec is a blanket pin or not.
	 * 
	 * @return
	 */
	public boolean isBlanket() {
		return getWo()!=null && getWo().contains("Blanket");
	}

	public int getQbrId() throws SQLException {
		if(getSubQbrId()==0) return 0;
		return SubQbr.getInstance(getSubQbrId()).getQbrId();
	}

	public Calendar getPrelimDate() {
		return null;
	}
	
	
	public Calendar getOpDate() {
		return getApprovedOd();
	}

	@Override
	public Calendar getModelDate() {
		Calendar date = getInServiceDate();
		if(date==null)
			date = getOpDate();
		if(date == null)
			date = getNeedDate();
		return date;
	}
	
	public Calendar getNeedDate() {
		return getProposedOd();
	}
	
	public void setNeedDate(Calendar needDate) throws SQLException{
		if(needDate==null) throw new SQLException("NEED_DATE can not be null");
		super.setProposedOd(needDate);
		resortFacilities();
	}

	/**
	 * Returns the Factor of the element cost that is PUC.
	 * @return PUC Factor
	 */
	public double getPUCFactor(){
		return 1.0-getFercFunding();
	}
	
	/**
	 * Returns the Factor of the element cost that is FERC.
	 * @return FERC Factor
	 */
	public double getFERCFactor(){
		double ff = getFercFunding();
		if(ff > 1.0)
			return 1.0;
		if(ff < 0.0)
			return 0.0;
		return ff;
	}
	public void insert() throws SQLException{
		setCostId(0); //Clear temp Cost Id
		super.insert();
	}
	public void setProperty(String prop, Object newValue, Object oldValue) throws SQLException{
		super.setProperty(prop, newValue, oldValue);
		SceProjRev rev = SceProjRev.getInstance(getSceProjRevId(), false);
		int planyear = rev!=null?rev.getPlanYear():Department.getActivePlanYear();
		int simId = rev!=null?rev.getSimId():0;
		FacilityObject fo = getFacilityObject(planyear,simId);
		if(fo instanceof Sub){
			((Sub)fo).invalidateAllCache();
//			for(int y=-1; y<=User.getActiveUser().getPlanFor(planyear, getSimId()); y++){
//				SubYear sy = ((Sub)fo).getYear(getSimId(), planyear+y, false);
//				if(sy!=null)
//					sy.invalidateAllCache();
//			}
		}
	}
	public double getContFactor() throws SQLException{
		ProjContingency pc = ProjContingency.getBestMatch(this);
		if(pc!=null){
			SceProjRev rev = getSceProjRev();
			return (rev!=null && rev.isMajorProject())?pc.getMajorCont():pc.getRegCont();
		}
		return 0;
	}
	public int getContAmount() throws SQLException{
		return (int)Math.round((getSubTotalCost()-getPriorCost())*getContFactor());
	}
	public int getTotalCost() throws SQLException{
		return getSubTotalCost()+getContAmount();
	}
	public Calendar getRevTs() throws SQLException {
		SceProjRev rev = getSceProjRev();
		if(rev!=null)
			return rev.getRevTs();
		return null;
	}
	public Program getProgram() throws SQLException {
		SceProjRev rev = getSceProjRev();
		if(rev!=null)
			return rev.getProgram();
		return null;
	}
}
