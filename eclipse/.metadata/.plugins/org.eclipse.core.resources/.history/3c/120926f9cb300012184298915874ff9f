package com.sce.esp.object.model;

import java.io.Serializable;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Collection;
import java.util.Hashtable;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.Vector;

import javax.persistence.Entity;
import javax.persistence.NamedNativeQueries;
import javax.persistence.NamedNativeQuery;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;

import com.sce.esp.log.EspLogger;
import com.sce.esp.object.dao.SceProjElemCostDAO;
import com.sce.esp.util.Calculate;
import com.sce.esp.util.FormatText;
import com.sce.esp.util.StringPool;
import com.sce.esp.util.StringUtils;
@Entity
@Table(schema="MDI",name="MDIS80_SCE_PROJ_ELEM_COST")
@NamedQueries({
	@NamedQuery(name = "findByID", query="SELECT o FROM SceProjElemCost o WHERE o.COST_ID=?1"),//AUTO-GENERATED
	@NamedQuery(name = "findAll", query="SELECT o FROM SceProjElemCost o"),//AUTO-GENERATED
	@NamedQuery(name = "findAllActive", query="SELECT o FROM SceProjElemCost o WHERE o.DELETED_TS IS NULL"),//AUTO-GENERATED
	@NamedQuery(name = "findBySceProjRev", query="SELECT o FROM SceProjElemCost o WHERE o.SCE_PROJ_REV_ID=?1 AND o.DELETED_TS IS NULL"),//AUTO-GENERATED
	@NamedQuery(name = "findBySceElem", query="SELECT o FROM SceProjElemCost o WHERE o.SCE_ELEM_ID=?1 AND o.DELETED_TS IS NULL"),//AUTO-GENERATED
	@NamedQuery(name = "findByFacility", query="SELECT o FROM SceProjElemCost o WHERE o.CO_TYPE_ID=?1 AND o.FACILITY_ID=?2 AND o.DELETED_TS IS NULL"),
	@NamedQuery(name = "findBySub", query="SELECT o FROM SceProjElemCost o WHERE o.CO_TYPE_ID=?1 AND o.FACILITY_ID=?2"),
	@NamedQuery(name = "findProjWo", query="SELECT o FROM SceProjElemCost o WHERE o.SCE_PROJ_REV_ID=?1 AND o.SCE_ELEM_ID=?2 AND o.COST_STAGE_ID=?3 AND o.DELETED_TS IS NULL"),
})
@NamedNativeQueries({
	@NamedNativeQuery(name = "refresh", query="SELECT o.* FROM MDIS80_SCE_PROJ_ELEM_COST o WHERE o.COST_ID=?"),//AUTO-GENERATED
})
public class SceProjElemCost extends SceProjElemCostDAO implements CostObject, Serializable, ProjectItem{

	private static final long serialVersionUID = 1293760248094675975L;

	public final static int COST_SEARCH_RANGE=10;

	//PEC Stage Arch.========================================================================
	public final static int APPROVED = 0;
	public final static int PLAN_EST = 1;
	public final static int PWEE_COST = 2;
	public final static int WO_COST = 3;
	public final static String[] STAGE_NAME = StringPool.STAGE_NAME;
	public final static int[] COST_STAGES = {APPROVED,PLAN_EST,PWEE_COST,WO_COST};

	public final static String INFO_FIELDS = StringPool.INFO_FIELDS;
	public final static String BSS_FIELDS = StringPool.BSS_FIELDS;
	public final static String ALWAYS_FIELDS = StringPool.ALWAYS_FIELDS;

	public final static int CAPITAL = 1;
	public final static int EXPENSE = 2;
	public final static int CUSTOMER = 3;
	
	public static enum Funder {CAPITAL,EXPENSE,CUSTOMER};
	
	
	private static int tempId = 0;

	public synchronized static int getTempId(){
		return --tempId;
	}

	public SceProjElemCost() {
		super(getTempId());
	}

	public SceProjElemCost(int costId) {
		super(costId);
	}

	public SceProjElemCost(SceProjElemCost sceProjElemCost) {
		super(sceProjElemCost);
		try {
			setCostId(getTempId());
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public SceProjElemCostYear getSceProjElemCostYear(int year) throws SQLException {
		return SceProjElemCostYear.getInstance(getCostId(), year);
	}

	public Vector<String> getInsertStatus(){
		Vector<String> errors = new Vector<String>();
		if(isNull(getSceProjRevId())) errors.add("SCE PROJ REV ID is Required.");
		if(isNull(getSceElemId())) errors.add("SCE ELEM ID is Required.");
		if(isNull(getProposedOd())) errors.add("PROPOSED OD is Required.");
		return errors;
	}

	public String getStageTitle() throws SQLException{
		if(getTitle() != null && getTitle().length() > 0)	
			return getTitle();
		return "Miscellaneous";
	}	

	public String getScopeWithStage() throws SQLException{

		String s="N/A";
		if(getScopeDesc()!=null)
			s=getScopeDesc();
		//Temporarily removed this logic until necessary HiK
		//if(getCostStageId() != PLAN_EST)
		s += " ("+getSapOrderNumBl()+")";

		return s;
	}

	public String getSapWbsBl() {
		String s="SAP Seq N/A";
		try {
			if(getSceProjRev().getProjNum()!=null && getSapWbs()!=null) //seq = 0 allowed?
				s = getSapWbs()+"-"+getSceProjRev().getProjNum()+"-"+getSapWbsSeq();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return s;
	}

	private String getSapOrderNumBl() {
		String s="SAP Order # ";
		if(getSapOrderNum()!=null) 
			s += getSapOrderNum();
		else 
			s += "N/A";
		return s;
	}

	//
	public int getPriorCost()throws SQLException{
		if(!isEnabled())
			return 0;
		int prior=0;
		int curYear = Calendar.getInstance().get(Calendar.YEAR);
		if(isUseUnitCost()){
			for(ScopeItem si:getScopeItems())
				prior += si.getPriorCost();
		}else
			for(SceProjElemCostYear pecy:getSceProjElemCostYears())
				if(pecy.getYear() < curYear)
					prior += pecy.getCost();
		return prior;
	}


	// 
	public int getSubTotalCost()throws SQLException{
		if(getCostStage().getCostType()==CostStage.Type.Proposed.ordinal() && !isEnabledBl())
			return getPriorCost();
		int total=0;
		if(isUseUnitCost()){
			for(ScopeItem si:getScopeItems())
				if(si.isEnabled())
					total += si.getSubTotalCost();
		}else
			for(SceProjElemCostYear pecy:getSceProjElemCostYears())
				total += pecy.getCost();
		return total;
	}

	//
	public int getCost(int year)throws SQLException{
		if(isUseUnitCost()){
			int cost=0;
			int curYear = Calendar.getInstance().get(Calendar.YEAR);
			for(ScopeItem si:getScopeItems())
				if(si.isEnabled() || year < curYear)
					cost += si.getCost(year);
			return cost;
		}
		for(SceProjElemCostYear specy: getSceProjElemCostYears())
			if(specy.getYear() == year)
				return specy.getCost();
		return 0;
	}

	public SapWbs getSapWbs() throws SQLException {
		return SapWbs.getInstance(getSapWbsId());
	}

	public void setSapWbs(SapWbs sapWbs) throws SQLException {
		setSapWbsId(sapWbs.getSapWbsId());
	}

	public int getCalendarYear(){
		if(getModelDate()!=null)
			return getModelDate().get(Calendar.YEAR);
		return 0;
	}

	public int getPeakYear(int planyear) throws SQLException{
		return Department.getEffYear(planyear, getModelDate());
	}

	//XXX Place Holder: 
	public int getFiscalYear(){
		if(getModelDate()!=null)
			return getModelDate().get(Calendar.YEAR);
		return 0;
	}

	/**
	 * Arch. allows multiple priorities, this method returns the most recent (current)
	 * 
	 * @return collection of Current SceProjElemPriority
	 * @throws SQLException
	 */
	public TreeSet<SceProjElemPriority> getCurrentSceProjElemPrioritys() throws SQLException {
		TreeSet<SceProjElemPriority> speps  = new TreeSet<SceProjElemPriority>();
		for(SceProjElemPriority spep: getSceProjElemPrioritys())
			if(speps.isEmpty() || speps.last().getCostId() != spep.getCostId() || speps.last().getYear()!= spep.getYear())
				speps.add(spep);
		return speps;
	}

	public void setProposedOd(Calendar proposedOd, boolean escalate)throws SQLException{
		setCostStageId(CostStage.PLAN_EST);
		int curYear = Calendar.getInstance().get(Calendar.YEAR);
		int delta = proposedOd.get(Calendar.YEAR) - getProposedOd().get(Calendar.YEAR);
		setNeedDate(proposedOd);
		if(escalate){
			escalateProjElemCostYears(curYear,delta);
			escalateScopeItemCostYears(curYear,delta);
		}
	}
	
	public void setApprovedOd(Calendar approvedOd, boolean escalate)throws SQLException{
		setCostStageId(CostStage.PLAN_EST);
		int curYear = Calendar.getInstance().get(Calendar.YEAR);
		
		int delta = approvedOd.get(Calendar.YEAR) - getModelDate().get(Calendar.YEAR);
		setOpDate(approvedOd);
		
		if(escalate){
			escalateProjElemCostYears(curYear,delta);
			escalateScopeItemCostYears(curYear,delta);
		}
	}
	
	private void escalateProjElemCostYears(int curYear, int delta) throws SQLException{
		TreeSet<SceProjElemCostYear> newCosts = new TreeSet<SceProjElemCostYear>();
		SceProjElemCostYear firstYear=null;
		for(SceProjElemCostYear specy:new TreeSet<SceProjElemCostYear>(getSceProjElemCostYears())){
			if(specy.getYear() >= curYear){
				if(specy.getYear() + delta <= curYear){
					if(firstYear == null)
						firstYear = new SceProjElemCostYear(getCostId(),curYear);
					firstYear.setCost(firstYear.getCost() + specy.getCost(curYear));
				}
				else{
					SceProjElemCostYear copy = specy.copy();
					copy.setYear(specy.getYear()+delta);
					copy.setCost(specy.getCost(copy.getYear()));
					newCosts.add(copy);
				}
				specy.deleteDB();
			}
		}
		for(SceProjElemCostYear specy:newCosts)
			specy.insert();
		if(firstYear != null)
			firstYear.insert();
	}
	
	private void escalateScopeItemCostYears(int curYear, int delta) throws SQLException{
		for(ScopeItem si:getScopeItems()){
			TreeSet<ScopeItemCostYear> newCosts = new TreeSet<ScopeItemCostYear>();
			ScopeItemCostYear firstYear=null;
			for(ScopeItemCostYear sicy:new TreeSet<ScopeItemCostYear>(si.getScopeItemCostYears())){
				if(sicy.getYear() >= curYear){
					if(sicy.getYear() + delta <= curYear){
						if(firstYear == null){
							firstYear = new ScopeItemCostYear(getCostId(),curYear);
						}
						firstYear.setCost(firstYear.getCost() + sicy.getCost(curYear));
					}
					else{
						ScopeItemCostYear copy = sicy.copy();
						copy.setYear(sicy.getYear()+delta);
						copy.setCost(sicy.getCost(copy.getYear()));
						newCosts.add(copy);
					}
					sicy.deleteDB();
				}
			}
			for(ScopeItemCostYear sicy:newCosts)
				sicy.insert();
			if(firstYear != null)
				firstYear.insert();
		}
	}

	public String toString(){
		StringBuffer buffer = new StringBuffer("");
		try {
			buffer.append(getStageTitle()).append(" (").
			append(getCalendarYear())/*.append(")").append(getSu)*/;

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return buffer.toString();
	}

	/**
	 * isEnabled and ProjRev isEnabledBl
	 */
	public boolean isEnabledBl() throws SQLException {
		return isEnabled() && (getSceProjRev() == null || getSceProjRev().isEnabledBl());
	}

	public boolean isUseUnitCost() throws SQLException{
		return getCostStage().isUnitCostable() && isUseCalc();
	}

	public void setUseUnitCost(boolean useUnitCost) throws SQLException{
		setUseCalc(useUnitCost);
	}
	public FacilityObject getFacilityObject(int planyear) throws SQLException{
		return getFacilityObject(planyear, getSimId());
	}
	public FacilityObject getFacilityObject(int planyear, int simId) throws SQLException{
		if(getCoTypeId() != 0 && getCoTypeId() != 18)
			return CoType.getInstance(getCoTypeId()).getFacilityObject(planyear,simId,getFacilityId());
		else if(getCoTypeId() ==CoType.TBANK)
			if(Abank.getInstance(planyear, getFacilityId())!=null)
				return Abank.getInstance(planyear, getFacilityId()).getTbank();
		return null;
	}
	public SceProjElemCost getPriorSceProjElemCost(int planyear,int simId) throws SQLException{
		if(getFacilityObject(planyear) != null){
			SortedSet<SceProjElemCost> headSet = getFacilityObject(planyear).getSceProjElemCosts().headSet(this);
			if(headSet.size() > 0){
				if(headSet.last().isActiveBl(planyear,simId))
					return headSet.last();
				return headSet.last().getPriorSceProjElemCost(planyear,simId);
			}
		}
		return null;
	}
	//Circuit Functions
	public TreeSet<Ckt> getCktsPre(int planyear,int simId,Collection<SceProjElemCost> without)throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getCktsPost(planyear,simId,without);
		return new TreeSet<Ckt>();
	}
	public TreeSet<Ckt> getCktsAdd(int planyear)throws SQLException{
		TreeSet<Ckt> ckts = new TreeSet<Ckt>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() > 0 && si.getModelingObject(planyear) instanceof Ckt)
				ckts.add((Ckt)si.getModelingObject(planyear));
		return ckts;
	}
	public TreeSet<Ckt> getCktsRem(int planyear)throws SQLException{
		TreeSet<Ckt> ckts = new TreeSet<Ckt>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() < 0 && si.getModelingObject(planyear) instanceof Ckt)
				ckts.add((Ckt)si.getModelingObject(planyear));
		return ckts;
	}
	public TreeSet<Ckt> getCktsPost(int planyear,int simId,Collection<SceProjElemCost> without)throws SQLException{
		TreeSet<Ckt> ckts = getCktsPre(planyear,simId,without);
		if(without == null || !without.contains(this)){
			ckts.addAll(getCktsAdd(planyear));
			ckts.removeAll(getCktsRem(planyear));
		}
		return ckts;
	}
	//Subtrans Lines Functions
	public TreeSet<Stl> getStlsPre(int planyear,int simId)throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getStlsPost(planyear,simId);
		return new TreeSet<Stl>();
	}
	public TreeSet<Stl> getStlsAdd(int planyear)throws SQLException{
		TreeSet<Stl> ckts = new TreeSet<Stl>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() > 0 && si.getModelingObject(planyear) instanceof Stl)
				ckts.add((Stl)si.getModelingObject(planyear));
		return ckts;
	}
	public TreeSet<Stl> getStlsRem(int planyear)throws SQLException{
		TreeSet<Stl> ckts = new TreeSet<Stl>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() < 0 && si.getModelingObject(planyear) instanceof Stl)
				ckts.add((Stl)si.getModelingObject(planyear));
		return ckts;
	}
	public TreeSet<Stl> getStlsPost(int planyear, int simId)throws SQLException{
		TreeSet<Stl> ckts = getStlsPre(planyear,simId);
		ckts.addAll(getStlsAdd(planyear));
		ckts.removeAll(getStlsRem(planyear));
		return ckts;
	}

	//Bank Functions
	public TreeSet<Bank> getBanksPre(int planyear,int simId,Collection<SceProjElemCost> without)throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getBanksPost(planyear,simId,without);
		return new TreeSet<Bank>();
	}
	public TreeSet<Bank> getBanksAdd(int planyear)throws SQLException{
		TreeSet<Bank> banks = new TreeSet<Bank>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() > 0 && si.getModelingObject(planyear) instanceof Bank)
				banks.add((Bank)si.getModelingObject(planyear));
		return banks;
	}
	public TreeSet<Bank> getBanksRem(int planyear)throws SQLException{
		TreeSet<Bank> banks = new TreeSet<Bank>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() < 0 && si.getModelingObject(planyear) instanceof Bank)
				banks.add((Bank)si.getModelingObject(planyear));
		return banks;
	}
	public TreeSet<Bank> getBanksPost(int planyear,int simId,Collection<SceProjElemCost> without)throws SQLException{
		TreeSet<Bank> banks = getBanksPre(planyear,simId,without);
		if(without == null || !without.contains(this)){
			banks.addAll(getBanksAdd(planyear));
			banks.removeAll(getBanksRem(planyear));
		}
		return banks;
	}
	public TreeSet<Bank> getBanksEverAddedPre(int planyear,int simId)throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getBanksEverAddedPost(planyear,simId);
		return new TreeSet<Bank>();
	}
	public TreeSet<Bank> getBanksEverAddedPost(int planyear,int simId)throws SQLException{
		TreeSet<Bank> banks = getBanksEverAddedPre(planyear,simId);
		banks.addAll(getBanksAdd(planyear));
		return banks;
	}

	//Transformer Functions
	public TreeSet<Xfmr> getXfmrsPre(int planyear,int simId)throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getXfmrsPost(planyear,simId);
		return new TreeSet<Xfmr>();
	}
	public TreeSet<Xfmr> getXfmrsAdd(int planyear)throws SQLException{
		TreeSet<Xfmr> banks = new TreeSet<Xfmr>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() > 0 && si.getModelingObject(planyear) instanceof Xfmr)
				banks.add((Xfmr)si.getModelingObject(planyear));
		return banks;
	}
	public TreeSet<Xfmr> getXfmrsRem(int planyear)throws SQLException{
		TreeSet<Xfmr> banks = new TreeSet<Xfmr>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() < 0 && si.getModelingObject(planyear) instanceof Xfmr)
				banks.add((Xfmr)si.getModelingObject(planyear));
		return banks;
	}
	public TreeSet<Xfmr> getXfmrsPost(int planyear,int simId)throws SQLException{
		TreeSet<Xfmr> banks = getXfmrsPre(planyear,simId);
		banks.addAll(getXfmrsAdd(planyear));
		banks.removeAll(getXfmrsRem(planyear));
		return banks;
	}

	//Low Side Sub Var Functions
	public TreeSet<SubVar> getSubVarsLowSidePre(int planyear,int simId)throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getSubVarsLowSidePost(planyear,simId);
		return new TreeSet<SubVar>();
	}
	public TreeSet<SubVar> getSubVarsLowSideAdd(int planyear)throws SQLException{
		TreeSet<SubVar> subVars = new TreeSet<SubVar>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() > 0 && si.getModelingObject(planyear) instanceof SubVar && !si.isHighSide())
				subVars.add((SubVar)si.getModelingObject(planyear));
		return subVars;
	}
	public TreeSet<SubVar> getSubVarsLowSideRem(int planyear)throws SQLException{
		TreeSet<SubVar> subVars = new TreeSet<SubVar>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() < 0 && si.getModelingObject(planyear) instanceof SubVar && !si.isHighSide())
				subVars.add((SubVar)si.getModelingObject(planyear));
		return subVars;
	}
	public TreeSet<SubVar> getSubVarsLowSidePost(int planyear,int simId)throws SQLException{
		TreeSet<SubVar> subVars = getSubVarsLowSidePre(planyear,simId);
		subVars.addAll(getSubVarsLowSideAdd(planyear));
		subVars.removeAll(getSubVarsLowSideRem(planyear));
		return subVars;
	}
	public int getKvarLowSidePre(int planyear,int simId)throws SQLException{
		int varAdd = 0;
		for(SubVar subVar:getSubVarsLowSidePre(planyear,simId))
			varAdd += subVar.getKvar();
		return varAdd;
	}
	public int getKvarLowSideAdd(int planyear) throws SQLException{
		int varAdd = 0;
		for(SubVar subVar:getSubVarsLowSideAdd(planyear))
			varAdd += subVar.getKvar();
		return varAdd;
	}
	public int getKvarLowSideRem(int planyear) throws SQLException{
		int varAdd = 0;
		for(SubVar subVar:getSubVarsLowSideRem(planyear))
			varAdd += subVar.getKvar();
		return varAdd;
	}
	public int getKvarLowSidePost(int planyear,int simId)throws SQLException{
		int varAdd = 0;
		for(SubVar subVar:getSubVarsLowSidePost(planyear,simId))
			varAdd += subVar.getKvar();
		return varAdd;
	}
	public int getKvarLowSideDelta(int planyear)throws SQLException{
		return getKvarLowSideAdd(planyear) - getKvarLowSideRem(planyear);
	}
	//Low Side Sub Var Functions
	public TreeSet<SubVar> getSubVarsHighSidePre(int planyear,int simId)throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getSubVarsHighSidePost(planyear,simId);
		return new TreeSet<SubVar>();
	}
	public TreeSet<SubVar> getSubVarsHighSideAdd(int planyear)throws SQLException{
		TreeSet<SubVar> subVars = new TreeSet<SubVar>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() > 0 && si.getModelingObject(planyear) instanceof SubVar && si.isHighSide())
				subVars.add((SubVar)si.getModelingObject(planyear));
		return subVars;
	}
	public TreeSet<SubVar> getSubVarsHighSideRem(int planyear)throws SQLException{
		TreeSet<SubVar> subVars = new TreeSet<SubVar>();
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getQuantity() < 0 && si.getModelingObject(planyear) instanceof SubVar && si.isHighSide())
				subVars.add((SubVar)si.getModelingObject(planyear));
		return subVars;
	}
	public TreeSet<SubVar> getSubVarsHighSidePost(int planyear,int simId)throws SQLException{
		TreeSet<SubVar> subVars = getSubVarsHighSidePre(planyear,simId);
		subVars.addAll(getSubVarsHighSideAdd(planyear));
		subVars.removeAll(getSubVarsHighSideRem(planyear));
		return subVars;
	}
	public int getKvarHighSidePre(int planyear,int simId)throws SQLException{
		int varAdd = 0;
		for(SubVar subVar:getSubVarsHighSidePre(planyear,simId))
			varAdd += subVar.getKvar();
		return varAdd;
	}
	public int getKvarHighSideAdd(int planyear) throws SQLException{
		int varAdd = 0;
		for(SubVar subVar:getSubVarsHighSideAdd(planyear))
			varAdd += subVar.getKvar();
		return varAdd;
	}
	public int getKvarHighSideRem(int planyear) throws SQLException{
		int varAdd = 0;
		for(SubVar subVar:getSubVarsHighSideRem(planyear))
			varAdd += subVar.getKvar();
		return varAdd;
	}
	public int getKvarHighSidePost(int planyear,int simId)throws SQLException{
		int varAdd = 0;
		for(SubVar subVar:getSubVarsHighSidePost(planyear,simId))
			varAdd += subVar.getKvar();
		return varAdd;
	}
	public int getKvarHighSideDelta(int planyear)throws SQLException{
		return getKvarHighSideAdd(planyear) - getKvarHighSideRem(planyear);
	}



	public void setFacilityObject(FacilityObject fo) throws SQLException {
		if(fo!=null){
			setCoTypeId(fo.getCoTypeId());
			setFacilityId(fo.getId());
		}else{
			setCoTypeId(0);
			setFacilityId(0);
		}
	}

	public void setCost(int year, int cost) throws SQLException {
		getSceProjElemCostYear(year).setCost(cost);
	}

	public double getNameplatePre(int planyear,int simId) throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getNameplatePost(planyear,simId,null);
		return 0;
	}
	/**
	 * FIXME eddie null op date
	 * 
	 * Substation Nameplate day after the project
	 * 
	 * @return double Substation Nameplate day after the project
	 * @throws SQLException 
	 * @throws SQLException
	 */
	public double getNameplatePost(int planyear,int simId,Collection<SceProjElemCost> without) throws SQLException {
		if(getModelDate()!=null){
			double np = 0;
			Calendar post = (Calendar)getModelDate().clone();
			post.add(Calendar.DATE, 1);
			for(Bank b:getBanksPost(planyear,simId,without))
				if(!b.isSpare())
					np += b.getNameplate(post,without);
			return np;
		}
		return 0;
	}

	public double getNameplateDelta(int planyear, int simId)throws SQLException{
		return getNameplatePost(planyear,simId,null) - getNameplatePre(planyear,simId);
	}
	public double getPLLFactorPre(int planyear,int simId) throws SQLException{
		return getPLLFactorPre(planyear,simId,null);
	}
	public double getPLLFactorPre(int planyear,int simId,Collection<SceProjElemCost> without) throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getPLLFactorPost(planyear,simId,without);
		return 0;
	}
	public double getPLLFactorPost(int planyear,int simId) throws SQLException{
		return getPLLFactorPost(planyear,simId,null);
	}

	//FIXME
	public double getPLLFactorPost(int planyear,int simId,Collection<SceProjElemCost> without) throws SQLException {
		if(without == null || !without.contains(this)){
			double pll = -1;
			for(ScopeItem si:getScopeItems())
				if(si.isEnabledBl() && si.getScopeType().getModelingCoTypeId() == CoType.PLL_SUB)
					pll = si.getQuantity()/100.0;
			if(pll != -1)
				return pll;
		}
		return getPLLFactorPre(planyear,simId,without);
	}
	public double getELLFactorPre(int planyear,int simId) throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getELLFactorPost(planyear,simId);
		return 0;
	}
	public double getELLFactorPost(int planyear,int simId) throws SQLException {
		double ell = -1;
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getScopeType().getModelingCoTypeId() == CoType.ELL_SUB)
				ell = si.getQuantity()/100.0;
		if(ell != -1)
			return ell;
		return getELLFactorPre(planyear,simId);
	}
	public double getN1FactorPre(int planyear,int simId) throws SQLException{
		SceProjElemCost pc = getPriorSceProjElemCost(planyear,simId);
		if(pc != null)
			return pc.getN1FactorPost(planyear,simId);
		return 0;
	}
	public double getN1FactorPost(int planyear,int simId) throws SQLException {
		double n1 = -1;
		for(ScopeItem si:getScopeItems())
			if(si.isEnabledBl() && si.getScopeType().getModelingCoTypeId() == CoType.N1_BBANK)
				n1 = si.getQuantity()/100.0;
		if(n1 != -1)
			return n1;
		return getN1FactorPre(planyear,simId);
	}

	/**
	 * Method to check if a Bank is being assigned in the ScopeItems, due to potential SI Bank/FO assignment not matching Cost FO
	 * @return boolean True = getScopeItems contains Xfmr
	 * @throws SQLException
	 */
	public boolean isContainingBankScopeItem()throws SQLException{
		for(ScopeItem s: getScopeItems()){
			if(s.getCoTypeId() == CoType.BANK)
				return true;
		}
		return false;
	}

	public boolean isInService() throws SQLException {
		return getInServiceDate() != null && isEnabledBl();
	}

	/**
	 * Returns a decoded text representation of the elem 
	 * scope based on default title selection.
	 * 
	 * @return the decoded element scope
	 */
	public String getScopeDesc(){
		return getScope();
//		return decodeVariables(getScopeActual());
	}


	/**
	 * Returns the elemtn scope encoded for preprocessors
	 * or it returns the stored database scope (based on default
	 * title selection).
	 * 
	 * @return the derived default title based on scope items.
	 */
	public String getScopeActual() {
		if(isUseDefaultScope() || getScope()==null || getScope().length()==0){
			try {
				return getActualDefaultScope();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		return getScope();
	}

	/**
	 * Decodes VARIABLES used in Project Title and GRC Testimony 
	 * 
	 * @param input
	 * @return String
	 * @throws SQLException 
	 */
	public String decodeVariables(String titleText) {
		//return the original title text if null
		if(titleText!=null && titleText.length()>0) {
			try {//FYI - this is the actual decode method call
				titleText = deriveExpression(titleText);
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		return titleText;
	}

	//FIXME use buffer
	//FIXME use buffer
	private String deriveExpression(String preprocessorTest) throws SQLException{
		if(preprocessorTest!=null && preprocessorTest.length()>0 && preprocessorTest.contains("&")) {
			//			Hashtable<Integer, LinkedList<ScopeItem>> hash = new Hashtable<Integer, LinkedList<ScopeItem>>();

			int pY=0;
			if(getSceProjRev()==null)
				pY = Department.getActivePlanYear();
			else
				pY = getSceProjRev().getPlanYear();

			//===============================================
			//iterate through my unique list
			//===============================================
			for(ScopeItem scopeItem: getScopeItems()){
				if(scopeItem.isEnabledBl() ){
					FacilityObject fo = scopeItem.getFacilityObject(pY); 
					//@Facility
					preprocessorTest=preprocessorTest.replaceAll("&Facility:"+scopeItem.getScopeSummaryIdentifier(), ""+fo);
					if(fo != null){
						//&PrimaryKv
						preprocessorTest=preprocessorTest.replaceAll("&PrimaryKv:"+scopeItem.getScopeSummaryIdentifier(), fo.getPrimaryKv()+"");
						//&SecondaryKv
						preprocessorTest=preprocessorTest.replaceAll("&SecondaryKv:"+scopeItem.getScopeSummaryIdentifier(), fo.getSecondaryKv()+"");
					}
					//&CktCountAfter
					preprocessorTest=preprocessorTest.replaceAll("&CktCountAfter:"+scopeItem.getScopeSummaryIdentifier(), ""+getCktsPost(pY, getSimId(),null).size());
					//&CktCountBefore
					preprocessorTest=preprocessorTest.replaceAll("&CktCountBefore:"+scopeItem.getScopeSummaryIdentifier(), ""+getCktsPre(pY, getSimId(),null).size());

					//&capAdd	
					if(scopeItem.getScopeType().getModelingCoTypeId()==CoType.TRANSFORMER ){

						preprocessorTest=preprocessorTest.replaceAll("&CapAdd:"+scopeItem.getScopeSummaryIdentifier(), ""+Calculate.round(scopeItem.getQuantity(),1));
						//if(scopeItem.getSceProjElemCost()!=null)
						preprocessorTest=preprocessorTest.replaceAll("&CapAddPre:"+scopeItem.getScopeSummaryIdentifier(), 
								""+Calculate.round(getNameplatePre(pY, getSimId()),1));
						//if(scopeItem.getSceProjElemCost()!=null)
						preprocessorTest=preprocessorTest.replaceAll("&CapAddPost:"+scopeItem.getScopeSummaryIdentifier(), 
								""+Calculate.round(getNameplatePost(pY, getSimId(), null),1));
					}

					//&CktAdd || &CktRemove
					if(scopeItem.getScopeType().getModelingCoTypeId()==CoType.CIRCUIT){
						preprocessorTest=preprocessorTest.replaceAll("&CktAdd:"+scopeItem.getScopeSummaryIdentifier(), ""+Math.round(scopeItem.getQuantity()));
						preprocessorTest=preprocessorTest.replaceAll("&CktRemove:"+scopeItem.getScopeSummaryIdentifier(), ""+Math.round(scopeItem.getQuantity()));
					}

					//&VarAdd || &VarRemove
					if(scopeItem.getScopeType().getModelingCoTypeId()==CoType.SUB_VAR){
						preprocessorTest=preprocessorTest.replaceAll("&VarAdd:"+scopeItem.getScopeSummaryIdentifier(), ""+Calculate.round(scopeItem.getQuantity(),1));
						preprocessorTest=preprocessorTest.replaceAll("&VarRemove:"+scopeItem.getScopeSummaryIdentifier(), ""+Calculate.round(scopeItem.getQuantity(),1));
					}
				}
			}

		}
		return preprocessorTest;
	}

	private String getActualDefaultScope() throws SQLException {
		StringBuffer defaultScope = new StringBuffer();

		//===============================================
		//iterate through my unique list
		//===============================================
		for(ScopeItem s: getScopeItems()){
			if(s.isEnabledBl() ){

				//Remove a Transformer
				if(s.getScopeType().getModelingCoTypeId()==CoType.TRANSFORMER && s.getScopeType().getDefaultQuantity()==-1){
					defaultScope.append("Decrease transformer capacity from &CapAddPre:").
					append(s.getScopeSummaryIdentifier()).append(" to &CapAddPost:").append(s.getScopeSummaryIdentifier())
					.append(" MVA.");
				}

				//"Add a Circuit"
				if(s.getScopeType().getModelingCoTypeId()==CoType.CIRCUIT && s.getScopeType().getDefaultQuantity()==1){

					defaultScope.append("Add &CktAdd:").append(s.getScopeSummaryIdentifier()).
					append(" -&SecondaryKv:").append(s.getScopeSummaryIdentifier()).
					append(" kV circuit(s) for a total of &CktCountAfter:").append(
							s.getScopeSummaryIdentifier()).append(".");

				}
				//Remove a Circuit
				if(s.getScopeType().getModelingCoTypeId()==CoType.CIRCUIT && s.getScopeType().getDefaultQuantity()==-1){
					defaultScope.append("Remove &CktRemove:").append(s.getScopeSummaryIdentifier()).
					append("-&SecondaryKv:").append(s.getScopeSummaryIdentifier()).
					append(" kV circuit(s) for a total of &CktCountBefore:").
					append(s.getScopeSummaryIdentifier()).append(".");
				}

				//Add a Capacitor Bank
				if(s.getScopeType().getModelingCoTypeId()==CoType.SUB_VAR && s.getScopeType().getDefaultQuantity()==1){
					defaultScope.append("Add &VarAdd:").append(s.getScopeSummaryIdentifier()).
					append(" MVAR of capacitors.");
				}
				//Remove a Capacitor Bank
				if(s.getScopeType().getModelingCoTypeId()==CoType.SUB_VAR && s.getScopeType().getDefaultQuantity()==-1){
					defaultScope .append("Remove &VarAdd:").append(s.getScopeSummaryIdentifier()).append(" MVAR of capacitors.");
				}
			}//end while
			defaultScope.append("\n");
		}

		return defaultScope.toString();

	}

	/**
	 * TreeSet of all of the unique ScopeTypes from the Scope Items assigned to this ProjElemCost 
	 * @return
	 * @throws SQLException
	 */
	public TreeSet<ScopeItem> getScopeItemSummary(int planyear) throws SQLException{
		Hashtable<String,ScopeItem> hash = new Hashtable<String,ScopeItem>();
		for(ScopeItem si: getScopeItems()){
			if(si.isEnabledBl() ){
				ScopeItem temp = hash.get(si.getScopeType().getHashKey()+getCoType().getHashKey()+getFacilityId());
				if(temp == null){
					temp = new ScopeItem(0);
					temp.setScopeTypeId(si.getScopeTypeId());
					temp.setFacilityObject(getFacilityObject(planyear));
					hash.put(temp.getScopeType().getHashKey()+getCoType().getHashKey()+getFacilityId(), temp);
				}
				//BME finish math for summary table, no bank PLL/ELL, get last Sub PLL,ELL,N-1
				temp.setQuantity(temp.getQuantity() + si.getQuantityBl(planyear));
			}
		}
		return new TreeSet<ScopeItem>(hash.values());
	}

	public boolean wouldBeInService(Calendar asOf) throws SQLException {
		if(getModelDate() == null || asOf == null) return false;
		return asOf.getTimeInMillis()+Calculate.ONE_DAY > getModelDate().getTimeInMillis();
	}

	/**
	 * Evaluates cost is Enabled, is Current Rev, and Not Cancelled
	 * @return
	 * @throws SQLException
	 */
	public boolean isActiveBl(int planyear, int simId) throws SQLException{
		return isEnabledBl() && (getSceProjRev() == null || getSceProjRev().isActiveBl(planyear,simId));
	}
	public boolean isCurRev(int planyear, int simId)throws SQLException{
		return getSceProjRev() == null || getSceProjRev().isCurRev(planyear, simId);
	}
	public int compareTo(Object o){
		if(o instanceof SceProjElemCost){
			SceProjElemCost pec = (SceProjElemCost)o;
			if(getModelDate() != null && pec.getModelDate() != null){
				if(getModelDate().getTimeInMillis() < pec.getModelDate().getTimeInMillis())
					return -1;
				if(getModelDate().getTimeInMillis() > pec.getModelDate().getTimeInMillis())
					return 1;
			}
		}
		return super.compareTo(o);
	}

	//
	public TreeSet<Referee> getFlags(int simId) throws SQLException{
		TreeSet<Referee> flags = new TreeSet<Referee>(); //super.getFlags(simId);

		//		int flagId = getInterSysTransFlag(simId);		
		//		if(flagId > 0)
		//		flags.add(new Referee(this,Flag.getInstance(getPlanyear(), flagId)));

		//		int flagId = getACLFlag(simId);
		//		if(flagId > 0)
		//		flags.add(new Referee(this,Flag.getInstance(getPlanyear(), flagId)));

		//				for(SceProjElemCost pec: getSceProjElemCosts())
		//				flags.addAll(pec.getFlags(simId));

		return flags;		
	}


	public int getPlanyear() throws SQLException {
		if(getSceProjRev()==null)
			return 0;
		return getSceProjRev().getPlanYear();
	}

	public int getSimId() throws SQLException {
		if(getSceProjRev()==null)
			return 0;
		return getSceProjRev().getSimId();
	}

	public void setSubPLLPercent(double pllPercent) throws SQLException{
		ScopeItem si=null;
		for(ScopeItem si2:getScopeItems()){
			if(si2.getScopeType().getModelingCoTypeId() == CoType.PLL_SUB){
				si = si2;
				break;
			}
		}
		if(si == null){
			si = new ScopeItem();
			si.setTitle("Sub PLL Set");
			si.setDescription("Auto Generated Sub PLL Set");
			si.setScopeType(ScopeType.getAddInstance(CoType.PLL_SUB));
			addScopeItem(si);
		}
		si.setQuantity(pllPercent);
	}
	public void setSubELLPercent(double ellPercent) throws SQLException{
		ScopeItem si=null;
		for(ScopeItem si2:getScopeItems()){
			if(si2.getScopeType().getModelingCoTypeId() == CoType.ELL_SUB){
				si = si2;
				break;
			}
		}
		if(si == null){
			si = new ScopeItem();
			si.setTitle("Sub ELL Set");
			si.setDescription("Auto Generated Sub ELL Set");
			si.setScopeType(ScopeType.getAddInstance(CoType.ELL_SUB));
			addScopeItem(si);
		}
		si.setQuantity(ellPercent);
	}
	public void setSubN1Percent(double n1Percent) throws SQLException{
		ScopeItem si=null;
		for(ScopeItem si2:getScopeItems()){
			if(si2.getScopeType().getModelingCoTypeId() == CoType.N1_BBANK){
				si = si2;
				break;
			}
		}
		if(si == null){
			si = new ScopeItem();
			si.setTitle("Sub N-1 Set");
			si.setDescription("Auto Generated Sub N-1 Set");
			si.setScopeType(ScopeType.getAddInstance(CoType.N1_BBANK));
			addScopeItem(si);
		}
		si.setQuantity(n1Percent);
	}
	public int getStatus() throws SQLException {
		int status = getStatusActiveDetails();
		if(!isEnabledBl()){
			if(status == SceProjRev.NEW)
				return SceProjRev.ABORTED;
			return SceProjRev.CANCELLED;
		}
		if(getInServiceDate() == null || getInServiceDate().getTimeInMillis() > Calendar.getInstance().getTimeInMillis())
			return SceProjRev.ACTIVE_STATUS;
		return SceProjRev.COMPLETE;
	}
	public int getStatusFull() throws SQLException{
		switch(getStatus()){
			case SceProjRev.ABORTED: return SceProjRev.ABORTED;
			case SceProjRev.CANCELLED: return SceProjRev.CANCELLED;
			case SceProjRev.COMPLETE: return SceProjRev.COMPLETE;
		}
		return getStatusActiveDetails();
	}
	public int getStatusActiveDetails()throws SQLException{
		if(getSceProjRev() == null)
			return SceProjRev.NEW;
		return getSceProjRev().getProjStatusActiveDetails();

	}
	//XXX ELLFactorPost does not exist with a without project
	public double getELLPost(int planyear, int simId, Collection<SceProjElemCost> without) throws SQLException {
		return getELLFactorPost(planyear, simId)*getNameplatePost(planyear, simId, without);
	}
	public double getN1Post(int planyear, int simId, Collection<SceProjElemCost> without) throws SQLException {
		return getN1FactorPost(planyear, simId)*getNameplatePost(planyear, simId, without);
	}
	public double getPLLPost(int planyear, int simId, Collection<SceProjElemCost> without) throws SQLException {
		//		EspLogger.debug(this, "getPLLFactorPost: "+ getPLLFactorPost(planyear, simId, without));
		//		EspLogger.debug(this, "SceProjElemCoist: "+ toString());
		//		EspLogger.debug(this, "getNameplatePost: "+ getNameplatePost(planyear, simId, without));
		return getPLLFactorPost(planyear, simId, without)*getNameplatePost(planyear, simId, without);
	}
	public void setInServiceDate(Calendar inServiceDate) throws SQLException{
		super.setInServiceDate(inServiceDate);
		resortFacilities();
	}
	public void resortFacilities() throws SQLException{
		if(getFacilityId() != 0){
			FacilityObject fo = getFacilityObject(Department.getActivePlanYear());
			if(fo != null)
				fo.invalidateCache("getSceProjElemCosts");
			for(ScopeItem si:getScopeItems()){
				if(si.getFacilityId() != 0){
					FacilityObject fo2 = si.getFacilityObject(Department.getActivePlanYear());
					if(fo2 != null)
						fo.invalidateCache("getSceProjElemCosts");
				}
			}
		}
	}

	
	//TODO use Sub.getAreaSubs logic
	public int getBadProjectFlag(int planyear, int simId) throws SQLException {
		Flag flag = Flag.getInstance(planyear, Flag.PROJ_BAD_FLAG);
		FacilityObject fo = getFacilityObject(planyear);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && getNameplateDelta(planyear, simId)>0 && getSceProjRev().isDEProject() && getStatus() == Proj.ACTIVE) {
			if(fo instanceof Sub){
				Sub sub = (Sub)fo;
				double areaReserve = sub.getYear(getSimId(),getPeakYear(planyear)).getReserveNoProj(getSceProjRev());
				double areaPLL = sub.getYear(getSimId(),getPeakYear(planyear)).getPLLNoProj(getSceProjRev());

				if(sub instanceof Bbank){
					for(BbankTie bt:((Bbank)sub).getActiveFromTies(getSimId())){
						if(bt.getStrength().equals(BbankTie.STRONG)){
							areaReserve += bt.getToSub().getYear(getSimId(),getPeakYear(planyear)).getReserveNoProj(getSceProjRev());
							areaPLL += bt.getToSub().getYear(getSimId(),getPeakYear(planyear)).getPLLNoProj(getSceProjRev());
						}
					}
					for(BbankTie bt:((Bbank)sub).getActiveToTies(getSimId())){
						if(bt.getStrength().equals(BbankTie.STRONG)){
							areaReserve += bt.getFromSub().getYear(getSimId(),getPeakYear(planyear)).getReserveNoProj(getSceProjRev());
							areaPLL += bt.getFromSub().getYear(getSimId(),getPeakYear(planyear)).getPLLNoProj(getSceProjRev());
						}
					}
				}
				if(areaReserve/areaPLL>flag.getValue())
					return flag.getFlagId();
			}
		}
		return 0;
	}

	public double getImpedanceDelta(int planyear, int simId){
		//TODO EMM 1 Write this method
		return 0;
	}

	public int getZFlag(int planyear, int simId) throws SQLException {
		// TODO EMM 1 Create flag logic for impedance
		Flag flag = Flag.getInstance(planyear, Flag.PROJ_Z_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() &&  isActiveBl(planyear, simId))
			if(getNameplateDelta(planyear, simId) > 0 && getImpedanceDelta(planyear,simId)<flag.getValue())
				return flag.getFlagId();
		return 0;
	}

	public int getYearAheadCostFlag(int planyear, int simId) throws SQLException {
		Flag flag = Flag.getInstance(planyear, Flag.PROJ_NO_PLAN_COST_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && getSceProjRev().isDEProject() && getStatus() == Proj.ACTIVE)
			if(getCost((getCalendarYear()-1) ) < getTotalCost()*flag.getValue())
				return flag.getFlagId();
		return 0;
	}

	public int getTotalCostFlag(int planyear, int simId) throws SQLException {
		Flag flag = Flag.getInstance(planyear, Flag.PROJ_NO_COST_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && getSceProjRev().isDEProject() && getStatus() == Proj.ACTIVE )
			if(getTotalCost()<=flag.getValue())
				return flag.getFlagId();
		return 0;
	}


	public int getTotalCostDeltaFlag(int planyear, int simId) throws SQLException {
		return getSceProjRev().getTotalCostDeltaFlag(planyear);
	}

	public int getYearOfCostFlag(int planyear, int simId) throws SQLException {
		Flag flag = Flag.getInstance(planyear, Flag.PROJ_YEAR_OF_COST_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && getSceProjRev().isCurRev(planyear, simId) && getSceProjRev().isDEProject() && getStatus() == Proj.ACTIVE){
			//if(getCost(getCalendarYear()-1) < getTotalCost()*flag.getValue())
			if(getCost(getCalendarYear()) < getTotalCost()*flag.getValue()){		
				return flag.getFlagId();
			}}
		return 0;
	}

	public int getPLLDeltaFlag(int planyear, int simId) throws SQLException {
		return getSceProjRev().getPLLDeltaFlag();
	}
	public int getELLDeltaFlag(int planyear, int simId) throws SQLException {
		return getSceProjRev().getELLDeltaFlag();
	}
	public int getN1DeltaFlag(int planyear, int simId) throws SQLException {
		return getSceProjRev().getN1DeltaFlag();
	}

	public int getFutureActOpDateFlag(int planyear, int simId) throws SQLException {
		Flag flag = Flag.getInstance(planyear, Flag.PROJ_ACT_OP_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()&& (getSceProjRev().getProjectStatus()==SceProjRev.ACTIVE_STATUS) )
			if(getInServiceDate()!=null && getInServiceDate().getTimeInMillis() > Calendar.getInstance().getTimeInMillis() + (flag.getValue() * 24 * 60 * 60 * 1000))
				return flag.getFlagId();
		return 0;
	}

	public int getOpDatePassedFlag(int planyear, int simId) throws SQLException {
		Flag flag = Flag.getInstance(planyear, Flag.PROJ_OP_DATE_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && getSceProjRev().isDEProject() && getSceProjRev().isCurRev(planyear, simId) && getSceProjRev().getProjectStatus() == SceProjRev.ACTIVE_STATUS && !getSceProjRev().isRetracted() )
			if(getInServiceDate()==null && getModelDate().getTimeInMillis() < Calendar.getInstance().getTimeInMillis() + (flag.getValue() * 24 * 60 * 60 * 1000) )
				return flag.getFlagId();
		return 0;
	}

	public int getAddInconsistentFlag(int planyear, int simId) throws SQLException {
		return getSceProjRev().getAddInconsistentFlag();
	}

	//===================================================================================================

	private TreeSet<SceProjElemCost> findHistoryKeys(SceProjElemCost keyRequestor) throws SQLException {

		if(keyRequestor==null) return null;

		TreeSet<SceProjElemCost> keys = new TreeSet<SceProjElemCost>();

		//establish the previous publication calendar date
		Calendar previousPublication = Calendar.getInstance();
		previousPublication.set(Calendar.DAY_OF_MONTH, 1);

		//if a previous version exists
		if(keyRequestor.getSceProjRev()!=null && keyRequestor.getSceProjRev().getPrevRev(SceProjRev.APPROVED)!=null)
			//now compare keyRequester to the previous version's approved spec's
			for(SceProjElemCost specOld : keyRequestor.getSceProjRev().getPrevRev(SceProjRev.APPROVED).getSceProjElemCosts()){

				//Look for matches of the same type
				if(specOld.getSceElemId() == keyRequestor.getSceElemId()){

					if(specOld.getTitle()==null&&keyRequestor.getTitle()==null)
						keys.add(specOld);

					else 
						if((specOld.getTitle()==null||keyRequestor.getTitle()==null))
							continue;

						else if((specOld.getTitle().equals(keyRequestor.getTitle())))						
							keys.add(specOld);
				}
			}
		return keys;
	}

	public String getPubPrintStatus(IWPStatus status){
		if(status.equals(IWPStatus.NEW_PROJECT))
			return "New Project";
		if(status.equals(IWPStatus.NEW_SCOPE_CHANGE))
			return "New Scope Change";
		if(status.equals(IWPStatus.NEW_OD_CHANGE))
			return "New OD Change";
		if(status.equals(IWPStatus.NEW_BUDGET_CHANGE))
			return "New Budget Change";
		if(status.equals(IWPStatus.NEW_CHANGE))
			return "New Change";
		if(status.equals(IWPStatus.NEW_WORK_ELEMENT))
			return "New Work Element";

		return "";
	}

	/**
	 * TODO complete logic and test and move to specy
	 * 
	 * 
	 * @return the status if any changes in last month.
	 * 
	 * @throws SQLException 
	 */
	public String getPublicationStatus() throws SQLException{
		StringBuffer buffer = new StringBuffer();

		//establish the previous publication calendar date
		Calendar previousPublication = Calendar.getInstance();
		previousPublication.set(Calendar.DAY_OF_MONTH, 1);

		//first of all, see if this a new project since last publication:
		//project insert timestamp field is null in some cases. 
		//inserted check to verify is not null (null exception 
		//occurs when running IWP reports (HiK).
		if(getSceProjRev().getSceProj().getInsertTs() != null && this.getSceProjRev().getSceProj().getInsertTs().getTimeInMillis()>previousPublication.getTimeInMillis())
			return getPubPrintStatus(IWPStatus.NEW_PROJECT);


		//look for matching spec's in previous version
		TreeSet<SceProjElemCost> matchSet = findHistoryKeys(this);

		if(matchSet.size()>0){
			for(SceProjElemCost match: matchSet){
				//DO NOT INCLUDE APPROVED OR BUDGET SPEC'S
				if(getCostStage().getCostType()==CostStage.Type.Proposed.ordinal()){
					//check within the last 30 days....
					//Null pointer exception fix for IWP master list report (HiK)
					if(!isSame(getScopeDesc(),match.getScopeDesc())){//: java.lang.NullPointerException
						setPubDiffDetails(StringUtils.difference(getScopeDesc(), match.getScopeDesc()));
						return getPubPrintStatus(IWPStatus.NEW_SCOPE_CHANGE);
					}
					//for approved/canceled projects
					if(match.getProposedOd()!=null && getProposedOd()!=null && !getProposedOd().equals(match.getProposedOd())){
						setPubDiffDetails("OD changed from "+FormatText.USER_DATE.format(match.getProposedOd().getTime())+" to "+FormatText.USER_DATE.format(getProposedOd().getTime()));
						return getPubPrintStatus(IWPStatus.NEW_OD_CHANGE);
					}
					if(this.getTotalCost()!=match.getTotalCost()){
						setPubDiffDetails("Cost changed from $"+match.getTotalCost()+" to "+getTotalCost());
						return getPubPrintStatus(IWPStatus.NEW_BUDGET_CHANGE);
					}
				}
			}			
		}	
		if(this.getInsertTs().getTimeInMillis()>previousPublication.getTimeInMillis())
			return getPubPrintStatus(IWPStatus.NEW_WORK_ELEMENT);

		return buffer.toString();
	}	

	private StringBuffer diffDetails = new StringBuffer();

	public void setPubDiffDetails(String details){
		diffDetails.append(details);
	}

	public String getPubDiffDetails(){
		return diffDetails.toString();
	}

	public Sub getSub(int planyear) throws SQLException{
		FacilityObject fo = getFacilityObject(planyear);
		if(fo instanceof Sub)
			return (Sub)fo;
		else if(fo instanceof Bank)
			return ((Bank)fo).getSub();
		else if(fo instanceof Ckt)
			return ((Ckt)fo).getBbank(getSimId());
		return null;
	}

	public Sys getSys(int planyear)throws SQLException{
		FacilityObject fo = getFacilityObject(planyear);
		if(fo instanceof Sys)
			return (Sys)fo;
		Sub s = getSub(planyear);
		if(s != null && s.getYear(getSimId(), getPeakYear(planyear))!=null)
			return s.getYear(getSimId(), getPeakYear(planyear)).getSys();
		return null;	
	}

	public District getDistrict(int planyear)throws SQLException{
		FacilityObject fo = getFacilityObject(planyear);
		if(fo instanceof District)
			return (District)fo;
		Sub s = getSub(planyear);
		if(s != null)
			return s.getDistrict();
		return null;
	}

	public Region getRegion(int planyear)throws SQLException{
		FacilityObject fo = getFacilityObject(planyear);
		if(fo instanceof Region)
			return (Region)fo;
		Sys s = getSys(planyear);
		if(s != null)
			return s.getRegion();
		return null;
	}

	public Zone getZone(int planyear)throws SQLException{
		FacilityObject fo = getFacilityObject(planyear);
		if(fo instanceof Zone)
			return (Zone)fo;
		Region r = getRegion(planyear);
		if(r != null)
			return r.getZone();
		return null;	
	}
	@Override
	public void addScopeItem(ScopeItem scopeItem)throws SQLException{
		if(getCostStage().getCostType()!=CostStage.Type.Proposed.ordinal())
			throw new SQLException("Scope Items can only be added to proposed costs");
		super.addScopeItem(scopeItem);
	}

	public String getWoNum(){
		String wo = getWo();
		if(wo != null && wo.contains("-"))
			return wo.substring(wo.indexOf("-")+1, wo.length());
		return null;
	}

	public String getLoc() throws SQLException{
		String wo = getWo();
		if(wo != null && wo.contains("-"))
			return wo.substring(0, wo.indexOf("-"));
		return null;
	}

	public String getSharedCostNumSeq() {
		return "SHARED_COST_NUM_SEQ";
	}

	public LastModified getLastModified() throws SQLException {
		LastModified specLm = new LastModified(getModifiedUser(), getModifiedTs());
		for(SceProjElemCostYear specy:new TreeSet<SceProjElemCostYear>(getSceProjElemCostYears())){
			LastModified specyLm = specy.getLastModified();
			if(specyLm.getModifiedTs()!=null && (specLm.getModifiedTs()==null || specyLm.getModifiedTs().getTimeInMillis()>specLm.getModifiedTs().getTimeInMillis())){
				specLm = specyLm;
			}
		}

		if(specLm.getModifiedTs() == null)
			specLm = new LastModified(getInsertUser(), getInsertTs());

		return specLm;

	}

	//TODO use regular expression
	public boolean isEditable(int simId, String field) throws SQLException{
		if(getSceProjRev().getProgramId()==Program.DSP &&  !User.getActiveUser().getUserRole().isAdmin())
			return false;
		//		if(getSceProjRev().getProgramId()==Program.DSP &&  !(User.getActiveUser().getUserRole().isAdmin() || User.getActiveUser().getUserRole().isIWPUser())) //XXX added to lock down projects
		//			return false;
		if(isNewInstance()) return true;
		if(getSceProjRev() != null){
			if(ALWAYS_FIELDS.contains(field))return getSceProjRev().isAlwaysEditable(simId);
			if(INFO_FIELDS.contains(field))return getSceProjRev().isInfoEditable(simId);
			if(BSS_FIELDS.contains(field))return getSceProjRev().isBSSEditable(simId);
		}
		else
			return true;
		throw new SQLException("Unknown Field: "+field);
	}


	//	//	@Override
	//	//	public void setSceProjRevId(int sceProjRevId) throws SQLException{
	//	//		if(getSceProjRev().getCurrentSceProjElemCosts().size()==1 && isEnabled())
	//	//			throw new SQLException("A project must have atleast one proposed enabled Proj Elem Cost");
	//	//		super.setSceProjRevId(sceProjRevId);
	//	//	}
	@Override
	public void setEnabled(boolean enabled) throws SQLException{
		//if(!isNewInstance() && !enabled && getSceProjRev().getCurrentSceProjElemCostsNoBudget().size()==1)
		//throw new SQLException("A project must have atleast one proposed enabled Proj Elem Cost");
		super.setEnabled(enabled);
	}
	@Override
	public void delete() throws SQLException{
		//only apply condition to non approved and non budget cost elements
		if(getCostStage().getCostType()==CostStage.Type.Proposed.ordinal() && getSceProjRev().getSceProjElemCosts(CostStage.Type.Proposed).size()==1)
			throw new SQLException("A project must have atleast one proposed enabled Proj Elem Cost");
		super.delete();
	}


	/**
	 * This method is to set the WO field to identify if this is a blanket cost element.
	 * If the value is true then "-Blanket" is written into the WO field other wise left blank.
	 * 
	 * @param value - boolean to signify whether this spec is a blanket or not
	 * @throws SQLException
	 */
	public void setBlanket(boolean value) throws SQLException {
		if((Boolean)value) {
			String wo = getWo();
			if(wo != null && wo.contains("-"))
				setWo(getWo().substring(0, wo.indexOf("-")+1)+"Blanket");
			else
				setWo("-Blanket");
		}
		else
			setWo("");
	}

	/**
	 * returns if this spec is a blanket pin or not.
	 * 
	 * @return
	 */
	public boolean isBlanket() {
		return getWo()!=null && getWo().contains("Blanket");
	}

	public int getQbrId() throws SQLException {
		if(getSubQbrId()==0) return 0;
		return SubQbr.getInstance(getSubQbrId()).getQbrId();
	}

	public Calendar getPrelimDate() {
		return null;
	}


	public Calendar getOpDate() {
		return getApprovedOd();
	}

	@Override
	public Calendar getModelDate() {
		Calendar date = getInServiceDate();
		if(date==null)
			date = getOpDate();
		if(date == null)
			date = getNeedDate();
		return date;
	}

	public Calendar getNeedDate() {
		return getProposedOd();
	}

	public void setNeedDate(Calendar needDate) throws SQLException{
		if(needDate==null) throw new SQLException("NEED_DATE can not be null");
		super.setProposedOd(needDate);
		resortFacilities();
	}

	/**
	 * Returns the Factor of the element cost that is PUC.
	 * @return PUC Factor
	 */
	public double getPUCFactor(){
		return 1.0-getFercFunding();
	}

	/**
	 * Returns the Factor of the element cost that is FERC.
	 * @return FERC Factor
	 */
	public double getFERCFactor(){
		double ff = getFercFunding();
		if(ff > 1.0)
			return 1.0;
		if(ff < 0.0)
			return 0.0;
		return ff;
	}
	public void insert() throws SQLException{
		setCostId(0); //Clear temp Cost Id
		super.insert();
	}
	public void setProperty(String prop, Object newValue, Object oldValue) throws SQLException{
		super.setProperty(prop, newValue, oldValue);
		SceProjRev rev = SceProjRev.getInstance(getSceProjRevId(), false);
		int planyear = rev!=null?rev.getPlanYear():Department.getActivePlanYear();
		int simId = rev!=null?rev.getSimId():0;
		FacilityObject fo = getFacilityObject(planyear,simId);
		if(fo instanceof Sub && !(fo instanceof Tbank)){
			((Sub)fo).invalidateAllCache();
			//			for(int y=-1; y<=User.getActiveUser().getPlanFor(planyear, getSimId()); y++){
			//				SubYear sy = ((Sub)fo).getYear(getSimId(), planyear+y, false);
			//				if(sy!=null)
			//					sy.invalidateAllCache();
			//			}
		}
	}
	public double getContFactor() throws SQLException{
		ProjContingency pc = ProjContingency.getBestMatch(this);
		if(pc!=null){
			SceProjRev rev = getSceProjRev();
			return (rev!=null && rev.isMajorProject())?pc.getMajorCont():pc.getRegCont();
		}
		return 0;
	}
	public int getContAmount() throws SQLException{
		return (int)Math.round((getSubTotalCost()-getPriorCost())*getContFactor());
	}
	public int getTotalCost() throws SQLException{
		return getSubTotalCost()+getContAmount();
	}
	public Calendar getRevTs() throws SQLException {
		SceProjRev rev = getSceProjRev();
		if(rev!=null)
			return rev.getRevTs();
		return null;
	}
	public Program getProgram() throws SQLException {
		SceProjRev rev = getSceProjRev();
		if(rev!=null)
			return rev.getProgram();
		return null;
	}
	public double getDelta(){
		if(this.getOpDate()!=null)
			return Math.round(((getOpDate().getTimeInMillis()-getNeedDate().getTimeInMillis())/(86400*1000.0*30)));
		return 0;
	}

	public void setOpDate(Calendar value) throws SQLException {
		super.setApprovedOd(value);
	}

	public double getRateSce(CostType ct) throws SQLException {
		for(ProjCostRate pcr:getProjCostRates())
			if(pcr.getCostTypeId()==ct.getId())
				return pcr.getRateSce();
		return ct.getRateSce(getSceProjRev().getRevTs());
	}

	public void setRateSce(CostType ct, double rate) throws SQLException{
		for(ProjCostRate pcr:getProjCostRates()){
			if(pcr.getCostTypeId()==ct.getId()){
				pcr.setRateSce(rate);
				return;
			}
		}
		ProjCostRate pcr = new ProjCostRate();
		pcr.setCostType(ct);
		pcr.setRateSce(rate);
		addProjCostRate(pcr);
	}

	public double getRateCont(CostType ct) throws SQLException {
		for(ProjCostRate pcr:getProjCostRates())
			if(pcr.getCostTypeId()==ct.getId())
				return pcr.getRateCont();
		return ct.getRateCont(getSceProjRev().getRevTs());
	}

	public void setRateCont(CostType ct, double rate) throws SQLException{
		for(ProjCostRate pcr:getProjCostRates()){
			if(pcr.getCostTypeId()==ct.getId()){
				pcr.setRateCont(rate);
				return;
			}
		}
		ProjCostRate pcr = new ProjCostRate();
		pcr.setCostType(ct);
		pcr.setRateCont(rate);
		addProjCostRate(pcr);
	}

	public double getHours(CostType ct) throws SQLException{
		return getDirectHours(ct)+getIndirectHours(ct);
	}
	//TODO
	public double getHours(CostType ct,Funder type) throws SQLException{
		return getDirectHours(ct,type)+getIndirectHours(ct,type);
	}
	public void setHours(CostType ct, double hours) throws SQLException{
		setIndirectHours(ct,hours-getDirectHours(ct));
	}
	public double getIndirectHours(CostType ct)throws SQLException{
		SceProjElemLabor spel = getSceProjElemLabor(ct);
		if(spel!=null)
			return spel.getHours();
		return 0;
	}
	
	public double getIndirectHours(CostType ct,Funder type)throws SQLException{
		SceProjElemLabor spel = getSceProjElemLabor(ct);
		if(spel!=null)
			return spel.getHours()*(getIndirectHoursPercent(ct,type));
		return 0;
	}
	
	public double getIndirectHoursPercent(CostType ct,Funder type) throws SQLException{
		double tot =0;
		for(ScopeItem si:getScopeItems()){
			if(type == SceProjElemCost.Funder.CUSTOMER && si.getFunderId()==LookUp.CUSTOMER )
				tot += si.getUnitCost(ct);
				else if(type == SceProjElemCost.Funder.EXPENSE && si.getFunderId()==LookUp.EXPENSE)
					tot += si.getUnitCost(ct);
				else if(type == SceProjElemCost.Funder.CAPITAL && si.getFunderId()!=LookUp.EXPENSE && si.getFunderId()!=LookUp.CUSTOMER)
					tot += si.getUnitCost(ct);
			}
		if(tot!=0)
		return tot/getCostTotal(ct);
		
		return tot;
	}
	
	public double getDirectHours(CostType ct) throws SQLException{
		double total = 0;
		for(ScopeItem si:getScopeItems())
			total+=si.getUnitCost(ct);
		return total;
	}
	
	public double getDirectHours(CostType ct,Funder type) throws SQLException{
		double tot = 0;
		for(ScopeItem si:getScopeItems()){
			if(type == SceProjElemCost.Funder.CUSTOMER && si.getFunderId()==LookUp.CUSTOMER )
				tot += si.getUnitCost(ct);
				else if(type == SceProjElemCost.Funder.EXPENSE && si.getFunderId()==LookUp.EXPENSE)
					tot += si.getUnitCost(ct);
				else if(type == SceProjElemCost.Funder.CAPITAL && si.getFunderId()!=LookUp.EXPENSE && si.getFunderId()!=LookUp.CUSTOMER)
					tot += si.getUnitCost(ct);
			}
		return tot;
	}
	
	public double getDirectHoursWDFac(CostType ct) throws SQLException{
		double total = 0;
		for(ScopeItem si:getScopeItems())
			total+=si.getUnitCost(ct)*si.getDifficultyFactor(ct);
		return total;
	}
	public double getDirectSceHours(CostType ct) throws SQLException{
		double total = 0;
		for(ScopeItem si:getScopeItems())
			total+=si.getSceHrs(ct);
		return total;
	}
	public double getDirectContHours(CostType ct) throws SQLException{
		double total = 0;
		for(ScopeItem si:getScopeItems())
			total+=si.getContHrs(ct);
		return total;
	}
	public void setIndirectHours(CostType ct, double hours) throws SQLException{
		getSceProjElemLabor4Edit(ct).setHours(hours);
	}
	public void setDirectHours(CostType ct, double hours) throws SQLException{
		double cd = getDirectHours(ct);
		if(cd==0) return;
		double ratio = hours/cd;
		for(ScopeItem si:getScopeItems())
			si.setUnitCost(ct, si.getUnitCost(ct)*ratio);
	}

	public double getContFactor(CostType ct) throws SQLException{
		if(ct.getCostGroupId()==CostType.NON_CRAFT_GROUP){
			SceProjElemLabor spel = getSceProjElemLabor(ct);
				if(spel!=null)
					return spel.getContFactor();
		}
		else{
			double dHrs = getDirectHoursWDFac(ct);
			if(dHrs!=0)
				return getDirectContHours(ct)/dHrs;
		}
		return ct.getContFactor(getUnitCostBasisDate());
	}
	private Calendar getUnitCostBasisDate() throws SQLException {
		if(getSceProjRev()==null)
			return Calendar.getInstance();
		return getSceProjRev().getUnitCostBasisDate();
	}

	public void setContFactor(CostType ct,double contFactor) throws SQLException{
		if(ct.getCostGroupId()==CostType.NON_CRAFT_GROUP)
			getSceProjElemLabor4Edit(ct).setContFactor(contFactor);
		else
			for(ScopeItem si:getScopeItems())
				si.setContFactor(ct, contFactor);
	}

	public double getSceHours(CostType ct) throws SQLException{
		return getHours(ct)*getDifficultyFactor(ct)*(1-getContFactor(ct));
	}
	
	public double getSceHours(CostType ct,Funder type) throws SQLException{
		return getHours(ct,type)*getDifficultyFactor(ct)*(1-getContFactor(ct));
	}

	public double getContHours(CostType ct) throws SQLException{
		return getHours(ct)*getDifficultyFactor(ct)*getContFactor(ct);
	}

	public double getContHours(CostType ct,Funder type) throws SQLException{
		return getHours(ct,type)*getDifficultyFactor(ct)*getContFactor(ct);
	}
	
	//	public double getContFactor(CostType ct) throws SQLException {
	//		double ch = getContHours(ct);
	//		return ch/(ch+getSceHours(ct));
	//	}

	public double getCostSce(CostType ct) throws SQLException{
		return getRateSce(ct)*getSceHours(ct);
	}
	
	public double getCostSce(CostType ct,Funder type) throws SQLException{
		return getRateSce(ct)*getSceHours(ct,type);
	}
	
	public double getCostCont(CostType ct) throws SQLException{
		return getRateCont(ct)*getContHours(ct);
	}
	
	public double getCostCont(CostType ct,Funder type) throws SQLException{
		return getRateCont(ct)*getContHours(ct,type);
	}
	
	public double getCostTotal(CostType ct) throws SQLException{
		return getCostSce(ct)+getCostCont(ct);
	}
	
	public double getCostTotal(CostType ct,boolean expense) throws SQLException{
		return getCostSce(ct)+getCostCont(ct);
	}

	@Override
	public Collection<SceProjElemCost> getSceProjElemCosts(CostStage.Type type) throws SQLException {
		Collection<SceProjElemCost> costs = new TreeSet<SceProjElemCost>();
		costs.add(this);
		return costs;
	}
	
	public SceProjElemLabor getSceProjElemLabor(CostType ct) throws SQLException{
		for(SceProjElemLabor spel:getSceProjElemLabors())
			if(spel.getCostType()==ct)
				return spel;
		return null;
	}
	public SceProjElemLabor getSceProjElemLabor4Edit(CostType ct) throws SQLException{
		SceProjElemLabor spel = getSceProjElemLabor(ct);
		if(spel==null){
			spel = new SceProjElemLabor();
			spel.setCostType(ct);
			spel.setHours(getIndirectHours(ct));
			spel.setContFactor(getContFactor(ct));
			spel.setDifficultyFactor(getContFactor(ct));
			addSceProjElemLabor(spel);
		}
		return spel;
	}

	public double getDifficultyFactor(CostType ct) throws SQLException {
		if(ct.getCostGroupId()==CostType.CRAFT_GROUP){
			double dhrs = getDirectHours(ct);
			if(dhrs==0)
				return 1;
			return getDirectHoursWDFac(ct)/dhrs;
		}
		SceProjElemLabor spel = getSceProjElemLabor(ct);
		if(spel!=null)
			return spel.getDifficultyFactor();
		return 1;
		
	}

	public void setDifficultyFactor(CostType ct, double diffFactor) throws SQLException {
		if(ct.getCostGroupId()==CostType.CRAFT_GROUP)
			for(ScopeItem si:getScopeItems())
				si.setDifficultyFactor(ct, diffFactor);
		else{
			getSceProjElemLabor4Edit(ct).setDifficultyFactor(diffFactor);
		}
	}

	public double getLoaderRate(LookUp loader) throws SQLException{
		for(CostLoaderRate clr:getCostLoaderRates()){
			if(clr.getLoaderId()==loader.getId())
				return clr.getRate();
		}
//		for(OverheadLoaderRate ohlr:OverheadLoaderRate.getCollection(new String[]{"LOADER_ID","DELETED_TS"}, loader.getId(), null))
//			if(ohlr.getEffDate().compareTo(getRevTs())<1)
//				return ohlr.getRate();
//		EspLogger.message(this, new ESPDate(getRevTs()));
		if(getCostSheetOH()!=null && getCostSheetOH().getOverheadLoaderRate(loader, getRevTs())!=null)
			return getCostSheetOH().getOverheadLoaderRate(loader, getRevTs()).getRate();
		return 0;
	}
	public void setLoaderRate(LookUp loader, double rate) throws SQLException{
		CostLoaderRate clr = CostLoaderRate.getInstance(getCostId(), loader.getId());
		if(clr==null)
			clr = new CostLoaderRate(getCostId(), loader.getId());
		clr.setRate(rate);
		if(clr.isNewInstance())
			clr.insert();
	}
	public double getLoaderCost(LookUp loader) throws SQLException{
		return getLoaderRate(loader)*getLoaderGross(loader);
	}
	
	public double getLoaderCost(LookUp loader,Funder type) throws SQLException{
		return getLoaderRate(loader)*getLoaderGross(loader,type);
	}
	public void setLoaderCost(LookUp loader, double cost) throws SQLException{
		setLoaderRate(loader,cost/getLoaderGross(loader));
	}
	public double getLoaderGross(LookUp loader)throws SQLException{
		switch(loader.getId()){
			case LookUp.PROCUREMENT_MAT_IMM: return getProcurementCost(); 
			case LookUp.WAREHOUSE_MAT_IMM: return getInventoryCost(); 
			case LookUp.SCE_LABOR_OH: return getTotSceCost(CostType.CRAFT_GROUP)+getTotSceCost(CostType.NON_CRAFT_GROUP); 
			case LookUp.NON_LABOR_OH: return getTotalContCost()+getUnitCost(CostType.getInstance(CostType.MATERIAL))+getUnitCost(CostType.getInstance(CostType.SUB_CONT)); 
			case LookUp.SUPPLY_OH: return getCost(CostType.getInstance(CostType.MATERIAL));
			case LookUp.TOOL_OH: return getTotSceCost(CostType.CRAFT_GROUP); 
			case LookUp.VEHICLE_IMM: return getTotalSceCost(); 
			case LookUp.B_MATERIALS_OH: return getCost(CostType.getInstance(CostType.MATERIAL));
			case LookUp.DIST_PLAN_OH: return getTotalSceCost()+.36*getTotalContCost(); 
			case LookUp.PREFAB_OH: return getTotalLaborCost(); 
			case LookUp.BPI_OH: return getTotalLaborCost();
			case LookUp.IT_DIV_OH: return getTotalLaborCost()+getCost(CostType.getInstance(CostType.MATERIAL));
			case LookUp.PAID_ABSENCE: return getTotalSceNTCosts(); 
			case LookUp.MAT_SALES_TAX: return getCost(CostType.getInstance(CostType.MATERIAL)); 
			case LookUp.PENSIONS_BENEFITS: return getTotalSceCost(); 
			case LookUp.CONTIGENCY: return getGrossDirectExpenditures();
			case LookUp.ENGINEERING_PROCURE: return getGrossDirectExpenditures(); 
			case LookUp.ADMIN_GENERAL: return getGrossDirectExpenditures();
			case LookUp.TELECOM: return getTotalSceCost();
			case LookUp.ITCC : return getFullyLoadedCost(); 
			default: return 0.0; 
		}
	}
	
	
	public double getLoaderGross(LookUp loader,Funder type)throws SQLException{
		switch(loader.getId()){
			case LookUp.PROCUREMENT_MAT_IMM: return getProcurementCost(type); 
			case LookUp.WAREHOUSE_MAT_IMM: return getInventoryCost(type); 
			case LookUp.SCE_LABOR_OH: return getTotSceCost(CostType.CRAFT_GROUP,type)+getTotSceCost(CostType.NON_CRAFT_GROUP,type); 
			case LookUp.NON_LABOR_OH: return getTotalContCost(type)+getUnitCost(CostType.getInstance(CostType.MATERIAL),type)+getUnitCost(CostType.getInstance(CostType.SUB_CONT),type); 
			case LookUp.SUPPLY_OH: return getCost(CostType.getInstance(CostType.MATERIAL),type);
			case LookUp.TOOL_OH: return getTotSceCost(CostType.CRAFT_GROUP,type); 
			case LookUp.VEHICLE_IMM: return getTotalSceCost(type); 
			case LookUp.B_MATERIALS_OH: return getCost(CostType.getInstance(CostType.MATERIAL),type);
			case LookUp.DIST_PLAN_OH: return getTotalSceCost(type)+.36*getTotalContCost(type); 
			case LookUp.PREFAB_OH: return getTotalLaborCost(type); 
			case LookUp.BPI_OH: return getTotalLaborCost(type);
			case LookUp.IT_DIV_OH: return getTotalLaborCost(type)+getCost(CostType.getInstance(CostType.MATERIAL),type);
			case LookUp.PAID_ABSENCE: return getTotalSceNTCosts(type); 
			case LookUp.MAT_SALES_TAX: return getCost(CostType.getInstance(CostType.MATERIAL),type); 
			case LookUp.PENSIONS_BENEFITS: return getTotalSceCost(type); 
			case LookUp.CONTIGENCY: return getGrossDirectExpenditures(type);
			case LookUp.ENGINEERING_PROCURE: return getGrossDirectExpenditures(type); 
			case LookUp.ADMIN_GENERAL: return getGrossDirectExpenditures(type);
			case LookUp.TELECOM: return getTotalSceCost(type);
			case LookUp.ITCC : return getFullyLoadedCost(type); 
			default: return 0.0; 
		}
	}

	public double getProcurementCost()  throws SQLException{
		double tot=0;
		for(ScopeItem si:getScopeItems())
			tot+=si.ProcurementCost();
		return tot;
	}
	
	public double getProcurementCost(Funder type)  throws SQLException{
		double tot=0;
		for(ScopeItem si:getScopeItems()){
			if(type == SceProjElemCost.Funder.CUSTOMER && si.getFunderId()==LookUp.CUSTOMER )
				tot+=si.ProcurementCost();
				else if(type == SceProjElemCost.Funder.EXPENSE && si.getFunderId()==LookUp.EXPENSE)
					tot+=si.ProcurementCost();
				else if(type == SceProjElemCost.Funder.CAPITAL && si.getFunderId()!=LookUp.EXPENSE && si.getFunderId()!=LookUp.CUSTOMER)
					tot+=si.ProcurementCost();}
		return tot;
	}

	public double getInventoryCost()  throws SQLException{
		double tot=0;
		for(ScopeItem si:getScopeItems())
			tot+=si.getInventoryCost();
		return tot;
	}
	
	public double getInventoryCost(Funder type)  throws SQLException{
		double tot=0;
		for(ScopeItem si:getScopeItems()){
			if(type == SceProjElemCost.Funder.CUSTOMER && si.getFunderId()==LookUp.CUSTOMER )
				tot+=si.getInventoryCost();
				else if(type == SceProjElemCost.Funder.EXPENSE && si.getFunderId()==LookUp.EXPENSE)
					tot+=si.getInventoryCost();
				else if(type == SceProjElemCost.Funder.CAPITAL && si.getFunderId()!=LookUp.EXPENSE && si.getFunderId()!=LookUp.CUSTOMER)
					tot+=si.getInventoryCost();}
		return tot;
	}
	
	public double getPerUnitCost(CostType ct) throws SQLException{
		double tot=0;
		for(ScopeItem si:getScopeItems())
			tot+=si.getPerUnitCost(ct);
		return tot;
	}
	


	public double getUnitCost(CostType ct) throws SQLException{
		double tot=0;
		for(ScopeItem si:getScopeItems())
			tot+=si.getUnitCost(ct);
		return tot;
	}
	
	public double getUnitCost(CostType ct,Funder type) throws SQLException{
		double tot=0;
		for(ScopeItem si:getScopeItems()){
			if(type == SceProjElemCost.Funder.CUSTOMER && si.getFunderId()==LookUp.CUSTOMER )
				tot += si.getUnitCost(ct);
				else if(type == SceProjElemCost.Funder.EXPENSE && si.getFunderId()==LookUp.EXPENSE)
					tot += si.getUnitCost(ct);
				else if(type == SceProjElemCost.Funder.CAPITAL && si.getFunderId()!=LookUp.EXPENSE && si.getFunderId()!=LookUp.CUSTOMER)
					tot += si.getUnitCost(ct);
		}
		return tot;
	}

	public double getCost(CostType ct) throws SQLException{
		double tot=0;
		for(ScopeItem si:getScopeItems())
			tot+=si.getCost(ct);
		return tot;
	}

	public double getCost(CostType ct,Funder type) throws SQLException{
		double tot=0;
		for(ScopeItem si:getScopeItems()){
			if(type == SceProjElemCost.Funder.CUSTOMER && si.getFunderId()==LookUp.CUSTOMER )
					tot+=si.getCost(ct);
				else if(type == SceProjElemCost.Funder.EXPENSE && si.getFunderId()==LookUp.EXPENSE)
					tot+=si.getCost(ct);
				else if(type == SceProjElemCost.Funder.CAPITAL && si.getFunderId()!=LookUp.EXPENSE && si.getFunderId()!=LookUp.CUSTOMER)
					tot+=si.getCost(ct);
			}
		if(tot<0)
			EspLogger.message(this, tot+"");
		return tot;
	}
	
	//	public double getTotSceCraftCost() throws SQLException{
	//		double total;
	//		total=0;
	//		for(ScopeItem si : getScopeItems())
	//			total+=si.getTotSceCost(CostType.CRAFT_GROUP);
	//		return total;
	//	}

	public double getTotalSceNTCosts() throws SQLException{
		double total=0;
		for(CostType ct : CostType.getCostTypes(CostType.CRAFT_GROUP))
			total += getCostSce(ct)*ct.getNTRatio(getUnitCostBasisDate());
		for(CostType ct : CostType.getCostTypes(CostType.NON_CRAFT_GROUP))
			total += getCostSce(ct)*ct.getNTRatio(getUnitCostBasisDate());
		return total;
	}
	
	public double getTotalSceNTCosts(Funder type) throws SQLException{
		double total=0;
		for(CostType ct : CostType.getCostTypes(CostType.CRAFT_GROUP))
			total += getCostSce(ct,type)*ct.getNTRatio(getUnitCostBasisDate());
		for(CostType ct : CostType.getCostTypes(CostType.NON_CRAFT_GROUP))
			total += getCostSce(ct,type)*ct.getNTRatio(getUnitCostBasisDate());
		return total;
	}
	
	
	public double getTotSceCost(int costGroupId) throws SQLException{
		double total=0;
		for(CostType ct : CostType.getCostTypes(costGroupId))
			total += getCostSce(ct);//cont total cost
		return total;
	}

	public double getTotSceCost(int costGroupId,Funder type) throws SQLException{
		double total=0;
		for(CostType ct : CostType.getCostTypes(costGroupId))
			total += getCostSce(ct,type);//cont total cost
		return total;
	}
	
	
	//	public double getTotalSceNonCraftCost() throws SQLException{
	//		double total;
	//		total=0;
	//		for(CostType ct : CostType.getNonCraftCostTypes())
	//			total+=getCostSce(ct);
	//		return total;
	//	}

	public double getTotalSceCost() throws SQLException{
		return getTotSceCost(CostType.CRAFT_GROUP)+getTotSceCost(CostType.NON_CRAFT_GROUP);
	}
	
	public double getTotalSceCost(Funder type) throws SQLException{
		return getTotSceCost(CostType.CRAFT_GROUP,type)+getTotSceCost(CostType.NON_CRAFT_GROUP,type);
	}

	//	public double getTotConCraftCost() throws SQLException{
	//		double total;
	//		total=0;
	//		for(ScopeItem si : getScopeItems())
	//			total+=si.getTotConCost(CostType.CRAFT_GROUP);
	//		return total;
	//	}

	public double getTotConCost(int costGroupId) throws SQLException{
		double total=0;
		for(CostType ct : CostType.getCostTypes(costGroupId))
			total += getCostCont(ct);//cont total cost
		return total;
	}
	
	public double getTotConCost(int costGroupId, Funder type) throws SQLException{
		double total=0;
		for(CostType ct : CostType.getCostTypes(costGroupId))
			total += getCostCont(ct,type);//cont total cost
		return total;
	}
	
	public double getTotalLaborCost(int costGroupId) throws SQLException{
		return getTotSceCost(costGroupId) + getTotConCost(costGroupId);
	}
	
	public double getTotalLaborCost(int costGroupId, Funder type) throws SQLException{
		return getTotSceCost(costGroupId,type) + getTotConCost(costGroupId,type);
	}

	//	public double getTotConNonCraftCost() throws SQLException{
	//		double total;
	//		total=0;
	//		for(CostType ct : CostType.getNonCraftCostTypes())
	//			total+=getCostCont(ct);
	//		return total;
	//	}

	public double getTotalContCost() throws SQLException{
		return getTotConCost(CostType.CRAFT_GROUP)+getTotConCost(CostType.NON_CRAFT_GROUP);
	}

	public double getTotalContCost(Funder type) throws SQLException{
		return getTotConCost(CostType.CRAFT_GROUP, type)+getTotConCost(CostType.NON_CRAFT_GROUP,type);
	}
	
	public double getTotalLaborCost() throws SQLException{
		return getTotalSceCost() + getTotalContCost();
	}
	
	public double getTotalLaborCost(Funder type) throws SQLException{
		return getTotalSceCost(type) + getTotalContCost(type);
	}
	
	public double getTotalSubContCost() throws SQLException{
		double tot =0;
		CostType ct = CostType.getInstance(CostType.SUB_CONT);
		for(ScopeItem si : getScopeItems())
			tot = si.getUnitCost(ct);
		return tot;
	}
	
	public double getTotalSubContCost(Funder type) throws SQLException{
		double tot =0;
		CostType ct = CostType.getInstance(CostType.SUB_CONT);
		for(ScopeItem si : getScopeItems()){
			if(type == SceProjElemCost.Funder.CUSTOMER && si.getFunderId()==LookUp.CUSTOMER )
			tot += si.getUnitCost(ct);
			else if(type == SceProjElemCost.Funder.EXPENSE && si.getFunderId()==LookUp.EXPENSE)
				tot += si.getUnitCost(ct);
			else if(type == SceProjElemCost.Funder.CAPITAL && si.getFunderId()!=LookUp.EXPENSE && si.getFunderId()!=LookUp.CUSTOMER)
				tot += si.getUnitCost(ct);
		}
		return tot;
	}

	private static Collection<LookUpGroup> forecastCats;
	public static Collection<LookUpGroup> getForecastCatories() throws SQLException{
		if(forecastCats==null){
			forecastCats = new Vector<LookUpGroup>();
			forecastCats.add(LookUpGroup.getInstance(LookUpGroup.MAT_FORECAST_CAT));
			forecastCats.add(LookUpGroup.getInstance(LookUpGroup.LABOR_FORECAST_CAT));
			forecastCats.add(LookUpGroup.getInstance(LookUpGroup.CONT_FORECAST_CAT));
			forecastCats.add(LookUpGroup.getInstance(LookUpGroup.OTHER_FORECAST_CAT));
		}
		return forecastCats;
	}

	public double getForecastCost() throws SQLException {
		double tot=0;
		for(LookUpGroup lug:getForecastCatories())
			tot+=getForecastCost(lug);
		return tot;
	}

	public double getForecastCost(int year) {
		// TODO Auto-generated method stub
		return 0;
	}

	public double getForecastCost(LookUpGroup catGroup, int year) {
		// TODO Auto-generated method stub
		return 0;
	}

	public double getForecastCost(LookUpGroup catGroup) throws SQLException {
		double tot = 0;
		for(LookUp lu:catGroup.getLookUps())
			tot += getForecastCost(lu);
		return tot;
	}

	public double getForecastCost(LookUp cat) throws SQLException {
		switch(cat.getId()){
			case LookUp.Wire_Cable_Bus_Bar	:
			case LookUp.Steel_Fabricated_Structural	:
			case LookUp.Circuit_Breakers	: 
			case LookUp.Electric_Wiring_and_Components	:
			case LookUp.Instrument_Transformers	: 
			case LookUp.Reactors_and_Line_Traps	: 
			case LookUp.Capacitors_and_Regulators	: 
			case LookUp.Line_Switches	: 
			case LookUp.Substation_Transformer	: 
			case LookUp.Protection_and_Test	: 
			case LookUp.Metals_Fabricated_Metal_Products	: 
			case LookUp.Poles_Wood_Products	: 
			case LookUp.Pole_Line_Hdwe_Connectors	: 
			case LookUp.Steel_Lattice_Towers	: 
			case LookUp.Steel_Poles	: 
			case LookUp.Other_Material: return getMatForecastCost(cat);


			case LookUp.SCE_Project_Management: return getPMCostSce();
			case LookUp.SCE_Engineering: return getEngCostSce();
			case LookUp.SCE_Craft: return getTotSceCost(CostType.CRAFT_GROUP);


			case LookUp.Contract_Construction: return getTotConCost(CostType.NON_CRAFT_GROUP);
			case LookUp.Contract_Project_Management: return getPMCostCon();
			case LookUp.Contract_Engineering:  return getEngCostCon();

			case LookUp.Unassigned_Costs	: 
			case LookUp.Equipment_Rental_and_Other_Costs	:
			case LookUp.IT_Services_and_Equipment	: 
			case LookUp.SAP_Conversion	: 
			case LookUp.Internal_Order_BA	:
			case LookUp.Order_to_Order	:

		}
		return getMatForecastCost(cat);
	}

	public double getPMCostSce() throws SQLException {
		double total=0;
		for(ScopeItem si : getScopeItems())
			total+=si.getPMCostSce();
		return total;
	}

	public double getEngCostSce() throws SQLException {
		double total=0;
		for(ScopeItem si : getScopeItems())
			total+=si.getEngCostSce();
		return total;
	}

	public double getPMCostCon() throws SQLException {
		double total=0;
		for(ScopeItem si : getScopeItems())
			total+=si.getPMCostCon();
		return total;
	}

	public double getEngCostCon() throws SQLException {
		double total=0;
		for(ScopeItem si : getScopeItems())
			total+=si.getEngCostCon();
		return total;
	}

	public double getForecastCost(LookUp cat, int year) throws SQLException {
		switch(cat.getId()){
			case LookUp.Wire_Cable_Bus_Bar	:
			case LookUp.Steel_Fabricated_Structural	:
			case LookUp.Circuit_Breakers	: 
			case LookUp.Electric_Wiring_and_Components	:
			case LookUp.Instrument_Transformers	: 
			case LookUp.Reactors_and_Line_Traps	: 
			case LookUp.Capacitors_and_Regulators	: 
			case LookUp.Line_Switches	: 
			case LookUp.Substation_Transformer	: 
			case LookUp.Protection_and_Test	: 
			case LookUp.Metals_Fabricated_Metal_Products	: 
			case LookUp.Poles_Wood_Products	: 
			case LookUp.Pole_Line_Hdwe_Connectors	: 
			case LookUp.Steel_Lattice_Towers	: 
			case LookUp.Steel_Poles	: 
			case LookUp.Other_Material	: return getMatForecastCost(cat,year);


			case LookUp.SCE_Project_Management	:
			case LookUp.SCE_Engineering	: 
			case LookUp.SCE_Craft	:


			case LookUp.Contract_Construction	: 
			case LookUp.Contract_Project_Management	: 
			case LookUp.Contract_Engineering	:

			case LookUp.Unassigned_Costs	: 
			case LookUp.Equipment_Rental_and_Other_Costs	:
			case LookUp.IT_Services_and_Equipment	: 
			case LookUp.SAP_Conversion	: 
			case LookUp.Internal_Order_BA	:
			case LookUp.Order_to_Order	:

		}
		return getMatForecastCost(cat,year);
	}
	public double getMatForecastCost(LookUp cat) throws SQLException {
		double tot=0;
		for(ScopeItem si:getScopeItems()){
			if(si.getScopeType().getPartType()!=null && si.getScopeType().getPartType().getForecastCat()==cat)
				tot += si.getCost(CostType.getInstance(CostType.MATERIAL));
		}
		return tot;
	}
	public double getMatForecastCost(LookUp cat, int year) throws SQLException {
		double tot=0;
		for(ScopeItem si:getScopeItems()){
			if(si.getScopeType().getPartType()!=null && si.getScopeType().getPartType().getForecastCat()==cat)
				tot += si.getCost(CostType.getInstance(CostType.MATERIAL),year);
		}
		return tot;
	}
	public PowerPlant getPowerPlant() throws SQLException {
		PowerPlant pp = new PowerPlant();
		int action=0;
		for(ScopeItem si : getScopeItems()){
			if(si.getFunderId()==LookUp.EXPENSE)
				action=LookUp.EXPENSE;
			else action=si.getActionId();

			CprPrime prime = si.getCprPrime();
			CprSub sub = si.getCprSub();
			if(action!=LookUp.TEMP && action!=LookUp.RELOC){
				PowerPlantGroup ppg = pp.getGroup(action,CostType.MATERIAL_GROUP,prime,sub);
				ppg.addQty(si.getPowerPlantCount(CostType.MATERIAL_GROUP));
				ppg.addAmount(si.getPowerPlantAmount(CostType.MATERIAL_GROUP));
				//ppg.addHrs(si.getPowerPlantHrs(CostType.MATERIAL_GROUP));
				
				ppg = pp.getGroup(action,PowerPlantGroup.LABOR,prime,sub);
				//ppg.addQty(si.getPowerPlantCount(PowerPlantGroup.LABOR));
				ppg.addAmount(si.getPowerPlantAmount(PowerPlantGroup.LABOR));
				ppg.addHrs(si.getPowerPlantHrs(PowerPlantGroup.LABOR));
				EspLogger.message(this, pp.getLaborTitle()==PowerPlant.LABOR_TITLE.LABOR);
				EspLogger.message(this, si.getTotConCost());
				EspLogger.message(this, si.getSubTotalCost());
				
				if(pp.getLaborTitle()==PowerPlant.LABOR_TITLE.LABOR && (si.getTotConCost()+si.getSubTotalCost())>0 ){
					EspLogger.message(this, "Labor:"+PowerPlant.LABOR_TITLE.CONTRACTOR);
					pp.setLaborTitle(PowerPlant.LABOR_TITLE.CONTRACTOR);}
			}
		}
		return pp;
	}
	
	public Collection<CostSheetOH> getCostSheetOHs() throws SQLException{
				return CostSheetOH.getCollection(new String[] {"SCE_ELEM_ID", "DELETED_TS" },getSceElemId(), null);
		}
	
	public double getGrossDirectExpenditures() throws SQLException{
		return  
		getCost(CostType.getInstance(CostType.MATERIAL))
		+getTotalLaborCost()
		+getCost(CostType.getInstance(CostType.SUB_CONT))
		+getLoaderCost(LookUp.getInstance(LookUp.PROCUREMENT_MAT_IMM))
		+getLoaderCost(LookUp.getInstance(LookUp.WAREHOUSE_MAT_IMM))
		+getLoaderCost(LookUp.getInstance(LookUp.SCE_LABOR_OH))
		+getLoaderCost(LookUp.getInstance(LookUp.NON_LABOR_OH))
		+getLoaderCost(LookUp.getInstance(LookUp.SUPPLY_OH))
		+getLoaderCost(LookUp.getInstance(LookUp.TOOL_OH))
		+getLoaderCost(LookUp.getInstance(LookUp.VEHICLE_IMM))
		+getLoaderCost(LookUp.getInstance(LookUp.B_MATERIALS_OH))
		+getLoaderCost(LookUp.getInstance(LookUp.PAID_ABSENCE))
		+getLoaderCost(LookUp.getInstance(LookUp.MAT_SALES_TAX))
		+getLoaderCost(LookUp.getInstance(LookUp.DIST_PLAN_OH))
		+getLoaderCost(LookUp.getInstance(LookUp.PREFAB_OH))
		+getLoaderCost(LookUp.getInstance(LookUp.BPI_OH))
		+getLoaderCost(LookUp.getInstance(LookUp.TELECOM))
		+getLoaderCost(LookUp.getInstance(LookUp.IT_DIV_OH));

	}
	
	public double getGrossDirectExpenditures(Funder type) throws SQLException{
		return  
		getCost(CostType.getInstance(CostType.MATERIAL),type)
		+getTotalLaborCost(type)
		+getCost(CostType.getInstance(CostType.SUB_CONT),type)
		+getLoaderCost(LookUp.getInstance(LookUp.PROCUREMENT_MAT_IMM),type)
		+getLoaderCost(LookUp.getInstance(LookUp.WAREHOUSE_MAT_IMM),type)
		+getLoaderCost(LookUp.getInstance(LookUp.SCE_LABOR_OH),type)
		+getLoaderCost(LookUp.getInstance(LookUp.NON_LABOR_OH),type)
		+getLoaderCost(LookUp.getInstance(LookUp.SUPPLY_OH),type)
		+getLoaderCost(LookUp.getInstance(LookUp.TOOL_OH),type)
		+getLoaderCost(LookUp.getInstance(LookUp.VEHICLE_IMM),type)
		+getLoaderCost(LookUp.getInstance(LookUp.B_MATERIALS_OH),type)
		+getLoaderCost(LookUp.getInstance(LookUp.PAID_ABSENCE),type)
		+getLoaderCost(LookUp.getInstance(LookUp.MAT_SALES_TAX),type)
		+getLoaderCost(LookUp.getInstance(LookUp.DIST_PLAN_OH),type)
		+getLoaderCost(LookUp.getInstance(LookUp.PREFAB_OH),type)
		+getLoaderCost(LookUp.getInstance(LookUp.BPI_OH),type)
		+getLoaderCost(LookUp.getInstance(LookUp.TELECOM),type)
		+getLoaderCost(LookUp.getInstance(LookUp.IT_DIV_OH),type);

	}
	
	
	public double getFullyLoadedCost() throws SQLException{
		return
		getGrossDirectExpenditures()
		+getLoaderCost(LookUp.getInstance(LookUp.PENSIONS_BENEFITS))
		+getLoaderCost(LookUp.getInstance(LookUp.CONTIGENCY))
		+getLoaderCost(LookUp.getInstance(LookUp.ADMIN_GENERAL))
		+getLoaderCost(LookUp.getInstance(LookUp.ENGINEERING_PROCURE));
	}
	
	public double getFullyLoadedCost(Funder type) throws SQLException{
		return
		getGrossDirectExpenditures(type)
		+getLoaderCost(LookUp.getInstance(LookUp.PENSIONS_BENEFITS),type)
		+getLoaderCost(LookUp.getInstance(LookUp.CONTIGENCY),type)
		+getLoaderCost(LookUp.getInstance(LookUp.ADMIN_GENERAL),type)
		+getLoaderCost(LookUp.getInstance(LookUp.ENGINEERING_PROCURE),type);
	}

	public double getPercentExpense(CostType ct,Funder type) throws SQLException {
		SceProjElemLabor spel = getSceProjElemLabor(ct);
		if(spel!=null){
		if(type == SceProjElemCost.Funder.EXPENSE)
			return (spel.getPercentExpense());
		else if(type == SceProjElemCost.Funder.CAPITAL)
			return (1-spel.getPercentExpense());
		}
		return 0;
	}
	
	public void setPercentExpense(CostType ct, double percent,Funder type) throws SQLException{
		if(type == SceProjElemCost.Funder.EXPENSE)
		getSceProjElemLabor4Edit(ct).setPercentExpense(percent);
		else if(type == SceProjElemCost.Funder.CAPITAL)
		getSceProjElemLabor4Edit(ct).setPercentExpense(1-percent);
	}

	@Override
	public Collection<SceElem> getSceElems() throws SQLException {
		TreeSet<SceElem> elems = new TreeSet<SceElem>();
		elems.add(getSceElem());
		return elems;
	}
	
}
