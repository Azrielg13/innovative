package com.sce.esp.object.model;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.io.Serializable;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.TreeSet;
import java.util.Vector;

import javax.persistence.Entity;
import javax.persistence.NamedNativeQueries;
import javax.persistence.NamedNativeQuery;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;
import javax.swing.JFrame;
import javax.swing.JOptionPane;

import com.sce.esp.log.EspLogger;
import com.sce.esp.object.dao.UserDAO;
import com.sce.esp.security.UserRole;
import com.sce.esp.util.db.PDBConnection;
@Entity
@Table(schema="MDI",name="MDI000_USER")
@NamedQueries({
	@NamedQuery(name = "findByID", query="SELECT o FROM User o WHERE o.USERNAME_ID=?1"),//AUTO-GENERATED
	@NamedQuery(name = "findAll", query="SELECT o FROM User o"),//AUTO-GENERATED
	@NamedQuery(name = "findAllActive", query="SELECT o FROM User o WHERE o.DELETED_TS IS NULL"),//AUTO-GENERATED
	@NamedQuery(name = "findByOrg", query="SELECT o FROM User o WHERE o.ORG_ID=?1 AND o.DELETED_TS IS NULL"),//AUTO-GENERATED
})
@NamedNativeQueries({
	@NamedNativeQuery(name = "refresh", query="SELECT o.* FROM MDI000_USER o WHERE o.USERNAME_ID=?"),//AUTO-GENERATED
})
public class User extends UserDAO implements Serializable{

	private static final long serialVersionUID = 3199206209927598861L;

	/** The user. */
	protected static User user;

	private UserRole userRole;

	private int sessionOrgId=0;

	private String lotusPassword;

	private String lotusUserName;

	private String lotusMailServer;
	
	public static User getInstance(Integer usernameId)throws java.sql.SQLException{
		if(usernameId==null)
			return null;
		return getInstance(usernameId, true);
	}
	/**
	 * Return the currently signed in username.
	 * 
	 * @return user
	 */
	public static User getActiveUser(){
		return user;
	}

	/**
	 * Set the username.
	 * 
	 * @param id the id
	 * @param username the username
	 * 
	 * @throws SQLException the SQL exception
	 */
	public static void setActiveUser(String username)throws SQLException{
		if(user != null && user.getUsername().equals(username)) return;
		user = getUserByName(username);
	}

	/**
	 * The Constructor.
	 */   
	public User() {
		super(0);
	}

	/**
	 * The Constructor.
	 * 
	 * @param usernameId the username id
	 */
	public User(int usernameId){
		super(usernameId);
	}

	public User(User user) {
		super(user);
	}
	
	/**
	 * Returns an <code>MDIRole</code> object containing
	 * a list of roles granted to the authenticated user,
	 * (e.g., guest, standard, and super user priviledges).
	 * 
	 * @return - The users granted roles.
	 * 
	 * @throws SQLException the SQL exception
	 */
	public UserRole getUserRole() throws SQLException{
		if(userRole == null)
			refreshRoles();
		return userRole;
	}

	public int getOrgId(){
		if(sessionOrgId != 0)
			return sessionOrgId;
		return super.getOrgId();
	}

	public void setSessionUserRole(UserRole userRole){
		this.userRole = userRole;
	}

	public void setSessionOrgId(int orgId){
		sessionOrgId = orgId;
	}

	/**
	 * Obtain roles granted to the user from the Oracle database
	 * and store them in a MDIRole object.
	 * 
	 * @throws SQLException the SQL exception
	 */
	public void refreshRoles() throws SQLException {		
		userRole = new UserRole();
		PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement("SELECT GRANTED_ROLE FROM user_role_privs");
		ResultSet rs = ps.executeQuery();
		while(rs.next())
			userRole.setProperty(rs.getString("GRANTED_ROLE"),"granted");
		rs.close();
		ps.close();
	}

	/**
	 * Display the proper user name.
	 * 
	 * @return firstName & lastName
	 */
	public String toString(){
		if(getUsernameId()==0)
			return "";
		return getFirstName()+" "+getLastName();
	}

	public static User getUserByName(String username) throws SQLException{
		Collection<User> uc = User.getCollection(new String[]{"USERNAME"}, username);
		if(uc!=null && uc.size()>0)
			return uc.iterator().next();
		return null;
	}

	public File getSignatureFile() throws Exception {
		for(UserFile file : getUserFiles()){
			if(file.getFileCat()!=null && file.getFileCatId() == FileCat.SIGNATURE){
				return file.getBLOBFile();
			}
		}		
		return null;
	}

	/**
	 * FTT take responsibility for creating this crafty method.
	 * @param orgId
	 * @return
	 * @throws SQLException
	 */
	public static Collection<? extends User> getAllActiveByOrg(int orgId)throws SQLException{
		return User.getCollection("SELECT o FROM User o WHERE o.ORG_ID=?1 AND o.DISABLED IS NULL AND o.DISABLED = 0", orgId);
	}

	/**
	 * Check if Sys is assigned to User.
	 * 
	 * @param sys the sys
	 * 
	 * @return - boolean, true if Sys belongs to User, else false
	 * 
	 * @throws SQLException the SQL exception
	 */
	public boolean isUsersSystem(Sys sys) throws SQLException{   	
		if(sys==null)   		
			return false;
		for(UserSys us: getUserSyss())   		
			if(us.getPlanyear()==sys.getPlanyear() && us.getSysId() == sys.getSysId())    			
				return true;    	
		return false;
	}
	/**
	 * Gets the planyear.
	 * 
	 * @return the planyear
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getPlanYearUserBased() throws SQLException {
		return getUserSelect().getPlanyear();
	}

	/**
	 * Get the amount of viewable years
	 * for the current planning year.
	 * 
	 * @param planyear the planyear
	 * @param simId the sim id
	 * 
	 * @return planFor
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getPlanFor(int planyear, int simId)throws SQLException{
		int pf = getUserSelect().getPlanFor();
		if(pf == 0){
			Simulation sim = Simulation.getInstance(planyear,simId);
			if(sim != null)
				pf = sim.getPlanFor();
		}
		if(pf == 0)
			pf = Department.getInstance(planyear).getPlanFor();
		return pf;
	}

	/**
	 * Set's the amount of viewable years
	 * for the current planning year.
	 * 
	 * @param years - the amount of years
	 * 
	 * @throws SQLException the SQL exception
	 */
	public void setPlanFor(int years) throws SQLException{
		getUserSelect().setPlanFor(years);
	}

	/**
	 * Get the users simulation id.
	 * 
	 * @return simId
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getSimId(){
		try {
			return getUserSelect().getSimId();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return 0;
	}

	/**
	 * Sets the user syss.
	 * 
	 * @param planyear the planyear
	 * @param userSys the user sys
	 * 
	 * @throws SQLException the SQL exception
	 */
	public void setUserSyss(int planyear, Vector<Integer> userSys) throws SQLException {
		for(UserSys us:getUserSyss())
			if(!userSys.contains(us.getSysId())) {
				EspLogger.warning(this, "deleting "+us.getSys());
				us.delete();
			}
		for(int sysId : userSys){
			UserSys us = UserSys.getInstance(planyear, getUsernameId(), sysId);
			if(us==null){
				us = new UserSys(planyear,getUsernameId(),sysId);
				us.insert();
			}
		}
	}

	/**
	 * Returns the departments active plan year.
	 * 
	 * @see com.sce.esp.object.model.PlanableObject#getPlanyear()
	 */
	public int getPlanyear(){
		return Department.getActivePlanYear();
	}

	/**
	 * 
	 * @return a <code>SubFilter</code> object.
	 */
	public SubFilter getSubFilter() throws SQLException{
		return getUserSelect().getSubFilter();
	}

	public UserSelect getUserSelect() throws SQLException{
		return UserSelect.getInstance(getUsernameId());
	}

	/**
	 * User method for determining if special views should be enabled for
	 * SPI folk.
	 * @return true if user's assigned <code>Org</code> is TIG or SPI.
	 */
	public boolean isSPIUser(){
		try {
			return ( getOrg().equals(Org.getInstance(Org.TIG)) || getOrg().equals(Org.getInstance(Org.SPI)));
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return false;
	}
	public static TreeSet<User> getEnabledUsers(){
		TreeSet<User> enabledUsers = new TreeSet<User>();
		try {
			for(User user : User.getAllActive()){
				if(!user.isDisabled()){
					enabledUsers.add(user);
				}
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return enabledUsers;
	}


	public String getLotusUserName(){
		if(lotusUserName == null)
			lotusUserName = getUsername();
		return lotusUserName;
	}

	public void setLotusUserName(String lotusUserName){
		this.lotusUserName = lotusUserName;
	}

	public String getLotusPassword() {
		return lotusPassword;
	}

	public void setLotusPassword(String lotusPassword){
		this.lotusPassword = lotusPassword;
	}

	public String getLotusMailServer(){
		lotusMailServer="C:\\Documents and Settings\\"+System.getProperty("user.name")
		+"\\Local Settings\\Application Data\\Lotus\\Notes\\Data\\notes.ini";
		File file = new File(lotusMailServer);	
		try{
			if(file.exists()){		
				FileInputStream fstream = new FileInputStream(lotusMailServer);
				DataInputStream in = new DataInputStream(fstream);
				BufferedReader br = new BufferedReader(new InputStreamReader(in));
				while(!lotusMailServer.contains("MailServer"))			    	
					lotusMailServer=br.readLine(); 
				lotusMailServer = lotusMailServer.substring(14,25);
				in.close();
			}
			else	lotusMailServer=""; 		  				
		}
		catch (Exception e){	//			e.printStackTrace();
			System.out.println("couldn't find mailServer it.");
			JOptionPane.showMessageDialog(new JFrame(), "This feature supports Lotus Notes 8.5 or higher.","Error",0);	
		}		
		return lotusMailServer;
	}
	
	public Collection<UserSys> getUserSyss()throws java.sql.SQLException{
		if(isNewInstance())
			return super.getUserSyss();
		return UserSys.getCollection(new String[]{"PLANYEAR", "USERNAME_ID"}, getPlanYearUserBased(), getUsernameId());
	}
}
