/**
 *           | Master Data Interface Version 2.0 |
 *
 * Copyright (c) 2006, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team.
 * 	                   All rights reserved.
 *
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package com.sce.esp.object.model;

import java.awt.Image;
import java.awt.Toolkit;
import java.awt.image.BufferedImage;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.Serializable;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.rmi.RemoteException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.Vector;
import java.util.zip.GZIPInputStream;

import javax.imageio.ImageIO;
import javax.persistence.Entity;
import javax.persistence.NamedNativeQueries;
import javax.persistence.NamedNativeQuery;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;

import org.apache.commons.math3.distribution.NormalDistribution;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.JDOMException;
import org.jdom.input.SAXBuilder;

import com.sce.esp.log.EspLogger;
import com.sce.esp.object.dao.WeatherstationDAO;
import com.sce.esp.object.jpa.EntityManagerHelper;
import com.sce.esp.psp.SystemPSP;
import com.sce.esp.util.Calculate;
import com.sce.esp.util.ESPDate;
import com.sce.esp.util.ESPProperties;
import com.sce.esp.util.ESPUserSysInfo;
import com.sce.esp.util.db.PDBConnection;
import com.sce.javadna.JavaDNA;
@Entity
@Table(schema="MDI",name="MDI580_WEATHERSTATION")
@NamedQueries({
	@NamedQuery(name = "findByID", query="SELECT o FROM Weatherstation o WHERE o.PLANYEAR=?1 AND o.STATION_ID=?2"),//AUTO-GENERATED
	@NamedQuery(name = "findAll", query="SELECT o FROM Weatherstation o"),//AUTO-GENERATED
	@NamedQuery(name = "findAllActive", query="SELECT o FROM Weatherstation o WHERE o.DELETED_TS IS NULL"),//AUTO-GENERATED
	@NamedQuery(name = "findByDepartment", query="SELECT o FROM Weatherstation o WHERE o.PLANYEAR=?1 AND o.DELETED_TS IS NULL"),//AUTO-GENERATED
})
@NamedNativeQueries({
	@NamedNativeQuery(name = "refresh", query="SELECT o.* FROM MDI580_WEATHERSTATION o WHERE o.PLANYEAR=? AND o.STATION_ID=?"),//AUTO-GENERATED
})
public class Weatherstation extends WeatherstationDAO implements GISObject, Serializable{
	private static final long serialVersionUID = 5120956171573894735L;
	
	public static final SimpleDateFormat FILE_DATE = new SimpleDateFormat("MM.dd.yyyy-kk.mm");
	
	public static final String NOAA_FTP_URL = "ftp://ftp.ncdc.noaa.gov/pub/data/gsod/";	
	public static final String NOAA_FTP_WS_MODESTOCITY = "/724926-23258-";
	public static final String NOAA_FTP_WS_BLYTHE = "/747188-23158-";
	public static final String NOAA_FTP_WS_LOS_ALAMITOS = "/722975-53141-";
	public static final String NOAA_FTP_WS_VANDERBURG = "/723930-93214-";
	public static final String NOAA_FTP_WS_MARCH_AFB = "/722860-99999-";
	public static final String NOAA_FTP_WS_SANTA_BARABARA = "/723925-23190-";
	public static final String NOAA_FTP_WS_Avalon_Catalina = "/722920-23191-";
	public static final String NOAA_FTP_EXTENSION = ".op.gz";
	
	public static final String FILE_PATH_CIMI = "C:\\TEMP\\PSP\\CIMI\\CIMI_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt";
	public static final String FILE_PATH_WN = "C:\\TEMP\\PSP\\WN\\WN_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt";
	public static final String FILE_PATH_NOAA = "C:\\TEMP\\PSP\\NOAA\\NOAA_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt";
	public static final String FILE_PATH_FTP = "C:\\TEMP\\PSP\\FTP\\NOAA_FTP_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt";
	public static final String FILE_PATH_eDNA = "C:\\TEMP\\PSP\\eDNA\\eDNA_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt";
	
	public static final boolean OVERWRITE = true;


	//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	/**Number of forecast days*/
	public static int DAYS = 5;
	/**Forecast Bean Object collection*/
	private ForecastWeather[] fDays = new ForecastWeather[DAYS];	/**Specifies if forecast has been read for this ws*/
	private boolean wsForecastRead=false;	/**Stores weather forecast readings*/
	private Map<Integer,WeatherCacheEntry> weatherCache = new HashMap<Integer,WeatherCacheEntry>();
	private boolean isWdotComRead=false;
	private ForecastWeather[] wComDays = new ForecastWeather[DAYS];

	private boolean prevInstanceRead=false;
	protected Weatherstation prevInstance;
	private Vector<SubWeather> subWeathers;
	
	private static final long FORECAST_TTL = 1000 * 60 * 60 * 4;//Four hours
	
	public Weatherstation(){
	}
	public Weatherstation(int planyear, int stationId){
		super(planyear,stationId);
	}

	/**
	 * The Constructor.
	 *
	 * @param planyear the planyear
	 */
	public Weatherstation(int planyear) {
		super(planyear,0);
	}

	public Weatherstation(Weatherstation weatherstation) {
		super(weatherstation);
	}

	/**
	 * Gets the ten year avg.
	 *
	 * @param year the year
	 *
	 * @return the ten year avg
	 *
	 * @throws SQLException the SQL exception
	 */
	public double getTenYearAvg(int year)throws SQLException{
		double tenYrAvg=0;
		for(int i=1; i<11; i++)
			tenYrAvg+=getPeakEff(year-i);
		return tenYrAvg/10;
	}
	
	public double getTenYearAvgAvg(int year)throws SQLException{
		double tenYrAvg=0;
		for(int i=1; i<11; i++)
			tenYrAvg+=getPeakTAvg(year-i);
		return tenYrAvg/10;
	}
	
	public double getTenYearAvgAvg()throws SQLException{
		return getTenYearAvgAvg(getPlanyear()-1);
	}

	/**
	 * Gets the ten year avg.
	 *
	 * @return the ten year avg
	 *
	 * @throws SQLException the SQL exception
	 */
	public double getTenYearAvg()throws SQLException{
		return getTenYearAvg(getPlanyear()-1);
	}

	/**
	 * Gets the peak eff.
	 *
	 * @param year the year
	 *
	 * @return the peak eff
	 *
	 * @throws SQLException the SQL exception
	 */
	public double getPeakEff(int year)throws SQLException{
		return TempYear.getInstance(getPlanyear(),getStationId(),year,true).getEffTemp();
	}
	
	public double getPeakEqu(int year)throws SQLException{
		return TempEquYear.getInstance(getPlanyear(),getStationId(),year,true).getEquTemp();
	}
	
	public double getPeakTAvg(int year)throws SQLException{
		return TempAvgYear.getInstance(getPlanyear(),getStationId(),year,true).getAvgTemp();
	}

	/**
	 *
	 * Obtain the forecast for the weather station based on the lat/lon from
	 * the NOAA weather service.
	 *
	 * @return an array containing multiple forecast day object see<code>ForecastBean</code>.
	 *
	 * @throws RemoteException the remote exception
	 */

	public ForecastWeather[] getNoaaForecast() {
		if (weatherCache.containsKey(this.getStationId())){
			WeatherCacheEntry entry = (WeatherCacheEntry) weatherCache.get(this.getStationId());
			long lastUpdated = entry.getLastUpdated().getTimeInMillis();
			long now = new GregorianCalendar().getTimeInMillis();
			long diffMillis = now - lastUpdated;
			if (diffMillis < Weatherstation.FORECAST_TTL) {			//if it's less than 4 hrs then no need to update
				return entry.getForecast();
			}else	wsForecastRead=false;
		}
		if(!wsForecastRead){
			wsForecastRead=true;
			getNoaaForcastXML(Calendar.getInstance());
			WeatherCacheEntry entry = new WeatherCacheEntry(fDays);
			weatherCache.put(getStationId(), entry);
		}
		return fDays;
	}

	/**
	 *
	 *
	 * @param startDate
	 */
	public Vector<ForecastHour> getHourlyForecast(Calendar startDate){
		HttpURLConnection connection=null;
		Vector<ForecastHour> vector = new Vector<ForecastHour>();
		String url = "http://www.weather.gov/forecasts/xml/SOAP_server/ndfdXMLclient.php?";

		Calendar endDate = (Calendar)startDate.clone();
		endDate.add(Calendar.DATE, 5);
		try{
			URL loc = new URL(url +	"lat="+getLatitude()+"&lon="+getLongitude()+"&product=time-series"+"" +
					"&begin="+new java.text.SimpleDateFormat("yyyy-MM-dd").format(startDate.getTime())+"T00:00:00" +
					"&end="+new java.text.SimpleDateFormat("yyyy-MM-dd").format(endDate.getTime())+"T00:00:00"+
					"&temp=temp"+"&wspd=wspd&Submit=Submit");
			connection = (HttpURLConnection)loc.openConnection();
			if(connection.getResponseCode() == HttpURLConnection.HTTP_OK){
				SAXBuilder builder = new SAXBuilder();
				Document doc = builder.build(new InputStreamReader(connection.getInputStream()));
				if (doc != null) {
					Element root = doc.getRootElement();
					Element data = root.getChild("data");
					Element date = null;
					Element temperature = null;
					Element wind = null;
					List<?> dates = data.getChild("time-layout").getChildren("start-valid-time");
					List<?> temps = data.getChild("parameters").getChildren("temperature");
					for (Object t : temps) {
						if ("hourly".equalsIgnoreCase(((Element)t).getAttributeValue("type"))) 
							temperature = (Element)t;
					}
					List<?> temperatures = temperature.getChildren("value");
					List<?> winds = data.getChild("parameters").getChildren("wind-speed");
					for (Object t : winds) {
						if ("sustained".equalsIgnoreCase(((Element)t).getAttributeValue("type"))) 
							wind = (Element)t;
					}
					List<?> windValues = wind.getChildren("value");
					for(int i = 0; i<temperatures.size();i++){
						date = ((Element)dates.get(i));
						temperature = ((Element)temperatures.get(i));
						wind = ((Element)windValues.get(i));
						ForecastHour fh = new ForecastHour(this,ForecastHour.parseString(date.getText()));
						fh.setTemperature(Integer.parseInt(temperature.getText()));
						fh.setWind(wind.getText());
						try{
							fh.setHour(Integer.parseInt(date.getText().substring(11, 13)));
						}catch(Exception e){

						}
						vector.add(fh);
					}
				}
			}
		} catch (Exception e) {
			//e.printStackTrace();
		}finally{
			PDBConnection.disableProxy();
			connection.disconnect();
		}
		return vector;
	}

	/**
	 * Gets the forcast by parsing the XML response.
	 *
	 * @param startDate the start date
	 */
	private void getNoaaForcastXML(Calendar startDate){//pass Calendar.getInstance() -- current date
		HttpURLConnection connection = null;	       
		try {
			PDBConnection.enableProxy();
			connection = (HttpURLConnection)(new URL("http://www.weather.gov/forecasts/xml/SOAP_server/ndfdSOAPclientByDay.php?" +
					"lat="+getLatitude()+"&lon="+getLongitude()+"&format=12+hourly"+"" +
					"&startDate="+new java.text.SimpleDateFormat("yyyy-MM-dd").format(startDate.getTime())+"" +
					"&numDays=7"+"&Submit=Submit").openConnection());
			if(connection.getResponseCode() == HttpURLConnection.HTTP_OK){
				SAXBuilder builder = new SAXBuilder();
				Document doc = builder.build(new InputStreamReader(connection.getInputStream()));
				String ALL = "-3";
				if (doc != null) {
					Element root = doc.getRootElement();
					Element data = root.getChild("data");
					Element layoutAll = null;
					Element tempMax = null;
					Element tempMin = null;

					List<?> timeLayouts = data.getChildren("time-layout");
					List<?> temp = data.getChild("parameters").getChildren("temperature");
					List<?> weather = data.getChild("parameters").getChild("weather").getChildren("weather-conditions");
					List<?> icons = data.getChild("parameters").getChild("conditions-icon").getChildren("icon-link");
					for (Object timeLayout : timeLayouts) {
						if (((Element)timeLayout).getChildText("layout-key").endsWith(ALL)){
							layoutAll = (Element)timeLayout;
						}
					}
					for (Object t : temp) {
						if ("maximum".equalsIgnoreCase(((Element)t).getAttributeValue("type"))) 
							tempMax = (Element)t;
						if ("minimum".equalsIgnoreCase(((Element)t).getAttributeValue("type"))) 
							tempMin = (Element)t;
					}
					List<?> allList = layoutAll.getChildren("start-valid-time");
					List<?> maxs = tempMax.getChildren("value");
					List<?> mins = tempMin.getChildren("value");

					int mult = 0;
					for (int x = 0; x < DAYS; x++) {
						mult = x * 2;
						fDays[x] = new ForecastWeather(this);
						fDays[x].setDayNum(x);
						fDays[x].setDayName(((Element)allList.get(mult)).getAttributeValue("period-name"));
						fDays[x].setNightName(((Element)allList.get(mult + 1)).getAttributeValue("period-name"));
						fDays[x].setMaxT(((Element)maxs.get(x)).getText());
						fDays[x].setMinT(((Element)mins.get(x)).getText());
						fDays[x].setDayWeather(((Element)weather.get(mult)).getAttributeValue("weather-summary"));
						fDays[x].setNightWeather(((Element)weather.get(mult + 1)).getAttributeValue("weather-summary"));

						URL url;
						url = new URL(((Element)icons.get(mult)).getText());
						BufferedImage im = ImageIO.read(url);
						Image img = Toolkit.getDefaultToolkit().createImage(im.getSource());
						fDays[x].setDayImgIcon(img);

						url = new URL(((Element)icons.get(mult + 1)).getText());
						im = ImageIO.read(url);
						img = Toolkit.getDefaultToolkit().createImage(im.getSource());
						fDays[x].setNightImgIcon(img);
						fDays[x].setDayImg(((Element)icons.get(mult)).getText());
						fDays[x].setNightImg(((Element)icons.get(mult + 1)).getText());
						fDays[x].getEffTemp();
					}
				}			
			}else{
				EspLogger.message(this, "Connection attempt failed for "+this);
			}
		} catch (MalformedURLException e) {
			e.printStackTrace();
		}catch (IOException e) {
			e.printStackTrace();
		} catch (JDOMException e) {
			e.printStackTrace();
		}finally{
			PDBConnection.disableProxy();
			connection.disconnect();
		}
	}

	public ForecastWeather[] getWDotComForecast() {
		if(wComDays[0]==null ||!isWdotComRead){
			isWdotComRead=true;
			getWDotComForcastXML(Calendar.getInstance());
		}
		return wComDays;
	}
	
	private void getWDotComForcastXML(Calendar cal){

	}

	/**
	 * Gets the temp range.
	 *
	 * @param cId the c id
	 *
	 * @return the temp range
	 *
	 * @throws SQLException the SQL exception
	 */
	public double getTempRange(int cId)throws SQLException{
		for(CriteriaWs cw : getCriteriaWss()) {
			if(cw.getCriteriaId() == cId)
				return cw.getTempRange();
		}
		Criteria c = Criteria.getInstance(getPlanyear(),cId);
		if(c != null)
			return c.getTempRange();
		return 0;
	}

	/**
	 * Gets the temperature.
	 *
	 * @param date the date
	 *
	 * @return the temperature
	 *
	 * @throws SQLException the SQL exception
	 */
	public Temperature getTemperature(Calendar date)throws SQLException{
		return Temperature.getInstance(getPlanyear(),getStationId(),date);
	}

	/**
	 * Gets the temperatures.
	 *
	 * @param startDate the start date
	 * @param endDate the end date
	 *
	 * @return the temperatures
	 *
	 * @throws SQLException the SQL exception
	 */
	public Temperature[] getTemperatures(Calendar startDate, Calendar endDate)throws SQLException{
		Temperature[] temps = new Temperature[(int)Math.round((endDate.getTimeInMillis()-startDate.getTimeInMillis())/(1000.0*60*60*24))];
		Calendar cal = (Calendar)startDate.clone();
		for(int t=0; t<temps.length; t++){
			temps[t] = getTemperature(cal);
			cal.add(Calendar.DATE,1);
		}
		return temps;
	}
	
	public static void moveLogFile(File file){
		File dir = new File(file.getParent());
		if(!dir.exists())	
			dir.mkdir();
		if (!file.renameTo(new File(dir, file.getName()))){ 			// Move file to new directory
			EspLogger.message(Weatherstation.class, "-- The tmp file cannot be moved to the target dir.");
		}
	}
	
	public static File checkLogFile(String filePath) throws IOException{
		SystemPSP.checkSystem();
		File file = new File(filePath);
		if(!file.exists())	file.createNewFile();
		return file;
	}

	/**
	 * Obtains weather from NOAA, WeatherNet, eDNA or CIMI data sources.
	 * @param date - the historical date
	 * @param overwrite - overwrite existing records
	 * @throws Exception
	 */
	
	public static void getWeatherData() throws Exception{		// Default update will go back 7 days and NOT overwrite
		Weatherstation.getCimiData(null, null, !Weatherstation.OVERWRITE, Weatherstation.getCimiWs(Department.getActivePlanYear()));
		Weatherstation.getWnData(null, null, !Weatherstation.OVERWRITE, Weatherstation.getWnWs(Department.getActivePlanYear()));
		Weatherstation.getNoaaData(null, null, !Weatherstation.OVERWRITE,Weatherstation.getNoaaWs(Department.getActivePlanYear()));
		Weatherstation.getNoaaFtpData(null, null, !Weatherstation.OVERWRITE,Weatherstation.getFtpWs(Department.getActivePlanYear()));
		Weatherstation.getDNARead(null, null, !Weatherstation.OVERWRITE,Weatherstation.getDnaWs(Department.getActivePlanYear()));
	}
	
	public static void getWeatherData(boolean overwrite) throws Exception{ // Default update will go back 7 days and user sets overwrite
		getWeatherData(null, null, overwrite, null);
	}
	
	public static void getWeatherData(Calendar sdate, Calendar edate, boolean overwrite, Collection<Weatherstation> wsList) throws Exception{
		Weatherstation.getCimiData(sdate, edate, overwrite, wsList);
		Weatherstation.getWnData(sdate, edate, overwrite, wsList);
		Weatherstation.getNoaaData(sdate, edate, overwrite, wsList);
		Weatherstation.getNoaaFtpData(sdate, edate, overwrite, wsList);
		Weatherstation.getDNARead(sdate, edate, overwrite, wsList);
	}
	
	public static void main(String[] argu){
		try {
			EntityManagerHelper.init(ESPProperties.getInstance().getGusDbUrl(), "mdi", "edison","suwannn");
			
			Calendar sdate = (Calendar) Calendar.getInstance().clone();
//			sdate.add(Calendar.DATE, -1);
			Calendar edate = (Calendar) Calendar.getInstance().clone();
			edate.add(Calendar.DATE, -2);
			
			updateWeatherData(sdate, edate, false, false, Weatherstation.getAllActive());
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public static void updateWeatherData(){
		try {
			Calendar sdate = (Calendar) Calendar.getInstance().clone();
			sdate.add(Calendar.DATE, -7);
			Calendar edate = (Calendar) Calendar.getInstance().clone();
			updateWeatherData(sdate, edate, true, false, Department.getActiveInstance().getWeatherstations());
		} catch (SQLException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public static void updateWeatherData(Calendar sdate, Calendar edate, boolean useDateRange, boolean overwrite, Collection<Weatherstation> wsList) throws Exception{
		if(!useDateRange){
			edate = (Calendar) sdate.clone();
			edate.add(Calendar.DATE, 1);
		}
		
		Collection<Weatherstation> cimi = new ArrayList<Weatherstation>();
		Collection<Weatherstation> wn = new ArrayList<Weatherstation>();
		Collection<Weatherstation> noaa = new ArrayList<Weatherstation>();
		Collection<Weatherstation> ftp = new ArrayList<Weatherstation>();
		Collection<Weatherstation> dna = new ArrayList<Weatherstation>();
		
		for(Weatherstation ws:wsList){
			if(ws.isCimi())			cimi.add(ws);
			else if(ws.isWn())		wn.add(ws);
			else if(ws.isNoaa())	noaa.add(ws);
			else if(ws.isFTP())		ftp.add(ws);
			else if(ws.isDNA())		dna.add(ws);
		}
		
		EspLogger.message(Weatherstation.class, "Cimi: "+cimi.size());
		EspLogger.message(Weatherstation.class, "WN: "+wn.size());
		EspLogger.message(Weatherstation.class, "Noaa: "+noaa.size());
		EspLogger.message(Weatherstation.class, "FTP: "+ftp.size());
		EspLogger.message(Weatherstation.class, "DNA: "+dna.size());
		
		if(cimi.size()>0)			Weatherstation.getCimiData(sdate, edate, overwrite, cimi);
		if(wn.size()>0)				Weatherstation.getWnData(sdate, edate, overwrite, wn);
		if(noaa.size()>0)			Weatherstation.getNoaaData(sdate, edate, overwrite, noaa);
		if(ftp.size()>0)			Weatherstation.getNoaaFtpData(sdate, edate, overwrite, ftp);
		if(dna.size()>0)			Weatherstation.getDNARead(sdate, edate, overwrite, dna);
	}

	private static String getCimiFtpNumber(String id){
		if(id.length()==3)
			return id;
		if(id.length()==1)
			return "00"+id;
		if(id.length()==2)
			return "0"+id;		
		return id;
	}
	
	/**
	 * 
	 * to get hourly data:
	 * select station_id, hourly_data_date,  amb_tmp_qty from wnt022_rec_60_min order by hourly_data_date desc
	 * 
	 * Connects to the WeatherNet Sybase database, retrieves one day of data
	 * for one weather station.
	 * @param sdate the date
	 * @param edate 
	 * @param sDate  	the date in the format: MM/DD/YYYY
	 * @param ws the ws
	 *
	 * @throws IOException 
	 *
	 * @throws Exception the exception
	 */
	
	public static void getCimiData(Calendar sdate, Calendar edate, boolean overwrite, Collection<Weatherstation> wsList)throws Exception{ 
		PDBConnection.enableProxy();
		
		File file = checkLogFile(FILE_PATH_CIMI);
		FileOutputStream fOutStream1 = new FileOutputStream(file.getPath());
		DataOutputStream out1 = new DataOutputStream(fOutStream1);
		out1.writeBytes(ESPUserSysInfo.getInfo());
		
		new File("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\CIMI\\new_CIMI_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		FileOutputStream fOutStream2 = new FileOutputStream("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\CIMI\\new_CIMI_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		DataOutputStream out2 = new DataOutputStream(fOutStream2);
		out2.writeBytes(ESPUserSysInfo.getInfo());
		
		Double minTemp, maxTemp;
		for(Weatherstation ws:wsList){
			URLConnection connection = (URLConnection)(new URL("ftp://ftpcimis.water.ca.gov/pub/daily/daily"+getCimiFtpNumber(ws.getStationCode())+".csv").openConnection());
			connection.setDoInput(true);
			BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
			String line = ""; 
			
			while ((line = reader.readLine()) != null) {
				String record_date = "", min_temp="", max_temp="";
				StringTokenizer st = new StringTokenizer(line, ",");
				Integer.parseInt(st.nextToken());//0
				record_date = st.nextToken();//1 MM/DD/YYYY
				st.nextToken();		/*2 - julian date	*/			st.nextToken(); 		/* 23 - qc */
				st.nextToken();		/*24 - solar radiation */		st.nextToken();			/*5 - qc*/
				st.nextToken();		/*6 - avg soil temp*/			st.nextToken();			/*7 - qc*/
				max_temp = st.nextToken();	//8 - max air temperature
				max_temp = max_temp.trim();
				max_temp = max_temp.replace('M','0');
				st.nextToken();//9 - qc
				min_temp = st.nextToken();//10 - min air temperature
				min_temp = min_temp.trim();
				min_temp = min_temp.replace('M','0');
				
				if(max_temp.equalsIgnoreCase("--"))			max_temp="0";
				if(min_temp.equalsIgnoreCase("--"))			min_temp="0";
				maxTemp=Double.parseDouble(max_temp);
				minTemp=Double.parseDouble(min_temp);
				
				Calendar recDate = (Calendar)Calculate.getCal4(record_date).clone();
				Temperature t = ws.getTemperature(recDate);	
				
				EspLogger.message(Weatherstation.class,ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+new ESPDate(recDate)+"\tMax/Min\t"+maxTemp+"/"+minTemp+"\t"+t+"\n");
				
				if(t.toString().indexOf("0.0/0.0")!=-1){
					out1.writeBytes(ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+new ESPDate(recDate)+"\tMax/Min\t"+maxTemp+"/"+minTemp+"\t"+t+"\n");
					out2.writeBytes(ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+new ESPDate(recDate)+"\tMax/Min\t"+maxTemp+"/"+minTemp+"\t"+t+"\n");
				}
				
				if((Double.parseDouble(max_temp)>1 && t.getMaxTemp()==0) || overwrite)
					t.setMaxTemp(maxTemp);
				if((Double.parseDouble(min_temp)>1 && t.getMinTemp()==0) || overwrite)
					t.setMinTemp(minTemp);
			}
			connection.getInputStream().close();
		}
		out1.close();
		out2.close();
		
		moveLogFile(file);
		System.out.println("----- moved file");
		EspLogger.debug(null, "Exitting CIMI update ....");
//>>>>>>> .merge-right.r19804
	}
	
	/**
	 * 
	 * to get hourly data:
	 * select station_id, hourly_data_date,  amb_tmp_qty from wnt022_rec_60_min order by hourly_data_date desc
	 * 
	 * Connects to the WeatherNet Sybase database, retrieves one day of data
	 * for one weather station.
	 * @param start_date the date
	 * @param edate TODO
	 * @param sDate  	the date in the format: MM/DD/YYYY
	 * @param ws the ws
	 *
	 * @throws Exception the exception
	 */
	public static void getWnData(Calendar sdate, Calendar edate, boolean overwrite, Collection<Weatherstation> wsList) throws Exception{ // use current date, need amount of days to get historical data
		
		sdate.add(Calendar.DATE, 1);
		edate.add(Calendar.DATE, 1);
		Calendar start_date = (Calendar)sdate.clone();
		
		new File("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\WN\\new_WN_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		FileOutputStream fOutStream2 = new FileOutputStream("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\WN\\new_WN_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		DataOutputStream out2 = new DataOutputStream(fOutStream2);
		out2.writeBytes(ESPUserSysInfo.getInfo());
		
		Calendar mdiDate = null;
		String TABLE="";
		File file = checkLogFile(FILE_PATH_WN);
		FileOutputStream fOutStream1 = new FileOutputStream(file.getPath());
		DataOutputStream out1 = new DataOutputStream(fOutStream1);
		out1.writeBytes(ESPUserSysInfo.getInfo());		//indicate who runs this code
		
		Class.forName("net.sourceforge.jtds.jdbc.Driver");	//Connect to the Sybase database
		Connection weatherNetcon = DriverManager.getConnection("jdbc:jtds:sybase://db111.sce.com:3400/wntpd001","wxnet", "wxnezz");
		SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy");
		Double minTemp, maxTemp;
		
		
//		select data_array_id, station_id, daily_data_date, avg_amb_tmp_qty, max_amb_tmp_qty, max_amb_tmp_time, min_amb_tmp_qty, min_amb_tmp_time, tot_solar_rdtn_qty, max_solar_rdtn_qty, max_solarrdtn_time, avg_slbrprsur_qty, max_slbrprsur_qty, max_slbrprsur_time, min_slbrprsur_qty, min_slbrprsur_time, acc_dly_prcp_qty, ytd_prcp_qty, heat_deg_days_qty, hrs_below_65_qty, cool_deg_days_qty, hrs_above_74_qty, avg_rltv_hum_qty 
//		from wntpd001.dbo.wnt023_rec_daily
//		WHERE station_id='15'
//		ORDER BY daily_data_date ASC

		for(Weatherstation ws:wsList){
			System.out.println("Updating Wn: "+ws);
			start_date = (Calendar)sdate.clone();
				while(!start_date.equals(edate)){
					System.out.println("Starting Wn: "+ws+"\t"+overwrite);
					mdiDate = (Calendar)start_date.clone();
					mdiDate.add(Calendar.DATE, -1);
					String wnDate = sdf.format(start_date.getTime());	//Temp of start_date is of the day before
					Statement stm = weatherNetcon.createStatement();	//Use a statement
					//---------------- Determine which table to use ----------------
					ResultSet rsWeatherNetTest = stm.executeQuery("SELECT count(*) FROM wnt023_rec_daily WHERE station_id='"+
							ws.getStationCode()+"' AND convert(char(20),daily_data_date,101)='"+wnDate+"'");
					if(rsWeatherNetTest.next() && rsWeatherNetTest.getInt(1)>0)		
						TABLE="wnt023_rec_daily";//Check near time recorded
					else
						TABLE="wnt026_his_daily";//else if not found check this table
					rsWeatherNetTest.close();
					//--------- Resultset to retrieve WeatherNet Station Data -------
					ResultSet rsWeatherNet = stm.executeQuery("SELECT station_id, " +
							"daily_data_date AS RcdDate, max_amb_tmp_qty AS MaxTemp,min_amb_tmp_qty AS MinTemp FROM "+TABLE+
							" WHERE station_id='"+ws.getStationCode()+"' AND convert(char(20),daily_data_date,101)='"+
							wnDate+"' ORDER BY RcdDate ASC");
					while(rsWeatherNet.next()){
						minTemp=rsWeatherNet.getDouble("MinTemp");
						maxTemp=rsWeatherNet.getDouble("MaxTemp");
						System.out.println("WN Min: "+minTemp+"\tMax: "+maxTemp);
						Temperature t = ws.getTemperature(mdiDate);		//only insert records if they do not exist or if specified
						if(t.toString().indexOf("0.0/0.0")!=-1){
							System.out.println(ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+ws.getStationName()+"\t"+wnDate+"\t"+new ESPDate(mdiDate)+"\tMax/Min\t"+maxTemp+"/"+minTemp+"\t"+t+"\n");
							out1.writeBytes(ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+wnDate+"\t"+new ESPDate(mdiDate)+"\tMax/Min\t"+maxTemp+"/"+minTemp+"\t"+t+"\n");
							out2.writeBytes(ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+wnDate+"\t"+new ESPDate(mdiDate)+"\tMax/Min\t"+maxTemp+"/"+minTemp+"\t"+t+"\n");
						}
						if((maxTemp>1 && t.getMaxTemp()==0) || overwrite){
							System.out.println("Noaa IN MAX: "+maxTemp);
							t.setMaxTemp(maxTemp);
						}
						if((minTemp>1 && t.getMinTemp()==0) || overwrite){
							System.out.println("Noaa IN MIN: "+minTemp);
							t.setMinTemp(minTemp);
						}
					}
					rsWeatherNet.close();
					stm.close();
					start_date.add(Calendar.DATE, 1);		//Must add a day for WN day offset
				}
		}
		weatherNetcon.close();
		out1.close();
		out2.close();
		EspLogger.message(null, "Exitting WN update ....");
	}

	/**
	 *
	 * Connects to the NOAA web page, parses and inserts records into a Oracle database.
	 * @param start_date calendar object containing the requested date.
	 * @param edate TODO
	 * @param ws the ws
	 *
	 * @throws Exception the exception
	 */
	public static void getNoaaData(Calendar sdate, Calendar edate, boolean overwrite, Collection<Weatherstation> wsList)throws Exception{
		sdate.add(Calendar.DATE, 1);
		edate.add(Calendar.DATE, 1);
		Calendar start_date = (Calendar)sdate.clone();
		
		File file = checkLogFile(FILE_PATH_NOAA);
		FileOutputStream fOutStream1 = new FileOutputStream(file.getPath());
		DataOutputStream out1 = new DataOutputStream(fOutStream1);
		
		new File("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\NOAA\\new_NOAA_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		FileOutputStream fOutStream2 = new FileOutputStream("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\NOAA\\new_NOAA_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		DataOutputStream out2 = new DataOutputStream(fOutStream2);
		
		out1.writeBytes(ESPUserSysInfo.getInfo());		// indicate who is running this code
		out2.writeBytes(ESPUserSysInfo.getInfo());

		Double minTemp, maxTemp;
		PDBConnection.enableProxy();	//Enable the proxy
		URL u = new URL("http://www.nws.noaa.gov/climate/getclimate.php?wfo=lox");
		for(Weatherstation ws:wsList){
			start_date = (Calendar)sdate.clone();
			while(!start_date.equals(edate)){
				Calendar actualDate = (Calendar)start_date.clone();
				actualDate.add(Calendar.DATE,-1);
				String noaaDate=""+start_date.get(Calendar.YEAR)+((start_date.get(Calendar.MONTH)+1<10)?"0":"")+
				(start_date.get(Calendar.MONTH)+1)+((start_date.get(Calendar.DATE)<10)?"0":"")+start_date.get(Calendar.DATE);//This String is formatted to a NOAA specific format:
				HttpURLConnection connection = (HttpURLConnection)(u.openConnection());
				connection.setRequestMethod("POST");
				connection.setDoOutput(true);
				OutputStreamWriter outStream = new OutputStreamWriter(new BufferedOutputStream(connection.getOutputStream()));
				outStream.write("printer_friendly=");
				outStream.write("&product=RTP");
				outStream.write("&station="+ws.getDataLoc());
				outStream.write("&recent=no");
				outStream.write("&date="+noaaDate);
				outStream.write("&prodDesc=REGIONAL+SUMMARY%3A+issued+multiple+times+per+day%0D%0ALocal+high+and+low+" +
						"temperature+and+precipitation+information+from+sites+like+cooperative+weather+observers+and+airports." +
				"++This+product+is+available+for+up+to+1+year.");
				outStream.close();

				if(connection.getResponseCode() == HttpURLConnection.HTTP_OK){
					BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
					String line = reader.readLine();
					while(line != null && !line.startsWith("<pre>"))
						line = reader.readLine();
					while(line != null){
						StringTokenizer st = new StringTokenizer(line,">");
						while(st.hasMoreTokens()){
							String token = st.nextToken();	/*&& token.substring(0,6).trim().equals(ws.getStationCode())/*token.length() > 47 && token.charAt(6) == ':'*/
							if(token.length() > 42){
								String cityID = token.substring(0,5).trim();	
								if(cityID.equals(ws.getStationCode())){
									String high = "M";							
									String low = "M";	
									if(ws.getDataLoc().equals("VEF")){
										high = token.substring(32,36).trim();
										low = token.substring(39,42).trim();
									}
									else if(ws.getDataLoc().equals("PSR")){
										high = token.substring(37,40).trim();
										low = token.substring(42,46).trim();
									}else{
										high = token.substring(38,41).trim();
										low = token.substring(45,48).trim();
									}
									if(high==null || high.length()==0 || high.equals("M") || high.equals("T"))
										high = "0";
									if(low==null || low.length()==0 || low.equals("M") || low.equals("T"))
										low = "0";
									maxTemp = Double.parseDouble(high);
									minTemp = Double.parseDouble(low);

									if(cityID!=null){
										if(cityID.equals(ws.getStationCode())){
											Temperature t = ws.getTemperature(actualDate);
											if(t.toString().indexOf("0.0/0.0")!=-1){
												EspLogger.message(Weatherstation.class, ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+ws.getStationName()+"\t"+FILE_DATE.format(start_date.getTime())+"\t"+FILE_DATE.format(actualDate.getTime())+"\tMax/Min\t"+maxTemp+"/"+minTemp+"\t"+t+"\n");
												out1.writeBytes(ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+noaaDate+"\t"+new ESPDate(start_date)+"\t"+new ESPDate(actualDate)+"Max/Min"+"\t"+maxTemp+"/"+minTemp+"\t"+t+"\n");
											out2.writeBytes(ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+noaaDate+"\t"+new ESPDate(start_date)+"\t"+new ESPDate(actualDate)+"Max/Min"+"\t"+maxTemp+"/"+minTemp+"\t"+t+"\n");
											}
											if((maxTemp>1 && t.getMaxTemp()==0) || overwrite)
												t.setMaxTemp(maxTemp);
											if((minTemp>1 && t.getMinTemp()==0) || overwrite)
												t.setMinTemp(minTemp);
										}
									}
								}
							}
						}
						if(line.endsWith("</pre>"))
							break;
						line = reader.readLine();
					}
				}
				connection.disconnect();
				start_date.add(Calendar.DATE, 1);
			}
		}
		PDBConnection.disableProxy();		//Disable the proxy
		out1.close();
		out2.close();
		EspLogger.message(null, "Exitting Noaa update ....");
	}
	
	/**
	 * NoaaFtp will update all particular selected year
	 * @param start_date
	 * @param edate TODO
	 * @throws SQLException
	 * @throws IOException 
	 */
	public static void getNoaaFtpData(Calendar sdate, Calendar edate, boolean overwrite, Collection<Weatherstation> wsList) throws SQLException, IOException, FileNotFoundException{
		
		int planyear = Calendar.getInstance().get(Calendar.YEAR);
		sdate.add(Calendar.DATE, -1);
		edate.add(Calendar.DATE, -1);
		Calendar start_date = (Calendar)sdate.clone();
		
		File file = checkLogFile(FILE_PATH_FTP);
		FileOutputStream fOutStream1 = new FileOutputStream(file.getPath());
		DataOutputStream out1 = new DataOutputStream(fOutStream1);
		out1.writeBytes(ESPUserSysInfo.getInfo());		// indicate who is running this code
		
		
		new File("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\NOAA_FTP\\new_NOAAFTP_Y"+planyear+"_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		FileOutputStream fOutStream2 = new FileOutputStream("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\NOAA_FTP\\new_NOAAFTP_Y"+planyear+"_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		DataOutputStream out2 = new DataOutputStream(fOutStream2);
		out2.writeBytes(ESPUserSysInfo.getInfo());
		

		PDBConnection.enableProxy();
		BufferedReader br = null;
		URL url = null;
		String dbRecord = null;   
		Double minTemp, maxTemp;
		for(Weatherstation ws:wsList){	//FIXME ADD new column in db to add second number to access the file
			start_date = (Calendar)sdate.clone();
			if(ws.getStationNumber()==724926){
				url = new URL(NOAA_FTP_URL+start_date.get(Calendar.YEAR)+NOAA_FTP_WS_MODESTOCITY+start_date.get(Calendar.YEAR)+NOAA_FTP_EXTENSION);
			}else if(ws.getStationNumber()==747188){//08 avail
				url = new URL(NOAA_FTP_URL+start_date.get(Calendar.YEAR)+NOAA_FTP_WS_BLYTHE+start_date.get(Calendar.YEAR)+NOAA_FTP_EXTENSION);
			}else if(ws.getStationNumber()==722975){
				url = new URL(NOAA_FTP_URL+start_date.get(Calendar.YEAR)+NOAA_FTP_WS_LOS_ALAMITOS+start_date.get(Calendar.YEAR)+NOAA_FTP_EXTENSION);
			}else if(ws.getStationNumber()==723930){
				url = new URL(NOAA_FTP_URL+start_date.get(Calendar.YEAR)+NOAA_FTP_WS_VANDERBURG+start_date.get(Calendar.YEAR)+NOAA_FTP_EXTENSION);
			}else if(ws.getStationNumber()==722860){
				url = new URL(NOAA_FTP_URL+start_date.get(Calendar.YEAR)+NOAA_FTP_WS_MARCH_AFB+start_date.get(Calendar.YEAR)+NOAA_FTP_EXTENSION);
			}else if(ws.getStationNumber()==723925){
				url = new URL(NOAA_FTP_URL+start_date.get(Calendar.YEAR)+NOAA_FTP_WS_SANTA_BARABARA+start_date.get(Calendar.YEAR)+NOAA_FTP_EXTENSION);
			}else if(ws.getStationNumber()==722920){
				url = new URL(NOAA_FTP_URL+start_date.get(Calendar.YEAR)+NOAA_FTP_WS_Avalon_Catalina+start_date.get(Calendar.YEAR)+NOAA_FTP_EXTENSION);
			}else	return;
			
			/*EspLogger.debug(Weatherstation.class,
			 	ftp://ftp.ncdc.noaa.gov/pub/data/gsod/2011/724926-23258-2011.op.gz
				ftp://ftp.ncdc.noaa.gov/pub/data/gsod/2011/747188-23158-2011.op.gz
				ftp://ftp.ncdc.noaa.gov/pub/data/gsod/2011/722975-53141-2011.op.gz
				ftp://ftp.ncdc.noaa.gov/pub/data/gsod/2011/723930-93214-2011.op.gz
				ftp://ftp.ncdc.noaa.gov/pub/data/gsod/2011/722860-23119-2011.op.gz //found it
				ftp://ftp.ncdc.noaa.gov/pub/data/gsod/2011/723925-23190-2011.op.gz
				ftp://ftp.ncdc.noaa.gov/pub/data/gsod/2011/722920-23191-2011.op.gz  KAVX Avalon
			 */
			
			EspLogger.message(Weatherstation.class, url+"");
			br = new BufferedReader(new InputStreamReader(new GZIPInputStream(url.openConnection().getInputStream())));
			if(br!=null){
				br.readLine();
				while ((dbRecord = br.readLine()) != null) {
					StringTokenizer st = new StringTokenizer(dbRecord, " ");
					st.nextToken();//station
					st.nextToken();//wban
					String yearModA = st.nextToken();
					st.nextToken();					st.nextToken();//temp 1, 2
					st.nextToken();					st.nextToken();//dewp 1, 2
					st.nextToken();					st.nextToken();//slp 1, 2
					st.nextToken();					st.nextToken();//stp 1, 2
					st.nextToken();					st.nextToken();//visib 1, 2
					st.nextToken();//wdspd
					st.nextToken();//wdsp 2
					st.nextToken();//mxspd
					st.nextToken();//gust

					String max =  st.nextToken();
					max = max.replace("*", "");
					String min =  st.nextToken();
					min = min.replace("*", "");
					maxTemp = Double.parseDouble(max);
					minTemp = Double.parseDouble(min);
					String cal = yearModA.substring(0, 4)+"-"+yearModA.substring(4, 6)+"-"+yearModA.substring(6, 8);
					
					Calendar actualDate = (Calendar)Calculate.getCal(cal).clone();

					//-------------- update database only the ones that in the date range ------------------
					Calendar actCal = (Calendar) actualDate.clone();
					actCal = Calculate.zeroOutTime(actCal);
					Calendar scal = (Calendar) sdate.clone();			
					scal = Calculate.zeroOutTime(scal);						
					Calendar ecal = (Calendar) edate.clone();			
					ecal = Calculate.zeroOutTime(ecal);

					if(!actCal.before(scal) && !actCal.after(ecal)){
						Temperature t = ws.getTemperature(actualDate);	
						if(t.toString().indexOf("0.0/0.0")!=-1){
							out1.writeBytes(ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+cal+"\t"+new ESPDate(actualDate)+"\t"+"Max/Min"+"\t"+maxTemp+"/"+minTemp+"\t"+t+"\n");
							out2.writeBytes(ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+cal+"\t"+new ESPDate(actualDate)+"\t"+"Max/Min"+"\t"+maxTemp+"/"+minTemp+"\t"+t+"\n");
							EspLogger.message(Weatherstation.class, ws.getStationId()+"\t"+ws.getStationName()+"\t"+new ESPDate(actualDate)+"\t"+max+"\t"+min+"\t"+t.toString());
						}
						if((maxTemp>1 && maxTemp != 9999.9 && t.getMaxTemp()==0) || overwrite)
							t.setMaxTemp(maxTemp);
						if((minTemp>1&& minTemp != 9999.9  && t.getMinTemp()==0) || overwrite)
							t.setMinTemp(minTemp);
					}
					//---------------------------------------------------------------------------
				}
				br.close();
			}
		}
		out1.close();
		out2.close();
		EspLogger.debug(null, "Exitting Noaa FTP update ....");
	}
	
	/**
	 * Obtain min/max temperature from the eDNA system.
	 * This method only needs start date, it doesn't care for end date.
	 * @param start_date -  the desired date.
	 * @param edate TODO
	 * @throws SQLException
	 * @throws IOException 
	 */
	public static void getDNARead(Calendar sdate, Calendar edate, boolean overwrite, Collection<Weatherstation> wsList) throws SQLException, IOException{ 
		File file = checkLogFile(FILE_PATH_eDNA);
		FileOutputStream fOutStream1 = new FileOutputStream(file.getPath());
		DataOutputStream out1 = new DataOutputStream(fOutStream1);
		out1.writeBytes(ESPUserSysInfo.getInfo());		// indicate who is running this code
		
		new File("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\eDNA\\new_eDNA_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		FileOutputStream fOutStream2 = new FileOutputStream("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\eDNA\\new_eDNA_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		DataOutputStream out2 = new DataOutputStream(fOutStream2);
		out2.writeBytes(ESPUserSysInfo.getInfo());
		
		Calendar finishDate = (Calendar)edate.clone();
		for(Weatherstation ws:wsList){
			Calendar startDate = (Calendar)sdate.clone();
			Calendar requestDate = (Calendar)startDate.clone();
			Calendar endDate = (Calendar)startDate.clone();
			endDate.add(Calendar.DATE, 1);
			
			if(ws.getDataLoc()!=null && ws.getDataLoc().equalsIgnoreCase("EMS.SCADA2.20190346")){ 
				while(!requestDate.equals(finishDate)){
					String start=JavaDNA.DATETIME.format(Calculate.zeroOutTime((Calendar)requestDate.clone()).getTime());
					String end=JavaDNA.DATETIME.format(Calculate.zeroOutTime((Calendar)endDate.clone()).getTime());
					long keyMax=0, keyMin=0;
					Double maxTemp=0.0, minTemp=0.0;
					if(JavaDNA.isGoodPointFormat(ws.getDataLoc())){
						keyMax = JavaDNA.initHistMax(ws.getDataLoc(), start, end, "1440");
						if(keyMax != 0)
							maxTemp = Calculate.round(JavaDNA.getNextHistory(keyMax).getValue(), 2);		
						keyMin = JavaDNA.initHistMin(ws.getDataLoc(), start, end, "1440");
						if(keyMin!=0)
							minTemp = Calculate.round(JavaDNA.getNextHistory(keyMin).getValue(), 2);	
						
						if(maxTemp>0 && minTemp>0){
							Temperature t = ws.getTemperature(requestDate);
							if(t.toString().indexOf("0.0/0.0")!=-1){
								EspLogger.debug(Weatherstation.class,ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+start+"\t"+new ESPDate(requestDate)+"\t"+"Max/Min"+"\t"+maxTemp+"/"+minTemp+"\t"+t+"\n");
								out1.writeBytes(ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+start+"\t"+new ESPDate(requestDate)+"\t"+"Max/Min"+"\t"+maxTemp+"/"+minTemp+"\t"+t+"\n");
								out2.writeBytes(ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+start+"\t"+new ESPDate(requestDate)+"\t"+"Max/Min"+"\t"+maxTemp+"/"+minTemp+"\t"+t+"\n");
							}
							if((maxTemp>1 && t.getMaxTemp()==0) || overwrite)
								t.setMaxTemp(maxTemp);
							if((minTemp>1 && t.getMinTemp()==0) || overwrite)
								t.setMinTemp(minTemp);
						}
						
					}
					requestDate.add(Calendar.DATE, 1);
					endDate.add(Calendar.DATE, 1);
				}
			}	
		}
		out1.close();
		out2.close();
		EspLogger.debug(null, "Exitting eDNA update ....");
	}
	
	/**
	 * create log files for each source
	 * This method requires approximately 150 seconds execute time(local), 1500 seconds(shared drive)
	 * @param 
	 * @throws SQLException
	 * @throws IOException 
	 */
	public static void getMissingDate() throws SQLException, IOException{	//XXX need more tuning later on
		new File("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\MissingDates\\missingDateCimi_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		FileOutputStream fOutStream1 = new FileOutputStream("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\MissingDates\\missingDateCimi_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		DataOutputStream out1 = new DataOutputStream(fOutStream1);
		new File("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\MissingDates\\missingDateWn_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		FileOutputStream fOutStream2 = new FileOutputStream("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\MissingDates\\missingDateWn_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		DataOutputStream out2 = new DataOutputStream(fOutStream2);
		new File("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\MissingDates\\missingDateNoaa_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		FileOutputStream fOutStream3 = new FileOutputStream("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\MissingDates\\missingDateNoaa_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		DataOutputStream out3 = new DataOutputStream(fOutStream3);
		new File("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\MissingDates\\missingDateFtp_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		FileOutputStream fOutStream4 = new FileOutputStream("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\MissingDates\\missingDateFtp_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		DataOutputStream out4 = new DataOutputStream(fOutStream4);
		new File("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\MissingDates\\missingDateDna_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		FileOutputStream fOutStream5 = new FileOutputStream("\\\\sce\\workgroup\\TDBU12\\ESP_Shared\\TIG\\PSP Services\\Weather Service\\MissingDates\\missingDateDna_"+FILE_DATE.format(Calendar.getInstance().getTime())+".txt");
		DataOutputStream out5 = new DataOutputStream(fOutStream5);
		
		// indicate who is running this code
		out1.writeBytes(ESPUserSysInfo.getInfo());
		out2.writeBytes(ESPUserSysInfo.getInfo());
		out3.writeBytes(ESPUserSysInfo.getInfo());
		out4.writeBytes(ESPUserSysInfo.getInfo());
		out5.writeBytes(ESPUserSysInfo.getInfo());
				
		Calendar finishDate = Calculate.getCal(2000, Calendar.DECEMBER, 31);
		Calendar startDate = Calculate.getCal();
		
		for(Weatherstation ws:Weatherstation.getCimiWs(Department.getActivePlanYear())){
			Calendar requestDate = (Calendar)startDate.clone();
			while(!requestDate.equals(finishDate)){
				Temperature t = ws.getTemperature(requestDate);
				if(t.toString().indexOf("0.0/0.0")!=-1){
					EspLogger.message(Weatherstation.class, ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+new ESPDate(requestDate)+"\t"+t);
					out1.writeBytes(ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+new ESPDate(requestDate)+"\t"+t+"\n");
				}
				requestDate.add(Calendar.DATE, -1);
			}
		}
		for(Weatherstation ws:Weatherstation.getWnWs(Department.getActivePlanYear())){
			Calendar requestDate = (Calendar)startDate.clone();
			while(!requestDate.equals(finishDate)){
				Temperature t = ws.getTemperature(requestDate);
				if(t.toString().indexOf("0.0/0.0")!=-1){
					EspLogger.message(Weatherstation.class, ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+new ESPDate(requestDate)+"\t"+t);
					out2.writeBytes(ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+new ESPDate(requestDate)+"\t"+t+"\n");
				}
				requestDate.add(Calendar.DATE, -1);
			}
		}
		for(Weatherstation ws:Weatherstation.getNoaaWs(Department.getActivePlanYear())){
			Calendar requestDate = (Calendar)startDate.clone();
			while(!requestDate.equals(finishDate)){
				Temperature t = ws.getTemperature(requestDate);
				if(t.toString().indexOf("0.0/0.0")!=-1){
					EspLogger.message(Weatherstation.class, ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+new ESPDate(requestDate)+"\t"+t);
					out3.writeBytes(ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+new ESPDate(requestDate)+"\t"+t+"\n");
				}
				requestDate.add(Calendar.DATE, -1);
			}
		}
		for(Weatherstation ws:Weatherstation.getFtpWs(Department.getActivePlanYear())){
			Calendar requestDate = (Calendar)startDate.clone();
			while(!requestDate.equals(finishDate)){
				Temperature t = ws.getTemperature(requestDate);
				if(t.toString().indexOf("0.0/0.0")!=-1){
					EspLogger.message(Weatherstation.class, ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+new ESPDate(requestDate)+"\t"+t);
					out4.writeBytes(ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+new ESPDate(requestDate)+"\t"+t+"\n");
				}
				requestDate.add(Calendar.DATE, -1);
			}
		}
		for(Weatherstation ws:Weatherstation.getDnaWs(Department.getActivePlanYear())){
			Calendar requestDate = (Calendar)startDate.clone();
			while(!requestDate.equals(finishDate)){
				Temperature t = ws.getTemperature(requestDate);
				if(t.toString().indexOf("0.0/0.0")!=-1){
					EspLogger.message(Weatherstation.class, ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+new ESPDate(requestDate)+"\t"+t);
					out5.writeBytes(ws.getPlanyear()+"\t"+ws.getStationId()+"\t"+new ESPDate(requestDate)+"\t"+t+"\n");
				}
				requestDate.add(Calendar.DATE, -1);
			}
		}
		out1.close();
		out2.close();
		out3.close();
		out4.close();
		out5.close();
	}

	/**
	 * Gets the ten year avg flag.
	 *
	 * @return the ten year avg flag
	 *
	 * @throws SQLException the SQL exception
	 */
	public int getTenYearAvgFlag() throws SQLException{
		int flagId = Flag.TEN_YR_AVG_FLAG;
		Flag flag = Flag.getInstance(getPlanyear(), flagId);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()) {
			for(int year=getPlanyear()-11; year<getPlanyear()-1; year++) {
				if(getTenYearAvgPeakEffFlag(year) > 0)
					return flagId;
			}
		}
		return 0;
	}

	/**
	 * Gets the ten year avg peak eff flag.
	 *
	 * @param year the year
	 *
	 * @return the ten year avg peak eff flag
	 *
	 * @throws SQLException the SQL exception
	 */
	public int getTenYearAvgPeakEffFlag(int year)throws SQLException{
		int flagId = Flag.TEN_YR_AVG_FLAG;
		Flag flag = Flag.getInstance(getPlanyear(), flagId);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()) {
			if(Math.abs(getPeakEff(year)/getTenYearAvg()-1) > flag.getValue())
				return flagId;
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * distance to a weatherstation is outside of
	 * the set limits in the database.  It will return
	 * 0 if all distances are within limits.
	 *
	 * @param co the co
	 *
	 * @return -
	 *
	 * @throws SQLException the SQL exception
	 */
	public int getWSDistanceFlag(CoreObject co) throws Exception{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.WS_DISTANCE_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()) {
			if(Calculate.distance(co.getLatitude(), co.getLongitude(), getLatitude(), getLongitude()) > flag.getValue())
				return flag.getFlagId();
		}
		return 0;
	}


	/**
	 * This function returns the flag id if the
	 * weatherstation is missing more than some percentage of
	 * mins and maxs temperatures set in the database
	 * between the months of June and September.  It will return
	 * 0 if all records are within limits.
	 *
	 * @param co the co
	 *
	 * @return -
	 *
	 * @throws SQLException the SQL exception
	 */
	public int getWSMissingPeaksFlag(int year) throws SQLException{

		Flag flag = Flag.getInstance(getPlanyear(), Flag.WS_MISSING_PEAKS_FLAG);

		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()) {

			int f = TempYear.getInstance(getPlanyear(), getStationId(), year).getWSMissingPeaksFlag();

			return f;

		}
		return 0;
	}

	/**
	 * Returns a string representation of the object.
	 *
	 * @return a string representation of the object.
	 */
	public String toString(){
		return getStationName();
	}

	/**
	 * Gets the all.
	 *
	 * @param planyear the planyear
	 *
	 * @return the all
	 *
	 * @throws SQLException the SQL exception
	 */
	public static Collection<Weatherstation> getAll(int planyear) throws SQLException {
		return Department.getInstance(planyear, true).getWeatherstations();
	}

	/* Gets the subs.
	 *
	 * @return the subs
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<Sub> getSubs()throws SQLException{
		TreeSet<Sub> wss = new TreeSet<Sub>();
		for(SubWeather sw:getSubWeathers()){
			wss.add(sw.getBbank());
			wss.add(sw.getBbank().getYear(getPlanyear(),getPlanyear()-1).getAbank());
		}
		return wss;
	}

	protected class WeatherCacheEntry implements Serializable {
		static final long serialVersionUID = 5675883260124394705L;
		private Calendar lastUpdated;
		private ForecastWeather[] days;
		/**
		 * @param days
		 */
		public WeatherCacheEntry(ForecastWeather[] days) {
			Calendar now = new GregorianCalendar();
			this.lastUpdated = now;
			this.days=days;
		}
		public ForecastWeather[] getForecast() {
			return days;
		}
		public Calendar getLastUpdated() {
			return lastUpdated;
		}
	}

	/**
	 * @return the prior plan year <code>Weatherstation</code> object.
	 * @throws SQLException
	 */
	public Weatherstation getPrevInstance() throws SQLException {
		if(!prevInstanceRead){
			prevInstance = getInstance(getPlanyear()-1,getStationId());
			prevInstanceRead = true;
		}
		return (Weatherstation)prevInstance;
	}

	/**
	 * Checks for sub weathers been read.
	 *
	 * @return true, if has sub weathers been read
	 */
	public boolean hasSubWeathersBeenRead(){
		return subWeathers!=null;
	}

	/**
	 * Gets the sub weathers.
	 *
	 * @return subWeathers
	 *
	 * @throws SQLException the SQL exception
	 */
	public Collection<SubWeather> getSubWeathers()throws SQLException{
		return SubWeather.getCollection(new String[]{"PLANYEAR","STATION_ID"}, getPlanyear(),getStationId());
	}
	
	public boolean isCimi(){
		return getDataLoc()!=null && getDataLoc().equals("CIMI");
	}
	
	public boolean isWn(){
		return getDataLoc()!=null && getDataLoc().equals("WN");
	}
	
	public boolean isNoaa(){
		return getDataLoc()!=null && (getDataLoc().equals("SGX") || getDataLoc().equals("HNX") || getDataLoc().equals("LOX") || getDataLoc().equals("VEF"));
	}
	
	public boolean isFTP(){
		return getDataLoc()!=null && getDataLoc().equals("FTP");
	}
	
	public boolean isDNA(){
		return getSource()!=null && getSource().equals("DNA");
	}
	
	public static TreeSet<Weatherstation> getCimiWs() throws SQLException{
		TreeSet<Weatherstation> cimiWs= new TreeSet<Weatherstation>();
		for(Weatherstation ws:Weatherstation.getAllActive())
			if(ws.getDataLoc()!=null && ws.getDataLoc().equals("CIMI"))
				cimiWs.add(ws);
		return cimiWs;
	}
	
	public static TreeSet<Weatherstation> getCimiWs(int planyear) throws SQLException{
		TreeSet<Weatherstation> cimiWs= new TreeSet<Weatherstation>();
		for(Weatherstation ws:Department.getInstance(planyear).getWeatherstations())
			if(ws.getDataLoc()!=null && ws.getDataLoc().equals("CIMI"))
				cimiWs.add(ws);
		return cimiWs;
	}
	
	public static TreeSet<Weatherstation> getWnWs() throws SQLException{
		TreeSet<Weatherstation> wnWs= new TreeSet<Weatherstation>();
		for(Weatherstation ws:Weatherstation.getAllActive())
			if(ws.getDataLoc()!=null && ws.getDataLoc().equals("WN"))
				wnWs.add(ws);
		return wnWs;
	}
	
	
	public static TreeSet<Weatherstation> getWnWs(int planyear) throws SQLException{
		TreeSet<Weatherstation> wnWs= new TreeSet<Weatherstation>();
		for(Weatherstation ws:Department.getInstance(planyear).getWeatherstations())
			if(ws.getDataLoc()!=null && ws.getDataLoc().equals("WN"))
				wnWs.add(ws);
		return wnWs;
	}
	
	public static TreeSet<Weatherstation> getNoaaWs() throws SQLException{ 		
		TreeSet<Weatherstation> noaaWs= new TreeSet<Weatherstation>();
		for(Weatherstation ws:Weatherstation.getAllActive())
			if(ws.getDataLoc()!=null && (ws.getDataLoc()==null || (ws.getDataLoc().equals("SGX") || ws.getDataLoc().equals("HNX") || ws.getDataLoc().equals("LOX") || ws.getDataLoc().equals("VEF"))))
				noaaWs.add(ws);
		return noaaWs;
	}
	
	public static TreeSet<Weatherstation> getNoaaWs(int planyear) throws SQLException{ 	
		TreeSet<Weatherstation> noaaWs= new TreeSet<Weatherstation>();
		for(Weatherstation ws:Department.getInstance(planyear).getWeatherstations())//FIXME exclude 44, 51, 47, 50, 24, 10, 11
			if(ws.getDataLoc()!=null && (ws.getDataLoc()==null || (ws.getDataLoc().equals("SGX") || ws.getDataLoc().equals("HNX") || ws.getDataLoc().equals("LOX") || ws.getDataLoc().equals("VEF"))))
				if(ws.getStationId()!=44 && ws.getStationId()!=51 && ws.getStationId()!=47 && ws.getStationId()!=50&& ws.getStationId()!= 24 
						&& ws.getStationId()!= 10&& ws.getStationId()!= 11)
					noaaWs.add(ws);
		return noaaWs;
	}
	
	public static TreeSet<Weatherstation> getFtpWs() throws SQLException{
		TreeSet<Weatherstation> ftpWs= new TreeSet<Weatherstation>();
		for(Weatherstation ws:Weatherstation.getAllActive())
			if(ws.getDataLoc()!=null && ws.getDataLoc().equals("FTP"))
				ftpWs.add(ws);
		return ftpWs;
	}
	
	public static TreeSet<Weatherstation> getFtpWs(int planyear) throws SQLException{
		TreeSet<Weatherstation> ftpWs= new TreeSet<Weatherstation>();
		for(Weatherstation ws:Department.getInstance(planyear).getWeatherstations())
			if(ws.getDataLoc()!=null && ws.getDataLoc().equals("FTP"))
				ftpWs.add(ws);
//			if(ws.getStationId()==7)
//				ftpWs.add(ws);
		return ftpWs;
	}
	
	/**
	 * Obtains weatherstains from NOAA which have FTP station number assigned.
	 * This can be used to find historical data including min,max,avg temperatures.
	 * 
	 * @param planyear
	 * @return
	 * @throws SQLException
	 */
	public static TreeSet<Weatherstation> getNOAAFtpWs(int planyear) throws SQLException{
		TreeSet<Weatherstation> ftpWs= new TreeSet<Weatherstation>();
		for(Weatherstation ws:Department.getInstance(planyear).getWeatherstations())
			if(ws.getStationNumber()>7000 )//7000 is designated NOAA FTP station id
				ftpWs.add(ws);
		return ftpWs;
	}
	
	public static TreeSet<Weatherstation> getDnaWs() throws SQLException{
		TreeSet<Weatherstation> dnaWs= new TreeSet<Weatherstation>();
		for(Weatherstation ws:Weatherstation.getAllActive())
			if(ws.getSource()!=null && ws.getSource().equals("DNA"))
				dnaWs.add(ws);
		return dnaWs;
	}
	
	public static TreeSet<Weatherstation> getDnaWs(int planyear) throws SQLException{
		TreeSet<Weatherstation> dnaWs= new TreeSet<Weatherstation>();
		for(Weatherstation ws:Department.getInstance(planyear).getWeatherstations())
			if(ws.getSource()!=null && ws.getSource().equals("DNA"))
				dnaWs.add(ws);
		return dnaWs;
	}
	
	public DescriptiveStatistics getEffectiveTemperatureStats() throws SQLException{
		DescriptiveStatistics stats = new DescriptiveStatistics();
		Vector<Double> data = new Vector<Double>();
		for(int yr=1980;yr<Department.getActivePlanYear();yr++){
			double pk = getPeakEff(yr);
			if(pk>65){
				stats.addValue(pk);
				data.add(pk);
			}
		}
		return stats;
	}
	
	public DescriptiveStatistics getEquivalentTemperatureStats() throws SQLException{
		DescriptiveStatistics stats = new DescriptiveStatistics();
		Vector<Double> data = new Vector<Double>();
		for(int yr=1980;yr<Department.getActivePlanYear();yr++){
			double pk = getPeakEqu(yr);
			if(pk>65){
				stats.addValue(pk);
				data.add(pk);
			}
		}
		return stats;
	}
	
	public double getEffMean() throws SQLException{
		return getEffectiveTemperatureStats().getMean();
	}
	
	public double getEqyMean() throws SQLException{
		return getEquivalentTemperatureStats().getMean();
	}
	
	public double getEffProbability(double percent) throws SQLException{
		DescriptiveStatistics stats = getEffectiveTemperatureStats();
		NormalDistribution normalD = new NormalDistribution(stats.getMean(),stats.getStandardDeviation());
		return normalD.inverseCumulativeProbability(percent);
	}
	
	public double getEquProbability(double percent) throws SQLException{
		DescriptiveStatistics stats = getEquivalentTemperatureStats();
		NormalDistribution normalD = new NormalDistribution(stats.getMean(),stats.getStandardDeviation());
		return normalD.inverseCumulativeProbability(percent);
	}
	
}
