/**
 *           | Master Data Interface Version 2.0 |                       
 * 
 * Copyright (c) 2006, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team. 					  
 * 	                   All rights reserved.
 * 
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
package com.sce.esp.object.model;

import java.io.Serializable;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Collection;
import java.util.Vector;

import com.sce.esp.util.IconsFactory;


/**
 * The Class AgDailyPeak.
 * 
 * @author Distribution Staff Engineering
 * @version 2.0
 */
public class AgDailyPeak implements AbstractDailyPeak, Serializable{
	
    /** The co. */
    private CoreObject co;
    
    /** The date. */
    private Calendar date;
    
    /**
     * The Constructor.
     * 
     * @param co the co
     * @param date the date
     */
    public AgDailyPeak(CoreObject co, Calendar date){
        this.co = co;
        this.date = date;
    }
    
    /**
     * Gets the core object.
     * 
     * @return the core object
     */
    public CoreObject getCoreObject(){
        return co;
    }
    
    /**
     * Gets the date.
     * 
     * @return the date
     */
    public Calendar getDate(){
        return date;
    }
    
    /**
     * Gets the B banks.
     * 
     * @return the B banks
     * 
     * @throws SQLException the SQL exception
     */
    private Collection<Bbank> getBBanks()throws SQLException{
        Vector<Bbank> bbanks = new Vector<Bbank>();
        for(Bbank bbank:co.getYear(0,date.get(Calendar.YEAR)).getBbanks(SubFilter.CORE_SUB))
        	bbanks.add(bbank);
        return bbanks;
    }
    
    /**
     * Gets the recorded peak.
     * 
     * @return the recorded peak
     * 
     * @throws SQLException the SQL exception
     */
    public double getRecordedPeak()throws SQLException{
        double sum=0;
        Collection<Bbank> bbanks = getBBanks();
        for(Bbank bbank:bbanks)
            sum += bbank.getDailyPeak(date).getRecordedPeak();
        return sum;
    }

    /**
     * Gets the peak adjustment.
     * 
     * @return the peak adjustment
     * 
     * @throws SQLException the SQL exception
     */
    public double getPeakAdjustment() throws SQLException{
        double sum=0;
        Collection<Bbank> bbanks = getBBanks();
        for(Bbank bbank:bbanks)
            sum += bbank.getDailyPeak(date).getPeakAdjustment();
       return sum;
    }

    /**
     * Gets the gen adjustment.
     * 
     * @return the gen adjustment
     * 
     * @throws SQLException the SQL exception
     */
    public double getGenAdjustment() throws SQLException{
        double sum=0;
        Collection<Bbank> bbanks = getBBanks();
        for(Bbank bbank:bbanks)
            sum += bbank.getDailyPeak(date).getGenAdjustment();
       return sum;
    }
    
    public double getPLL() throws SQLException{
    	double sum=0;
        Collection<Bbank> bbanks = getBBanks();
        for(Bbank bbank:bbanks)
            sum += bbank.getDailyPeak(date).getPLL();
       return sum;
    }

    /**
     * Gets the actual peak.
     * 
     * @return the actual peak
     * 
     * @throws SQLException the SQL exception
     */
    public double getActualPeak() throws SQLException{
        double sum=0;
        Collection<Bbank> bbanks = getBBanks();
        for(Bbank bbank:bbanks)
            sum += bbank.getDailyPeak(date).getActualPeak();
        return sum;
    }
    
    /**
     * Gets the adj peak.
     * 
     * @return the adj peak
     * 
     * @throws SQLException the SQL exception
     */
    public double getAdjPeak() throws SQLException{
        double sum=0;
        Collection<Bbank> bbanks = getBBanks();
        for(Bbank bbank:bbanks)
            sum += bbank.getDailyPeak(date).getAdjPeak();
       return sum;
    }

    /*
     * (non-Javadoc)
     * @see com.sce.mdi.object.AbstractDailyPeak#getTemperature()
     */
	public AbstractTemperature getTemperature() throws SQLException{
		return getCoreObject().getTemperature(this.getDate());
	}

	// Return the % Adj of the peak
	public double getAdjFactor() throws SQLException{
		double ap = getActualPeak();
		if(ap == 0)
			return 0;
		//return 1-(getAdjPeak()/ap);
		return (getAdjPeak()-ap)/ap;
	}

	// Return the interruption status
	public int getIntStatus() throws SQLException{
		int interruptionDays = 0;
		int intOccurance = 0;
		
		// Loop through systems, 0==Production
		for(Sys s: getCoreObject().getSyss(0)){
			// Interruption info stored in SysDaily
			SysDaily si = s.getInterruption(date);
			// 0 : No interruption on this day
			if(si.isInterruption()==true)
				interruptionDays++;		
			// 2 : Interruption occurred on peak day and is understood to be all day from no start or end time specified
			if((si.getStartTime()==null || si.getStartTime().equals("00:00:00")) && (si.getEndTime()==null || si.getEndTime().equals("23:59:59")))
				intOccurance++;		
			// 1 : Interruption occurred on peak day but peak time is not available	
			if(si.getEndTime()==null /*|| peakTime.length()==0*/)
				return 1;
			// 2 : Peak occurred during an interruption
			if(si.getStartTime()==null || /*peakTime.compareTo(si.getStartTime())!=-1) &&*/ (si.getEndTime()==null) /*|| peakTime.compareTo(si.getEndTime())!=1*/)
				return 2;
			// 1 : Interruption occurred on peak day but outside of peak time 
			//return 1;
		}
		// If no interruptions, time not known for object
		if(interruptionDays==0)
			return 0;
		// If interruptions, all day, time not known for object
		else if(intOccurance>0)
			return 2;
			
		// (DEFAULT) : Interruption occurred on peak day but outside of peak time 
		return 1;
	}

	public String getIntStatusIconURL() throws SQLException {
		int status = getIntStatus();
		if(isWithinTempCriteria())
			switch(status){
				case 0: return IconsFactory.Interruption.INT1;
				case 1: return IconsFactory.Interruption.INT2;
				case 2: return IconsFactory.Interruption.INT3;
			}
		else
			switch(status){
				case 0: return IconsFactory.Interruption.INT4;
				case 1: return IconsFactory.Interruption.INT5;
				case 2: return IconsFactory.Interruption.INT6;
			}
		return null;
	}
	
	public boolean isWithinTempCriteria() throws SQLException{
		if(Math.abs(getEffDelta())<=DailyPeak.TEMP_CRITERIA_RANGE)
			return true;
		return false;
	}
	
	public double getEffDelta() throws SQLException {
		return getTemperature().getTenYearAvg()-getTemperature().getEffTemp();
	}
}