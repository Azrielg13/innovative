/**
 *           | Master Data Interface Version 2.0 |                       
 * 
 * Copyright (c) 2006, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team. 					  
 * 	                   All rights reserved.
 * 
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
package com.sce.esp.object.model;

import java.io.Serializable;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Collection;
import java.util.TreeSet;

import javax.persistence.Entity;
import javax.persistence.NamedNativeQueries;
import javax.persistence.NamedNativeQuery;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;
import javax.swing.Icon;

import com.sce.esp.hst.ForecastBank;
import com.sce.esp.hst.RealTimeBank;
import com.sce.esp.object.dao.BankDAO;
import com.sce.esp.object.jpa.AutoInsertable;
@Entity
@AutoInsertable
@Table(schema="MDI",name="MDI400_BANK")
@NamedQueries({
	@NamedQuery(name = "findByID", query="SELECT o FROM Bank o WHERE o.PLANYEAR=?1 AND o.SIM_ID=?2 AND o.BANK_ID=?3"),//AUTO-GENERATED
	@NamedQuery(name = "findAll", query="SELECT o FROM Bank o"),//AUTO-GENERATED
	@NamedQuery(name = "findAllActive", query="SELECT o FROM Bank o WHERE o.DELETED_TS IS NULL"),//AUTO-GENERATED
	@NamedQuery(name = "findByProj", query="SELECT o FROM Bank o WHERE o.PLANYEAR=?1 AND o.SIM_ID=?2 AND o.IN_SERVICE_PROJ_ID=?3 AND o.DELETED_TS IS NULL"),//AUTO-GENERATED
	@NamedQuery(name = "findByProj2", query="SELECT o FROM Bank o WHERE o.PLANYEAR=?1 AND o.SIM_ID=?2 AND o.OUT_SERVICE_PROJ_ID=?3 AND o.DELETED_TS IS NULL"),//AUTO-GENERATED
	@NamedQuery(name = "findBySub", query="SELECT o FROM Bank o WHERE o.PLANYEAR=?1 AND o.SUB_ID=?2 AND o.DELETED_TS IS NULL"),//AUTO-GENERATED
})
@NamedNativeQueries({
	@NamedNativeQuery(name = "refresh", query="SELECT o.* FROM MDI400_BANK o WHERE o.PLANYEAR=? AND o.SIM_ID=? AND o.BANK_ID=?"),//AUTO-GENERATED
})
public class Bank extends BankDAO implements AutomatedEquipment, TransformerEquipment, FacilityObject, Serializable{
	/**
	 * 
	 */
	private static final long serialVersionUID = 7607143048292577991L;
	private RealTimeBank bankHst;
	private ForecastBank bankForc;
	private TreeSet<ScopeItem> scopeItems2;
	private TreeSet<ScopeItem> scopeItems;

	/**
	 * The Constructor.
	 * 
	 * @param planyear the planyear
	 */
	public Bank(){
	}
	public Bank(int planyear) {
		super(planyear,0,0);
	}

	public Bank(int planyear, int simId) {
		super(planyear,simId,0);
	}

	/**
	 * The Constructor.
	 * 
	 * @param planyear the planyear
	 * @param bankId the bank id
	 */
	public Bank(int planyear, int simId, int bankId){
		super(planyear,simId,bankId);
	}

	public Bank(Bank bank) {
		super(bank);
	}

	/**
	 * Returns a string representation of the object.
	 * 
	 * @return a string representation of the object.
	 * 
	 * @throws SQLException  */
	public String toString(){
		return /*this.getFacilityInstalledAt() + */"#"+getBankNum()+" Bank";
	}

	/**
	 * Gets the name.
	 * 
	 * @return the toString() method.
	 * @throws SQLException 
	 */
	public String getName(){
		return getBankNum();
	}

	public void setName(String s) throws SQLException {
		this.setBankNum(s);		
	}

	/**
	 * Gets the daily peak.
	 * 
	 * @param date the date
	 * 
	 * @return the <code>BankDaily</code> object
	 * 
	 * @throws SQLException the SQL exception
	 */
	public BankDaily getDailyPeak(Calendar date) throws SQLException {
		return BankDaily.getInstance(getPlanyear(), 0, getBankId(), date, true);
	}

	/**
	 * Gets the daily peaks.
	 * 
	 * @param startDate the start date
	 * @param endDate the end date
	 * 
	 * @return the daily peaks
	 * 
	 * @throws SQLException the SQL exception
	 */
	public BankDaily[] getDailyPeaks(Calendar startDate, Calendar endDate)throws SQLException{
		BankDaily[] peaks = new BankDaily[(int)Math.round((endDate.getTimeInMillis()-startDate.getTimeInMillis())/(1000.0*60*60*24)+1)];		
		Calendar cal = (Calendar)startDate.clone();
		for(int p=0; p<peaks.length; p++){
			peaks[p] = getDailyPeak(cal);
			cal = (Calendar)cal.clone();
			cal.add(Calendar.DATE,1);
		}
		return peaks;
	}

	/**
	 * Checks if is automated.
	 * 
	 * @return true, if is automated
	 */
	public boolean isAutomated() {
		return isPAutomated();
	}

	/**
	 * Checks if hp, a, b , or c is automated.
	 * 
	 * @return true, if is automated
	 */
	public boolean isPAutomated() {
		return (getADp() != null && getADp().length() > 0) || (getBDp() != null && getBDp().length() > 0) || (getCDp() != null && getCDp().length() > 0);
	}

	/**
	 * Checks if N is automated.
	 * 
	 * @return true, if is automated
	 */
	public boolean isNAutomated() {
		return getNDp() != null && getNDp().length() > 0;
	}

	/**
	 * Checks if mw or mvar is automated.
	 * 
	 * @return true, if is automated
	 */
	public boolean isVWAutomated() {
		return (getMvarDp() != null && getMvarDp().length() > 0) || (getMwDp ()!= null && getMwDp().length() > 0);
	}

	/**
	 * Checks if N is automated.
	 * 
	 * @return true, if is automated
	 */
	public boolean isKvAutomated() {
		return (getKvDp() != null && getKvDp().length() > 0);
	}

	/**
	 * Obtain scada peak.
	 * 
	 * @param cal the cal
	 * 
	 * @throws Exception the exception
	 */
	public void obtainScadaPeak(Calendar sDate, boolean overwrite){
		obtainScadaPeak(sDate,sDate,overwrite);
	}

	/**
	 * Obtains historical peak data only.  Will return if the calendar time
	 * is greater than or equal to today.
	 * 
	 * @param xfmr the bank
	 * @param cal the calendar date
	 * 
	 * @throws Exception the exception
	 */

	public void obtainScadaPeak(Calendar sDate, Calendar eDate, boolean overwrite){
		DailyPeak.obtainScadaPeak(this, sDate, eDate, overwrite);
	}

	/**
	 * @return the <code>RealTimeBank</code> object
	 */
	public RealTimeBank getRealTimeBank() {	 
		if(bankHst==null)
			bankHst = new RealTimeBank(this);
		return bankHst;
	}

	/**
	 * @return the <code>ForecastBank</code> object
	 */
	public ForecastBank getForecastBank(Calendar cal) {	 
		if(bankForc==null||bankForc.getDate()!=cal)
			bankForc = new ForecastBank(this,cal);
		return bankForc;
	}

	/**
	 * @return true if the bank serves load.
	 */
	public boolean isLseBank(){
		return !isSpare() && !isFake();	
	}

	public double getMVAFactor() throws SQLException {		
		return getSub().getMVAFactor();
	}
	public double getSecondaryKv() throws SQLException{
		if(getSub() !=null)
			return getSub().getSecondaryKv();
		return 0;
	}
	public String getNDp() {
		return getNeutDp();
	}
	public void setNDp(String neutDp) throws SQLException {
		setNeutDp(neutDp);
	}
	
	/**
	 * @deprecated
	 * @return
	 */
	public double getPLL(){
		return getNameplate()*getPllPercent();
	}

	public AutomatedEquipment getCoinParent() {
		return null;
	}
	
	public boolean isFake() {
		return getBankNum().toUpperCase().startsWith("X");
	}

	public boolean isSpare() {
		return getBankNum()!=null && ( getBankNum().toUpperCase().startsWith("SPARE") || getBankNum().toUpperCase().startsWith("GROUND") || getBankNum().toUpperCase().startsWith("SLP"));
	}
	
	public Proj getInServiceProj() throws SQLException {
		return Proj.getInstance(getPlanyear(),getSimId(),getInServiceProjId());
	}
	
	public Proj getOutServiceProj() throws SQLException {
		return Proj.getInstance(getPlanyear(),getSimId(),getOutServiceProjId());
	}
	public void setInServiceProj(Proj proj) throws SQLException{
		setProj(proj);
	}
	public void setOutServiceProj(Proj proj) throws SQLException{
		setProj2(proj);
	}
	public ScopeItem getMostRecentScopeItem(Calendar asOf) throws SQLException{
		ScopeItem last = null;
		for(ScopeItem si:getScopeItems2()){
			if(!si.isInService(asOf))
				return last;
			if(si.isActiveBl(getPlanyear(),getSimId()))
				last = si;
		}
		return last;
	}
	public ScopeItem getMostRecentScopeItemInService(Calendar asOf) throws SQLException{
		ScopeItem last = null;
		for(ScopeItem si:getScopeItems2()){
			if(!si.isInService(asOf))
				return last;
			if(si.isInService() && si.isActiveBl(getPlanyear(),getSimId()))
				last = si;
		}
		return last;
	}
	public double getPLLFactor(Calendar asOf) throws SQLException {
		ScopeItem last = getMostRecentScopeItem(asOf);
		if(last != null)
			return last.getBankPLLFactorPost(getPlanyear(),getSimId());
		return 0;
	}
	public double getPLLFactorInService(Calendar asOf) throws SQLException {
		ScopeItem last = getMostRecentScopeItemInService(asOf);
		if(last != null)
			return last.getBankPLLFactorPost(getPlanyear(),getSimId());
		return 0;
	}
	
	public double getPLL(Calendar asOf) throws SQLException{
		return getPLLFactor(asOf)*getNameplate(asOf);
	}

	public double getPLLInService(Calendar asOf) throws SQLException {
		return getPLLFactorInService(asOf)*getNameplateInService(asOf);
	}
	
	public double getELL(Calendar asOf) throws SQLException{
		return getELLFactor(asOf)*getNameplate(asOf);
	}
	
	public double getELLFactor(Calendar asOf) throws SQLException {
		ScopeItem last = getMostRecentScopeItem(asOf);
		if(last != null)
			return last.getBankELLFactorPost(getPlanyear(),getSimId());
		return 0;
	}
	public double getELLInService(Calendar asOf) throws SQLException {
		return getELLFactorInService(asOf)*getNameplateInService(asOf);
	}
	public double getELLFactorInService(Calendar asOf) throws SQLException {
		ScopeItem last = getMostRecentScopeItemInService(asOf);
		if(last != null)
			return last.getBankELLFactorPost(getPlanyear(),getSimId());
		return 0;
	}
	public TreeSet<Xfmr> getXfmrs(Calendar asOf) throws SQLException {
		return getXfmrs(asOf,null);
	}
	public TreeSet<Xfmr> getXfmrs(Calendar asOf,Collection<SceProjElemCost> without) throws SQLException {
		ScopeItem last = getMostRecentScopeItem(asOf);
		if(last != null)
			return last.getXfmrsPost(getPlanyear(),getSimId(),without);
		return new TreeSet<Xfmr>();
	}
	public TreeSet<Xfmr> getXfmrsInService(Calendar asOf) throws SQLException {
		ScopeItem last = getMostRecentScopeItemInService(asOf);
		if(last != null)
			return last.getXfmrsPost(getPlanyear(),getSimId());
		return new TreeSet<Xfmr>();
	}
	public double getNameplate(Calendar asOf) throws SQLException {
		return getNameplate(asOf,null);
	}
	public double getNameplate(Calendar asOf,Collection<SceProjElemCost> without) throws SQLException {
		double np=0;
		for(Xfmr xfmr:getXfmrs(asOf,without))
			np += xfmr.getNameplate();
		return np;
	}
	public double getNameplateInService(Calendar asOf) throws SQLException {
		double np=0;
		for(Xfmr xfmr:getXfmrsInService(asOf))
			np += xfmr.getNameplateInService();
		return np;
	}

	public CoType getCoType() throws SQLException {
		return CoType.getInstance(getCoTypeId());
	}

	public int getCoTypeId() {
		return CoType.BANK;
	}

	public int getId() {
		return getBankId();
	}

	public Object getRegions(int simId) throws SQLException {
		return getSub().getRegions(simId);
	}
	public synchronized TreeSet<SceProjElemCost> getSceProjElemCosts()throws SQLException{
		TreeSet<SceProjElemCost> sceProjElemCosts = new TreeSet<SceProjElemCost>();
		for(ScopeItem si:getScopeItems2())
			sceProjElemCosts.add(si.getSceProjElemCost());
		return sceProjElemCosts;
	}
	
	public void setParentId(int coId) throws SQLException {
		setSubId(coId);
	}
	
	public FacilityObject getFacilityInstalledAt()throws SQLException{
		for(ScopeItem si:getScopeItems())
			if(si.isActiveBl(getPlanyear(),getSimId()) && si.getQuantity() == 1)
				return si.getFacilityObject(getPlanyear());
		return null;
	}
	
	public synchronized Collection<ScopeItem> getScopeItems()throws SQLException{
		return ScopeItem.getNamedCollection("findByModelingItem", getCoTypeId(),getId());
	}
	
	public synchronized Collection<ScopeItem> getScopeItems2()throws SQLException{
		return ScopeItem.getNamedCollection("findByFacility", getCoTypeId(),getId());
	}

	public FacilityObject getFacilityInstalledAt(int simId) throws SQLException {
		return getFacilityInstalledAt();
	}
	
	public void resortSceProjElemCosts() throws SQLException {
		TreeSet<ScopeItem> sis = new TreeSet<ScopeItem>();
		if(scopeItems2!=null){
			for(ScopeItem si:scopeItems2)
				sis.add(si);
			scopeItems2 = sis;
		}
	}
	
	public Calendar getInServiceDate()throws SQLException{
		ScopeItem si = getInServiceScopeItem();
		if(si != null)
			return si.getModelDate();
		return null;
	}
	
	public SceProj getInServiceSceProj() throws SQLException{
		ScopeItem si = getInServiceScopeItem();
		if(si != null)
			return si.getSceProjElemCost().getSceProjRev().getSceProj();
		return null;
	}
	public ScopeItem getInServiceScopeItem() throws SQLException{
		for(ScopeItem si:getScopeItems())
			if(si.isActiveBl(getPlanyear(),getSimId()) && si.getQuantity() == 1)
				return si;
		return null;
	}

	public Calendar getOutServiceDate()throws SQLException{
		ScopeItem si = getOutServiceScopeItem();
		if(si != null)
			return si.getModelDate();
		return null;
	}
	
	public SceProj getOutServiceSceProj() throws SQLException{
		ScopeItem si = getOutServiceScopeItem();
		if(si != null)
			return si.getSceProjElemCost().getSceProjRev().getSceProj();
		return null;
	}
	public ScopeItem getOutServiceScopeItem() throws SQLException{
		for(ScopeItem si:getScopeItems())
			if(si.isActiveBl(getPlanyear(),getSimId()) && si.getQuantity() == -1)
				return si;
		return null;
	}
	
//	public void insert() throws SQLException{
//		super.insert();
//		if(getPlanyear()<Department.getActivePlanYear()){
//			Bank cp = copy();
//			cp.setPlanyear(getPlanyear()+1);
//			cp.insert();
//		}
//	}

	public double getPrimaryKv() throws SQLException {
		return getSub().getPrimaryKv();
	}
	@Override
	public Icon getIcon() {
		return null;
	}
	public String getSerials() throws SQLException {
		StringBuffer sb = new StringBuffer();
		for(Xfmr x: getXfmrs())
			sb.append(x.getSerialNum()+",");
		return sb.toString();
	}
}
