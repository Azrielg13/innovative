/**
 * 
 */
package com.sce.esp.object.model;

import java.awt.Color;
import java.io.Serializable;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.TreeSet;
import java.util.Vector;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.NamedNativeQueries;
import javax.persistence.NamedNativeQuery;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;
import javax.persistence.TypedQuery;
import javax.swing.Icon;

import com.sce.esp.log.EspLogger;
import com.sce.esp.object.dao.SceProjRevDAO;
import com.sce.esp.object.jpa.EntityManagerHelper;
import com.sce.esp.object.jpa.criteria.CriteriaBuilderImpl;
import com.sce.esp.object.jpa.criteria.CriteriaQueryImpl;
import com.sce.esp.object.jpa.criteria.Restrictions;
import com.sce.esp.util.Calculate;
import com.sce.esp.util.FormatText;
import com.sce.esp.util.IconsFactory;
import com.sce.esp.util.db.PDBConnection;

@Entity
@Table(schema="MDI",name="MDIS40_SCE_PROJ_REV")
@NamedQueries({
	@NamedQuery(name = "findByID", query="SELECT o FROM SceProjRev o WHERE o.SCE_PROJ_REV_ID=?1"),//AUTO-GENERATED
	@NamedQuery(name = "findAll", query="SELECT o FROM SceProjRev o"),//AUTO-GENERATED
	@NamedQuery(name = "findAllActive", query="SELECT o FROM SceProjRev o WHERE o.DELETED_TS IS NULL"),//AUTO-GENERATED
	@NamedQuery(name = "findBySceProj", query="SELECT o FROM SceProjRev o WHERE o.SCE_PROJ_ID=?1 AND o.DELETED_TS IS NULL"),//AUTO-GENERATED
	@NamedQuery(name = "findByProgram", query="SELECT o FROM SceProjRev o WHERE o.PROGRAM_ID=?1 AND o.DELETED_TS IS NULL"),//AUTO-GENERATED
	@NamedQuery(name = "findByOrg", query="SELECT o FROM SceProjRev o WHERE o.ORG_ID=?1 AND o.DELETED_TS IS NULL"),//AUTO-GENERATED

})
@NamedNativeQueries({
	@NamedNativeQuery(name = "refresh", query="SELECT o.* FROM MDIS40_SCE_PROJ_REV o WHERE o.SCE_PROJ_REV_ID=?"),//AUTO-GENERATED
})
public class SceProjRev extends SceProjRevDAO implements Serializable, ProjectItem, Schedulable {

	private static final long serialVersionUID = 6261434504472757855L;

	/** The Constant NEW. */
	public final static int NEW=1; //1

	/** The Constant ABORTED. */
	public final static int ABORTED=2; //2

	/** The Constant CANCELLED. */
	public final static int CANCELLED=4; //4

	/** The Constant NO_CHANGE. */
	public final static int NO_CHANGE=8; //8

	/** The Constant COMPLETE. */
	public final static int COMPLETE=16; //16

	public final static String[] STATUS_TEXT = {"New", "Cancel", "No Change", "Revise", "Complete"};

	/** The Constant OD_CHANGED. */
	public final static int OD_CHANGED=32; //32

	/** The Constant SCOPE_CHANGED. */
	public final static int SCOPE_CHANGED=64; //64

	/** The Constant USER_FORCED. */
	public final static int USER_FORCED=128; //128

	/** The Constant REVISED. */
	public final static int REVISED = OD_CHANGED | SCOPE_CHANGED | USER_FORCED;

	/** The Constant ACTIVE. */
	public final static int ACTIVE_STATUS = NEW | NO_CHANGE | REVISED;

	/** The Constant ALL_STATUSES */
	public final static int ALL_STATUSES = ACTIVE_STATUS | CANCELLED | COMPLETE;

	/** The Constant Statuses without Aborted */
	public final static int PUBLISH = ACTIVE_STATUS | CANCELLED;

	/** The G o131 d_ TEXT. */
	public static String[] GO131D_TEXT = new String[]{"No","Yes","Unknown"};

	public static final int APPROVED = 1;
	public static final int DENIED = 2;
	public static final int RETRACTED = 4;
	public static final int EMERGENT = 8;
	public static final int CONCEPTUAL = 16;
	public static final int INSERVICE = 32;

	public static final String REV_STATUS_SUBMIT = "Submitted";
	public static final String REV_STATUS_EVAL = "Evaluating";
	public static final String REV_STATUS_APP = "Approved";
	public static final String REV_STATUS_APP_CANCEL = "Approved - CANCEL";
	public static final String REV_STATUS_DENIED = "Request Denied";
	public static final String REV_STATUS_DELETE = "Deleted";
	public static final String REV_STATUS_PROJ_DELETE = "Project Deleted";
	public static final String REV_STATUS_RETRACT = "Request Retracted";
	public static final String REV_STATUS_RETRACT_REQ = "Retraction Requested";
	public static final String REV_STATUS_CONCEPTUAL = "Conceptual";
	public static final String REV_STATUS_EMERGENT = "Emergent";

	public static final String REQUEST_ADD = "Add Project to Master List";
	public static final String REQUEST_REM = "Remove Project from Master List";
	public static final String REQUEST_CHANGE = "Modify Project on Master List";


	public static final int HISTORICAL_YEARS = 9;
	public static final int FUTURE_YEARS = 1;

	public static final int ENG_FINALIZED=1;
	public static final int MGR_FINALIZED=2;

	public static final int LOW_PRIORITY=1;
	public static final int HIGH_PRIORITY=0;

	public static final String LOW_PRIORITY_STRING="LOW";
	public static final String HIGH_PRIORITY_STRING="HIGH";

	public static final int MODEL_NEED_DATE = 1;
	public static final int MODEL_OPERATING_DATE = 2;
	public static final int MODEL_IN_SERVICE_DATE = 3;


	public final static String[] VARIABLES = new String[]{"&Facility","&PrimaryKv","&SecondaryKv","&CktCountAfter","&CktCountBefore",
		"&CapAdd","&CapAddPre","&CapAddPost","&CktAdd", "&CktRemove", "&VarAdd", "&VarRemove"};

	public final static String INFO_FIELDS = "ORG_ID,SPONSOR_USER_ID,LOCATION,TITLE,DESCRIPTION,NEED,ALT_PROJ_NOTE,COMMITTEE,FILE_NO,PMO_ORG_ID,PMO_NOTE,OD_NOTE,EPEF_COMMENT,PROJ_NUM"
			+"USE_DEFAULT_TITLE,CRIT_ASS,ECON_JUST,ENG_FINALIZED,GO131D,GRC,ProjWorkGroup,ProjResourceEval,SceProjTracking,IN_SERVICE_TS,USE_CALC_JUST,N1_RESERVE,PROJ_PRIORITY,ACL_NO_PROJ"
			+"RESERVE_NO_PROJ,RESERVE_HC_NO_PROJ";
	public final static String CANCEL_FIELDS = "ACTIVE";
	public final static String BSS_FIELDS = "DELETED_TS,FORCE_REV_STATUS,APPROVED_OD,PROPOSED_OD";
	public final static String ADMIN_FIELDS = "SCE_PROJ_ID,REV_TS,MGR_FINALIZED,REVIEWED";
	public final static String ALWAYS_FIELDS = "INSERT_TS,ProjRevFile,GateTracking,NOTE";
	public final static String SPI_FIELDS = "PRIORITY_OVERRIDE,EPEF_NUM,EPEF_OFFSET_COMMENT,EPEF_REL_TRENDS,EPEF_ACK_USER_ID,EPEF_ACK_TS,EPEF_APP_USER_ID"
			+",EPEF_APP_BY_USER_ID,EPEF_RESOLUTION_TS,EPEF_RESOLUTION,EPEF_RESOLUTION_NOTE,EPEF_APP_EXPIRE_TS,EPEF_PRIORITY_NEEDED,ATP_NEED_TS,TOTAL_DURATION,ENG_SCH_USER_ID,ENG_SCH_ORG_ID,ProjRevOffset, PROGRAM_ID";
	public final static String SUBMIT_FIELDS = "EPEF_SUBMIT_USER_ID,EPEF_SUBMIT_TS";
	public final static String RETRACT_FIELDS = "RETRACT_REQ_TS,RETRACT_REQ_USER_ID,RETRACT_REQ_NOTE";

	public static final int LIC_NOT_EXPECTED = 0;
	public static final int LIC_REVIEW_REQ = 1;
	public static final int LIC_REVIEW_IP = 2;
	public static final int LIC_131D_REVIEW_REQ = 3;
	public static final int LIC_131D_REVIEW_IP = 4;
	public static final int LIC_REQUIRED = 5;
	public static final int LIC_EXEMPT = 6;
	public static final int LIC_NOT_REQ = 7;

	public static enum ModelDateType {NEED_DATE, OPERATING_DATE, IN_SERVICE_DATE};
	public static enum YearType {PLAN_YEAR, CALENDAR_YEAR, FISCAL_YEAR};

	/**
	 * Public constructor for creating a generic SceProjRev
	 * object for record insertion through a wizard.
	 * WARNING!! This should not be used for anything else.
	 * @throws SQLException 
	 */
	public SceProjRev() {
		super(0);
		try {
			setUseDefaultTitle(true);
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
	@Column(name="PROJ_NUM",nullable=true,length=32)
	public String getProjNum(){
		try {
			if(super.getProjNum() == null){
				if(getProgram()!=null)
					return ""+getProgram()+getSceProjId();
				else
					return "NoProg"+getSceProjId();
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return super.getProjNum();
	}
	public String getProjNumWithoutLeadingZeros(){
		try {
			if(super.getProjNum() == null){
				if(getProgram()!=null)
					return ""+getProgram()+getSceProjId();
				else
					return "NoProg"+getSceProjId();
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return super.getProjNum().replaceFirst("^0+(?!$)", "");
	}

	/**
	 * @param sceProjRevId
	 * @param sceProjId
	 */
	public SceProjRev(int sceProjRevId) throws SQLException {
		super(sceProjRevId);
		setUseDefaultTitle(true);
	}

	public SceProjRev(SceProjRev sceProjRev) {
		super(sceProjRev);
	}

	public void setApproved(boolean approve) throws SQLException{
		if(approve){
			setEpefResolution(APPROVED);
			setEpefResolutionTs(Calendar.getInstance());
			setEpefAppUser(getProgram().getApprover());
			setEpefAppByUser(User.getActiveUser());
		}else{
			setEpefResolution(0);
			setEpefResolutionTs(null);
			setEpefAppUser(null);
			setEpefAppByUser(null);
		}
	}


	public void setIwpApproved(Calendar c, User u) throws SQLException {
		if(getEpefResolutionTs()==null){
			setEpefResolution(APPROVED);
			setEpefAppByUser(u);
			setEpefResolutionTs(c);
		}
	}


	public void setApprovedODToProp() throws SQLException{
		for(SceProjElemCost spec : getSceProjElemCosts(CostStage.Type.Proposed))
			spec.setApprovedOd(spec.getProposedOd());
	}

	public boolean isConceptual(){
		return getIWPState() == CONCEPTUAL;
	}

	public boolean isEmergent(){
		return (getIWPState() == EMERGENT);
	}

	public boolean isRetracted(){
		return (getIWPState() == RETRACTED);
	}

	public boolean isRetractRequested(){
		return getRetractReqTs() != null;
	}

	public boolean isAcknowledged(){
		return getEpefAckTs() != null;
	}

	public boolean isDenied() { 
		return getIWPState()==DENIED;
	}

	public boolean isApproved(){
		return getIWPState()==APPROVED;
	}

	public boolean isInService() {
		return getIWPState()==INSERVICE;
	}

	/**
	 * Returns the IWP state (Conceptual, Emergent, Approved)
	 * @return the integer state
	 */
	public int getIWPState(){
		if(getEpefSubmitTs()==null && getEpefResolutionTs()==null)
			return CONCEPTUAL;
		if(getEpefResolutionTs()==null)
			return EMERGENT;
		return getEpefResolution();

	}

	public boolean isComplete() throws SQLException{
		return getInServiceDate() != null;
	}



	public boolean isEditable(int simId){
		if(simId != getSimId())
			return false;
		if(isNewInstance()) {
			return true;
		}
		try {
			//If IWP user check status
			if(User.getActiveUser().getUserRole().isIWPUser()){
				return (isConceptual() || isEmergent() || isDenied() || isRetracted());
			}
			return isConceptual() && !isPlanFinalized() && !isComplete() && !isMgrFinalized() && 
					User.getActiveUser().getUserRole().isPSIUser() && this == getSceProj().getCurRev(Department.getActivePlanYear(),getSimId());
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return false;
	}

	public boolean isIwpAdminOnly() throws SQLException{
		return User.getActiveUser().getUserRole().isIWPAdmin()||User.getActiveUser().getOrgId() == Org.TIG && isApproved();
	}

	public boolean isAdminOnly() throws SQLException{
		return User.getActiveUser().getUserRole().isAdmin()&& isApproved();
	}

	public boolean isPlanFinalized() throws SQLException{
		if(getProgramId() == Program.DSP || getProgramId() == Program.TSP_ABANK || getProgramId() == Program.TSP_STL || getProgramId() == Program.TSP_STV)
			return Department.getActiveInstance().getCutOverDate().compareTo(getRevTs()) > -1;
			return false;
	}

	/**
	 * Includes SPEC with prior costs even if not Enabled
	 * @return
	 * @throws SQLException
	 */
	public TreeSet<SceProjElemCost> getSceProjElemCostsPrintable(CostStage.Type costType) throws SQLException{
		TreeSet<SceProjElemCost> specs = new TreeSet<SceProjElemCost>();
		for(SceProjElemCost spec: getSceProjElemCosts(costType))
			if((spec.isEnabled() || spec.getPriorCost() > 0))
				specs.add(spec);
		return specs;
	}

	/**
	 * Returns the request state: REM, CHANGE, ADD
	 * @return
	 * @throws SQLException
	 */
	public String getRequest() throws SQLException{	
		//If the project was submitted with a canceled status then the request is 'Remove'
		if(getProjectStatus() == CANCELLED)
			return REQUEST_REM;
		if(getPrevRev(APPROVED) != null)
			return REQUEST_CHANGE;
		//if we made it this far, it must be an 'Add'
		return REQUEST_ADD;
	}

	/**
	 * XXX finish / incorporate IWP/GPC Status
	 * 
	 * Display the revision status.
	 * 
	 * @return the status of the rev in test format
	 * @throws SQLException
	 */
	public String getRevStatus() throws SQLException {

		if(isConceptual())
			return "";

		if(isDenied())
			return REV_STATUS_DENIED + " " + FormatText.USER_DATETIME_SHORT.format(getEpefResolutionTs().getTime());

		//Sets status Delete to Project node
		if(getSceProj() != null && getSceProj().isDeleted())
			return REV_STATUS_PROJ_DELETE;

		//Sets status Delete to Revisions node
		if(isDeleted())
			return REV_STATUS_DELETE;

		//If a retract has been requested then 'Retracted'
		if(isRetracted())
			return REV_STATUS_RETRACT + " " + FormatText.USER_DATETIME_SHORT.format(getEpefResolutionTs().getTime());

		//Approved 
		if(isApproved()){
			if(!isActive())
				return REV_STATUS_APP_CANCEL;
			return REV_STATUS_APP;
		}

		if(isRetractRequested())
			return REV_STATUS_RETRACT_REQ;

		//Received / Acknowledged
		if(!isAcknowledged())
			return REV_STATUS_SUBMIT;

		//Evaluating
		Vector<String> eval = new Vector<String>();

		//Priority
		if(isEpefPriorityNeeded()){
			if(getCurrentSceProjElemPriorities().size()==0)
				eval.add("Priority");
			else{
				for(SceProjElemPriority p: getCurrentSceProjElemPriorities()){
					if(p.getPriority()==0){
						eval.add("Priority");
						break;
					}
				}
			}
		}

		//Resource
		for(ProjResourceEval pre : getProjResourceEvals()){
			for(ProjWorkGroup pwg : pre.getProjWorkGroups()){
				if(pwg.isRequired() && pwg.getRecvTs()!=null){
					eval.add("Resource");
					break;
				}
			}
		}

		boolean eval4=false;

		//Budget
		if(eval4) //TODO IWP DBo will we track if you are evaluating this project for budget?
			eval.add("Budget");

		//Offset
		if(eval4)//TODO IWP Dbo will we track if you are evaluating this project for an offset?
			eval.add("Offset");

		if(eval.size()==0)
			eval.add("Approval");

		if(eval.size()>0){
			String out = REV_STATUS_EVAL + " (";
			for(String s:eval)
				out += s+",";
			return out.substring(0, out.length()-1)+")";
		}

		//Submitted
		return REV_STATUS_EVAL;
	}

	public TreeSet<SceProjTracking> getSceProjTrackingNodes() throws SQLException{
		TreeSet<SceProjTracking> nodes = new TreeSet<SceProjTracking>();
		for(SceProjTracking pt:getSceProjTrackings())
			if(pt.getSceProjTrackingDeps().size() == 0)
				nodes.add(pt);
		return nodes;
	}
	
	public String getTitleShort(){
		if(getTitle().length()>40)
			return getTitle().substring(0, 40)+"...";
		return getTitle();
	}

	/*
	 * (non-Javadoc)
	 * @see com.sce.esp.object.DataAccessObject#toString()
	 */
	public String toString(){
		StringBuilder simString = new StringBuilder();
		if(getSimId() != 0)
			simString.append("[Sim "+getSimId()+"] ");
		String title = getTitle();
		//if(title.length()>40)
		//title = title.substring(0, 40)+"...";

		if(isEmergent() || isDenied() || isRetracted())
			return simString.append(getProjNum()).append(" [").append(getEpefNum()).append("]: ").append(title).toString();

		return simString.append(getProjNum()).append(": ").append(title).toString();
	}

	public String toStringOld(){
		String simString = "";
		if(getSimId() != 0)
			simString = "[Sim "+getSimId()+"] ";
		String title = getProjectTitle();
		//if(title.length()>40)
		//title = title.substring(0, 40)+"...";

		if(isEmergent() || isDenied() || isRetracted())
			return simString + getProjNum() + " [" + getEpefNum() + "]: " + title;

		return simString + getProjNum() + ": " +title;
	}

	public User getSponsor() throws SQLException{
		return User.getInstance(getSponsorUserId());
	}

	public void setSponsor(User sponsor) throws SQLException{
		if(sponsor==null)
			setSponsorUserId(0);
		else
			setSponsorUserId(sponsor.getUsernameId());
	}

	public User getEpefAppUser() throws SQLException{
		return User.getInstance(getEpefAppUserId());
	}

	public void setEpefAppUser(User appUser) throws SQLException{
		if(appUser==null)
			setEpefAppUserId(0);
		else
			setEpefAppUserId(appUser.getUsernameId());
	}

	public User getEpefAppByUser() throws SQLException{
		return User.getInstance(getEpefAppByUserId());
	}

	public void setEpefAppByUser(User appByUser) throws SQLException{
		if(appByUser==null)
			setEpefAppByUserId(0);
		else
			setEpefAppByUserId(appByUser.getUsernameId());
	}

	/**
	 * Business Logic Version that provides the next sequence value
	 * 
	 * @throws SQLException
	 */
	public void setEpefNum() throws SQLException{
		PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement("SELECT MDIS40_EPEF_SEQ.NEXTVAL FROM MDIS75_COST_STAGE WHERE ROWNUM=1");
		ResultSet rs = ps.executeQuery();
		if(rs.next())
			setEpefNum(""+rs.getInt(1));
		rs.close();
		ps.close();
	}

	@Column(name="REV_TS",nullable=false,length=7)
	public Calendar getRevTs(){
		if(super.getRevTs() == null)
			return Calendar.getInstance();
		return super.getRevTs();
	}

	public void insert() throws SQLException{
		if(getSceProjId()==0) {
			SceProj sceProj = new SceProj();
			sceProj.setAltDouble3(getReserveNoProj());//refactored getAltDouble1() to getReserveWithoutProj()
			sceProj.insert();
			setSceProjId(sceProj.getSceProjId());
		}
		super.insert();
		if(getEpefNum()==null)
			setEpefNum();
		//this.getSceProjElemCosts()=null;
	}

	//	public void setTitle(String t) throws SQLException{
	//		super.setProjTitle(t);
	//	}

	public SceProjRev copyToConceptual(int simId)throws SQLException{
		//		EspLogger.debug(this, "COPY TO CONCEPTUAL: "+simId);
		SceProjRev cp = copy();

		//		for(SceProjElemCost spec : cp.getSceProjElemCosts(CostStage.Type.Proposed))
		//			spec.setApprovedOd(null);

		if(simId > 0){
			for(SceProjElemCost spec : new TreeSet<SceProjElemCost>(cp.getSceProjElemCosts(CostStage.Type.Approved))){
				cp.removeSceProjElemCost(spec);
				//				EspLogger.debug(this, "Got Here");
			}
		}

		// why would one want to clear out PLEC, GPC or PMWIF Milestones? Even if it goes back to conceptual
		// there is a need to track the projects history.
		for(GateTracking ct:cp.getGateTrackings()){
			ct.setSubmitDate(null);
			ct.setResolution(0);
			ct.setApprover(null);
			ct.setResolutionTs(null);
			ct.setResolutionNote(null);
		}

		cp.setSimId(simId);
		cp.setEpefSubmitTs(null);

		cp.setEpefAckUserId(0);
		cp.setEpefAckTs(null);
		cp.setEpefAppUserId(0);
		cp.setEpefAppByUserId(0);
		cp.setEpefAppExpireTs(null);
		cp.setEpefComment(null);

		cp.setRetractReqTs(null);
		cp.setRetractReqNote(null);
		cp.setRetractReqUserId(0);

		cp.setEpefResolution(0);
		cp.setEpefResolutionTs(null);
		cp.setEpefResolutionNote(null);

		//		cp.setGpcApproval(null);
		//		cp.setBotApproval(null);
		//		cp.setBodApproval(null);
		//		cp.setUmcApproval(null);
		//		cp.setCpcnApproval(null);
		//		cp.setNercApproval(null);
		//		cp.setFercApproval(null);


		//TODO Make this an option when scope changes, removed by BJS 12/2
		//		getSceProjTrackings().clear();
		getProjRevOffsets().clear();
		getProjRevOffsets2().clear();

		cp.setMgrFinalized(false);
		cp.setEngFinalized(false);


		return cp;
	}

	public SceProjRev copyToEmergent()throws SQLException{
		SceProjRev cp = copy();

		for(SceProjElemCost spec : cp.getSceProjElemCosts(CostStage.Type.Proposed))
			spec.setApprovedOd(null);

		cp.setEpefSubmitTs(Calendar.getInstance());

		cp.setEpefComment(null);
		//Added by BJS on 11/20 to handle App -> Emergent, should not be acknowledged
		cp.setEpefAckUserId(0); 
		cp.setEpefAckTs(null);
		cp.setEpefAppUserId(0);
		cp.setEpefAppByUserId(0);

		cp.setEpefResolution(0);
		cp.setEpefResolutionTs(null);

		cp.setEpefResolutionNote(null);

		return cp;
	}

	public SceProjRev copy()throws SQLException{
		SceProjRev cp = super.copy();
		cp.setEpefNum(null);
		cp.setRevTs(Calendar.getInstance());
		return cp;
	}

	public int compareTo(Object o){
		if(o == this)
			return 0;
		if(o instanceof SceProjRev){
			SceProjRev rev = (SceProjRev)o;
			if(getRevTs().compareTo(rev.getRevTs()) > 0)
				return -1;
			if(getRevTs().compareTo(rev.getRevTs()) < 0)
				return 1;
			if(getSceProjRevId() == 0)
				return -1;
			if(rev.getSceProjRevId() == 0)
				return 1;
			if(getSceProjRevId() > rev.getSceProjRevId())
				return -1;
			if(getSceProjRevId() < rev.getSceProjRevId())
				return 1;
		}
		return super.compareTo(o);
	}

	public void setEpefAckUser(User user) throws SQLException {
		if(user == null)
			setEpefAckUserId(0);
		else
			setEpefAckUserId(user.getUsernameId());
	}

	public User getEpefAckUser() throws SQLException {
		return User.getInstance(getEpefAckUserId());
	}

	/**
	 * 
	 * @return
	 * @throws SQLException
	 */
	public int getTotalCost(CostStage.Type costType) throws SQLException {
		int totalCost=0;
		for(SceProjElemCost spec : getSceProjElemCosts(costType))
			if(spec.isEnabled())
				totalCost += spec.getTotalCost();
		return totalCost; 
	}
	public int getSubTotalCost(CostStage.Type costType) throws SQLException {
		int totalCost=0;
		for(SceProjElemCost spec : getSceProjElemCosts(costType))
			if(spec.isEnabled())
				totalCost += spec.getSubTotalCost();
		return totalCost; 
	}

	public int getTotalCost(CostStage.Type costType, int year) throws SQLException {
		int totalCost=0;
		int curYear = Calendar.getInstance().get(Calendar.YEAR);
		for(SceProjElemCost spec : getSceProjElemCosts(costType)){

			if((spec.isEnabledBl() || year < curYear))
				totalCost+=spec.getCost(year);
		}
		return totalCost;
	}

	public int getDeltaTotalCost() throws SQLException {
		return getDeltaTotalCost(CostStage.Type.Proposed,CostStage.Type.Approved);
	}

	public int getDeltaTotalCost(CostStage.Type from, CostStage.Type to) throws SQLException {
		return getTotalCost(from)-getTotalCost(to);
	}

	/**
	 * Doesn't matter if CostElement isEnabledBl()
	 * 
	 * @return
	 * @throws SQLException
	 */
	public int getPriorCost(CostStage.Type costType)throws SQLException{
		int prior=0;
		for(SceProjElemCost spec : getSceProjElemCosts(costType))
			prior+=spec.getPriorCost();
		return prior;
	}

	/**
	 * IsEnabled took over isActive
	 * @return boolean
	 */
	public boolean isEnabled() {
		return isActive();
	}

	/**
	 * IsEnabled took over isActive
	 * @throws SQLException 
	 * 
	 */
	public void setEnabled(boolean v) throws SQLException {
		setActive(v);
	}

	/**
	 * Gets the Basic Project Status: Aborted, Cancel, Complete, or Active
	 * 
	 * @return int
	 */
	public int getProjectStatus(){
		return getProjStatus(null);
	}

	public int getProjStatus(SceProjRev rev){
		try {
			int status = getProjStatusActiveDetails(rev);
			if(!isEnabledBl()){
				if(status == NEW)
					return ABORTED;
				return CANCELLED;
			}

			if(getInServiceDate() == null || getInServiceDate().getTimeInMillis() > Calendar.getInstance().getTimeInMillis())
				return ACTIVE_STATUS;
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return COMPLETE;
	}

	public int getProjStatusFull() throws SQLException{
		return getProjStatusFull(null);
	}

	/**
	 * Returns the Project Status: Aborted, Cancel, Complete, New, Revised, No Change (w/o active details)
	 * @return int
	 * @throws SQLException
	 */
	public int getProjStatusFull(SceProjRev rev) throws SQLException{
		switch(getProjStatus(rev)){
			case ABORTED: return ABORTED;
			case CANCELLED: return CANCELLED;
			case COMPLETE: return COMPLETE;
			default: return getProjStatusActiveDetails(rev);
		}
	}

	/** Gets the Active Project Status:  New, No Change, Revised OD, Revised User Forced, Revised Scope
	 * 
	 * @return int
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getProjStatusActiveDetails() throws SQLException{
		return getProjStatusActiveDetails(null);
	}
	public int getProjStatusActiveDetails(SceProjRev rev) throws SQLException{
		SceProjRev prevProj = rev!=null?rev:getPrevRev(APPROVED);
		if(prevProj != null){
			int rc=0;
			if(getModelDate()!=null && !getModelDate().equals(prevProj.getModelDate()))
				rc |= OD_CHANGED;
			if(isForceRevStatus())
				rc |= USER_FORCED;
			if(rc == 0)
				return NO_CHANGE;
			return rc;
		}
		return NEW;
	}

	public String getProjStatusName() throws SQLException{
		return getProjStatusName(null);
	}


	public String getProjStatusLetter(SceProjRev rev) throws SQLException{
		switch(getProjStatus(rev)){
			case ABORTED: return "Aborted";
			case CANCELLED: return "Cancelled";
		}
		int ps = getProjStatusActiveDetails(rev);
		switch(ps){
			case NEW: return "New";
			case NO_CHANGE: return "No Change";
			case REVISED: return "Revised";
		}
		if((ps & REVISED) > 0)
			return "Revised";
		return "New";
	}

	public String getProjStatusName(SceProjRev rev) throws SQLException{
		int sf = getProjStatusFull(rev);
		switch(sf){
			case ABORTED: return "Aborted";
			case NEW: return STATUS_TEXT[0];
			case CANCELLED: return STATUS_TEXT[1];
			case NO_CHANGE: return STATUS_TEXT[2];
			case COMPLETE: return STATUS_TEXT[4];
		}
		String status = "";
		if((sf & OD_CHANGED) > 0)
			status += "Date";
		if((sf & SCOPE_CHANGED) > 0)
			status += (status.length()>0?", ":"") + "Scope";
		if((sf & USER_FORCED) > 0)
			status += (status.length()>0?", ":"") + "User";
		return "Revised ("+status+")";
	}

	/**
	 * Method for isForceRevStatus ComboBox
	 * @return String Yes or No
	 */
	public String getForceRevStatusStr(){
		if(isForceRevStatus())
			return "Yes";
		return "No";
	}

	/**
	 * Method for isInactive ComboBox
	 * @return String Yes or No
	 */
	public String getEnabled(){
		if(isEnabled())
			return "Yes";
		return "No";
	}

	public Color getProjStatusColor() throws SQLException{
		switch(getProjectStatus()){
			case ABORTED: return Color.MAGENTA;
			case CANCELLED: return Color.RED;
			case COMPLETE: return Color.BLUE;
			case ACTIVE_STATUS: return null;
		}
		return null;
	}

	/**
	 * 
	 * @return String Deleted, Approved, Emergent, or Prelim
	 */
	public String getIWPStatusName() {
		if(isDeleted())
			return REV_STATUS_DELETE;

		switch(getIWPState()){
			case DENIED: return REV_STATUS_DENIED; 
			case APPROVED:
				if(getProjectStatus()==CANCELLED)
					return REV_STATUS_APP_CANCEL;
				return REV_STATUS_APP;
			case EMERGENT: return REV_STATUS_EMERGENT;
			case RETRACTED: return REV_STATUS_RETRACT;
		}

		return REV_STATUS_CONCEPTUAL;		
	}

	/**
	 * Shows an icon based on the current and previous status
	 * for the SceProjRev - version history.
	 * @return an <code>Icon</code>
	 * @throws SQLException
	 */
	public Icon getIcon() throws SQLException {
		if(getSceProj()!=null && getSceProj().isDeleted())
			return IconsFactory.getImageIcon(IconsFactory.Frame.DELETE);

		if(isDeleted())
			return IconsFactory.getImageIcon(IconsFactory.Frame.DELETE);
		//APPROVED
		else if(isApproved()){
			//if has E in future overlay E: eA
			if(getPrevRev(SceProjRev.EMERGENT)!=null)
				return IconsFactory.getOverlayIcon(null, 
						IconsFactory.SPI_APPROVED, 
						IconsFactory.SPI_EMERGENT_OVERLAY,
						8, 
						IconsFactory.SPI_APPROVED.getIconHeight()-8);

			else if(!isActive())
				return IconsFactory.SPI_APPROVED_CANCEL;

			return IconsFactory.SPI_APPROVED;
		}

		//DENIED
		else if(isDenied())
			return IconsFactory.SPI_DENY;

		//Retracted - needs to be ahead of retract requested
		else if(isRetracted())
			return IconsFactory.SPI_RETRACTED;

		//Retract Requested
		else if(isRetractRequested()){
			return IconsFactory.getOverlayIcon(null, 
					IconsFactory.SPI_EMERGENT, 
					IconsFactory.SPI_RETRACTED_OVERLAY, 
					8, 
					IconsFactory.SPI_EMERGENT.getIconHeight()-8);
		}

		//EMERGENT
		else if(isEmergent()){
			//if has A in history overlay A: Ea
			if(getPrevRev(SceProjRev.APPROVED)!=null)
				return IconsFactory.getOverlayIcon(null, 
						IconsFactory.SPI_EMERGENT, 
						IconsFactory.SPI_APPROVED_OVERLAY, 
						8, 
						IconsFactory.SPI_EMERGENT.getIconHeight()-8);
			return IconsFactory.SPI_EMERGENT;
		}

		//PRELIM
		//if has A in history overlay A: aP	
		//if has A followed by E in history overlay AE: aeP
		if(getPrevRev(SceProjRev.APPROVED)!=null){

			return IconsFactory.getOverlayIcon(null, 
					IconsFactory.SPI_PRELIM, 
					IconsFactory.SPI_APPROVED_OVERLAY, 
					8, 
					IconsFactory.SPI_PRELIM.getIconHeight()-8);
		}
		//if has E in history overlay E: eP
		if(getPrevRev(SceProjRev.EMERGENT)!=null){
			return IconsFactory.getOverlayIcon(null, 
					IconsFactory.SPI_PRELIM, 
					IconsFactory.SPI_EMERGENT_OVERLAY, 
					8, 
					IconsFactory.SPI_PRELIM.getIconHeight()-8);
		}
		return IconsFactory.SPI_PRELIM;
	}

	public void setEpefSubmitUser(User activeUser) throws SQLException {
		if(activeUser == null)
			setEpefSubmitUserId(0);
		setEpefSubmitUserId(activeUser.getUsernameId());

	}

	public User getEpefSubmitUser() throws SQLException {
		return User.getInstance(getEpefSubmitUserId());
	}

	public int getRevNo() throws SQLException {
		if(getSceProj() != null){
			int i = getSceProj().getSceProjRevs().size()-1;
			for(SceProjRev spr : getSceProj().getSceProjRevs()){
				if(spr == this)
					return i;
				i--;
			}
		}
		return -1;
	}

	String pendingRevNums;
	public String getPendingRevNums() throws SQLException {
		if(pendingRevNums == null) {
			if(getSceProj() != null){
				StringBuffer sb = new StringBuffer();
				int i = getSceProj().getSceProjRevs().size()-1;
				for(SceProjRev spr : getSceProj().getSceProjRevs()){
					if(spr == this) {
						pendingRevNums = sb.toString();
						break;
					}
					if(spr.getSimId() == 0) {
						if(sb.length() > 0)
							sb.append(", ");
						sb.append("("+i+" "+spr.getIWPStatusName()+")");
					}
					i--;
				}
			}
		}
		return pendingRevNums;
	}

	public int getBaseyear() throws SQLException {
		if(getCalendarYear()-5 < Calendar.getInstance().get(Calendar.YEAR))
			return Calendar.getInstance().get(Calendar.YEAR);
		return getCalendarYear()-5;
	}

	public String getPriority() throws SQLException{
		String out = "";
		TreeSet<String> ps = new TreeSet<String>();
		for(SceProjElemCost spec : getSceProjElemCosts(CostStage.Type.Proposed))
			for(SceProjElemPriority p: spec.getCurrentSceProjElemPrioritys())
				ps.add(p.getYear()+"-"+p.getPriority());
		for(String l: ps){
			if(out.length()>0)
				out += ", "+l;
			else
				out = ""+l;
		}
		return out;
	}

	public Calendar getEpefTrackingSentTsBl() {
		if(getEpefTrackingSentTs()==null)
			return getEpefAckTs();
		return super.getEpefTrackingSentTs();
	}

	public void setAcknowledged(boolean b) throws SQLException {
		if(b){
			this.setEpefAckTs(Calendar.getInstance());
			this.setEpefAckUser(User.getActiveUser());
		}else{
			this.setEpefAckTs(null);
			this.setEpefAckUser(null);
		}
	}

	public Org getEngSchOrg() throws SQLException {		
		return getOrg3();
	}
	public void setEngSchOrg(Org org) throws SQLException {
		setOrg3(org);
	}

	public User getEngSchUser() throws SQLException{
		return User.getInstance(getEngSchUserId());
	}

	public void setEngSchUser(User user) throws SQLException{
		if(user==null)
			setEngSchUserId(0);
		else
			setEngSchUserId(user.getUsernameId());
	}

	public TreeSet<Integer> getYearsWithCost() throws SQLException {
		TreeSet<Integer> years = new TreeSet<Integer>();
		for(SceProjElemCost pec:getSceProjElemCosts()){
			if(pec.isUseUnitCost()){
				for(ScopeItem si:pec.getScopeItems())
					if(si.isEnabledBl())
						years.addAll(si.getYearsWithCost());
			}else{
				for(SceProjElemCostYear pecy:pec.getSceProjElemCostYears()){
					if(pecy.getCost()>0)
						years.add(pecy.getYear());
				}
			}
		}
		return years;
	}

	public User getRetractReqUser() throws SQLException {
		return User.getInstance(getRetractReqUserId());
	}

	public void setRetractReqUser(User user) throws SQLException {
		if(user == null)
			setRetractReqUserId(0);
		else
			setRetractReqUserId(user.getUsernameId());
	}

	/**
	 * Inserts a Zero (0) Priority for all Current SceProjElemCost via a copy of the existing SceProjElemPriority
	 * @return true is success, false if none exist
	 * @throws SQLException 
	 */
	public boolean clearPriorities() throws SQLException {
		boolean success = false;
		for(SceProjElemCost spec: getSceProjElemCosts(CostStage.Type.Proposed)){
			for(SceProjElemPriority spep: spec.getCurrentSceProjElemPrioritys()){
				SceProjElemPriority spepCopy = spep.copy();		
				spepCopy.setPriorityTs(Calendar.getInstance());
				spepCopy.insert();
				spepCopy.setPriority(0);	
				spepCopy.setPriorityUser(User.getActiveUser());
			}
		}
		return success;
	}

	/**
	 * Clears approves cost and sets approved to proposed
	 * @param option 
	 * @param sceProjRev 
	 * @return true is success, false if none exist
	 * @throws SQLException
	 */
	public boolean setApprovedCost(SceProjRev sceProjRev, boolean copyApp) throws SQLException {
		//Do not clear approved if no proposed exist 

		//Clear Approved costs
		for(SceProjElemCost spec : new Vector<SceProjElemCost>(getSceProjElemCosts(CostStage.Type.Approved)))
			spec.delete();

		//Create Approved from Proposed
		for(SceProjElemCost spec: copyApp?sceProjRev.getSceProjElemCosts(CostStage.Type.Approved):sceProjRev.getSceProjElemCosts(CostStage.Type.Proposed)){
			// this copy is problematic if the proposed cost element uses default scope and a default title
			// The approved cost element text is empty -HiK 2/2012
			SceProjElemCost aSpec = spec.copy();
			aSpec.setSceProjRevId(getSceProjRevId());
			aSpec.setCostStageId(CostStage.APPROVED);

			//If sc.isUseDefaultScope() is true, elements do not display correctly on approved cost tab
			for(ScopeItem sc: aSpec.getScopeItems()){
				if(sc != null && sc.isUseDefaultScope()){
					sc.setUseDefaultScope(false);
				}
			}

			aSpec.getSceProjElemPrioritys().clear();
			aSpec.getScopeItems().clear();
			// if the following is not done to the approved cost element, proposed cost elements using
			// default description will be blank.  -HiK 2/2012
			aSpec.setScope(spec.getScope());
			aSpec.setUseDefaultScope(false);

			//Disables approved costs, since items are cancelled
			if(!sceProjRev.isEnabled() || !spec.isEnabled())
				aSpec.setEnabled(false);

			//Since scope items are cleared, using default scope becomes and empty string.
			//This forces new spec to use previous (proposed) scope description
			if(spec.isUseDefaultScope()){
				aSpec.setUseDefaultScope(false);

				if(spec.getScopeDesc() != null && spec.getScopeDesc().length() > 0)
					aSpec.setScope(spec.getScopeDesc());
			}

			aSpec.getSceProjElemCostYears().clear();
			aSpec.insert();
			for(int y : getYearsWithCost())
				aSpec.setCost(y, spec.getCost(y));
		}
		return true;
	}

	/**
	 * Arch. allows multiple elem costs and priorities, this method returns the most recent (current) only
	 * @return collection of Current SceProjElemPriority
	 * @throws SQLException
	 */
	public TreeSet<SceProjElemPriority> getCurrentSceProjElemPriorities() throws SQLException{
		TreeSet<SceProjElemPriority> speps  = new TreeSet<SceProjElemPriority>();
		for(SceProjElemCost spec: getSceProjElemCosts(CostStage.Type.Proposed)){
			speps.addAll(spec.getCurrentSceProjElemPrioritys());
		}
		return speps;
	}

	public Org getPmoOrg() throws SQLException {		
		return getOrg2();
	}
	public void setPmoOrg(Org org) throws SQLException {
		setOrg2(org);
	}

	/**
	 * Returns the need date
	 */
	public Calendar getNeedDate() throws SQLException{
		Calendar max = null;
		for(SceProjElemCost spec : getSceProjElemCosts(CostStage.Type.Proposed))
			if(spec.getNeedDate()!=null && (max==null || spec.getNeedDate().getTimeInMillis()>max.getTimeInMillis()))
				max = spec.getNeedDate();
		return max;
	}

	/**
	 * This method is used to return In-service Date, Operating Date and Need Date in that order based
	 * on its existence in a project revision. This method should be used to gather project for planning.
	 * It should not be used to determine a project's operating date or to populate the to/from year
	 * on a project report.
	 * 
	 */
	public Calendar getModelDate() throws SQLException{
		if(getInServiceDate() != null)
			return getInServiceDate();
		if(getOpDate() != null)
			return getOpDate();
		return getNeedDate();
	}

	public int getCalendarYear() throws SQLException{
		if(getModelDate()!=null)
			return getModelDate().get(Calendar.YEAR);
		return 0;
	}

	/**
	/* Returns the Calendar year of project completion based on modelDateType passed in as a parameter. This method should be used in 
	 * cases when one is attempting to get the to and from years of a project based on a specific model date.
	 * TO/FROM ND is to determine changes to sponsors system need date to a project
	 * TO/FROM OD is the determine changes to project execution based on feasibility or executing groups direction.
	 * 
	 *@param modeDateType the calendar year based on the project need date, operating date or in-service date
	 *@return the 4 digit year as an integer
	 */

	public int getCalendarYear(SceProjRev.ModelDateType modelDateType) throws SQLException{

		if(modelDateType==ModelDateType.NEED_DATE && getNeedDate() != null)
			return getNeedDate().get(Calendar.YEAR);
		if(modelDateType==ModelDateType.OPERATING_DATE && getOpDate() !=null)
			return getOpDate().get(Calendar.YEAR);
		if(modelDateType==ModelDateType.IN_SERVICE_DATE && getInServiceDate()!=null)
			return getInServiceDate().get(Calendar.YEAR);
		return 0;
	}

	public int getPeakYear(int planyear) throws SQLException{
		return Department.getEffYear(planyear, getModelDate());
	}

	/**
	/* Returns the Peak year based on modelDateType passed in as a parameter. This method should be used in 
	 * cases when one is attempting to get the to and from years of a project based on a specific model date.
	 * TO/FROM ND is to determine changes to sponsors system need date to a project
	 * TO/FROM OD is to determine changes to project execution based on feasibility or executing groups direction.
	 * 
	 *@param modeDateType the peak year based on the project need date, operating date or in-service date
	 *@return the 4 digit year as an integer
	 */

	public int getPeakYear(int planyear, ModelDateType modelDateType) throws SQLException{
		// Change int to enumerations
		if (modelDateType==ModelDateType.NEED_DATE  )
			return Department.getEffYear(planyear, getNeedDate());

		if (modelDateType==ModelDateType.OPERATING_DATE&& getOpDate()!=null)
			return Department.getEffYear(planyear, getOpDate());

		if(modelDateType==ModelDateType.IN_SERVICE_DATE && getInServiceDate()!=null)
			return Department.getEffYear(planyear, getInServiceDate());

		return 0;
	}


	public int getFiscalYear() throws SQLException{
		if(getModelDate()!=null)
			return getModelDate().get(Calendar.YEAR);
		return 0;
	}

	public void setNeedDate(Calendar proposedOd, boolean escalate)throws SQLException{
		Collection<SceProjElemCost> curCosts = getSceProjElemCosts(CostStage.Type.Proposed);
		if(curCosts.size() > 0)
			for(SceProjElemCost spec:curCosts)
				spec.setProposedOd(proposedOd,escalate);
		else
			setProposedOdWAuto(proposedOd);
	}

	public Calendar getPrelimDate() throws SQLException{
		Calendar max = null;
		for(SceProjElemCost spec : getSceProjElemCosts(CostStage.Type.Proposed)){
			Calendar date=spec.getPrelimDate();
			if(date!=null && (max==null || date.getTimeInMillis()>max.getTimeInMillis()))
				max = date;
		}
		return max;
	}

	/**
	 * Returns the approvedOd
	 * @return The approvedOd
	 * @throws SQLException 
	 */
	public Calendar getOpDate() throws SQLException{
		Calendar max = null;
		for(SceProjElemCost spec : getSceProjElemCosts(CostStage.Type.Proposed))
			if(spec.getOpDate()!=null && (max==null || spec.getOpDate().getTimeInMillis()>max.getTimeInMillis()))
				max = spec.getOpDate();
		return max;
	}

	/**
	 * Sets the approvedOd
	 * @param The new approvedOd
	 */

	//	public void setOpDate(Calendar approvedOd)throws SQLException{
	//		for(SceProjElemCost spec : getSceProjElemCosts(CostStage.Type.Proposed))
	//			spec.setApprovedOd(approvedOd);
	//	}

	public void setOpDate(Calendar approvedOd)throws SQLException{
		for(SceProjElemCost spec : getSceProjElemCosts(CostStage.Type.Proposed))
			spec.setApprovedOd(approvedOd);
	}

	public void setOpDate(Calendar approvedOd, boolean escalate)throws SQLException{
		for(SceProjElemCost spec : getSceProjElemCosts(CostStage.Type.Proposed))
			spec.setApprovedOd(approvedOd,escalate);
	}

	public String getCoTypeString(int planyear) throws SQLException {
		String out = "";
		for(FacilityObject co: getFacilities(planyear)){
			if(out.length()>0)
				out += ", "+co.getCoType();
			else if(co.getCoType() != null)
				out = ""+co.getCoType();
		}
		return out;
	}

	public String getCoreObjectString(int planyear) throws SQLException {
		String out = "";
		for(FacilityObject co: getFacilities(planyear)){
			if(co!=null){
				if(out.length()>0)
					out += ", ";
				out += co;
			}
		}
		return out;
	}

	/**
	 * 
	 * @return previous <code>SceProjRev</code>
	 * @throws SQLException
	 */
	public SceProjRev getPrevRev() throws SQLException{
		if(getSceProj()!=null && getSceProj().getSceProjRevs().contains(this)){
			TreeSet<SceProjRev> set = new TreeSet<SceProjRev>(getSceProj().getSceProjRevs());
			if(set.last()!= this){
				Iterator<SceProjRev> i = set.tailSet(this).iterator();
				i.next();
				return i.next();
			}
		}
		return null;
	}

	/**
	 * 
	 * @param allowedState
	 * @return previous <code>SceProjRev</code>
	 * @throws SQLException
	 */
	public SceProjRev getPrevRev(int allowedState) throws SQLException{
		if(getSceProj()!=null && getSceProj().getSceProjRevs().contains(this)){
			TreeSet<SceProjRev> set = new TreeSet<SceProjRev>(getSceProj().getSceProjRevs());
			if(set.last()!= this){
				for(SceProjRev rev:set.tailSet(this))
					if((rev.getIWPState() & allowedState) > 0)
						return rev;
			}
		}
		return null;
	}

	public String getRegionString(int planyear) throws SQLException{
		String out = "";
		for(FacilityObject co: getFacilities(planyear)){
			if(co!=null){
				if(out.length()>0)
					out += ", ";
				out = ""+co.getRegions(0);//FIXME 2.3
			}
		}
		return out;
	}

	public TreeSet<FacilityObject> getFacilities(int planyear) throws SQLException{
		TreeSet<FacilityObject> cos = new TreeSet<FacilityObject>();
		for(SceProjElemCost pec:getSceProjElemCosts()){
			FacilityObject co = pec.getFacilityObject(planyear);
			if(co != null)
				cos.add(co);
		}
		return cos;
	}

	/**
	 * TODO IWP Remove after DB update for EPEF_COMMENT field size
	 * 
	 * Returns the epefComment
	 * @return The epefComment
	 */
	public String getEpefComment(){
		if(super.getEpefComment() == null)
			return null;
		return super.getEpefComment() + (getEpefComment2()!=null?getEpefComment2():"");
	}

	/**
	 * TODO IWP Remove after DB update for EPEF_COMMENT field size
	 * 
	 * Sets the epefComment
	 * @param The new epefComment
	 */
	public void setEpefComment(String epefComment)throws SQLException{
		if(epefComment == null){
			super.setEpefComment(null);
			setEpefComment2(null);
		}
		else if(epefComment.length()>EPEFCOMMENT_LIMIT){
			super.setEpefComment(epefComment.substring(0, EPEFCOMMENT_LIMIT));
			setEpefComment2(epefComment.substring(EPEFCOMMENT_LIMIT));
		}else{
			super.setEpefComment(epefComment);
			setEpefComment2(null);
		}
	}

	public boolean isCurRev(int planyear, int simId) throws SQLException {
		if(getSceProj() == null)
			return true;
		else
			return  getSceProj().getCurRev(planyear,simId) == this;
	}

	public boolean isCurRev(Calendar asOf) throws SQLException{
		if(getSceProj() == null)
			return true;
		return getSceProj().getCurRev(asOf) == this;
	}

	public TreeSet<ScopeItem> getScopeItemSummary(int planyear) throws SQLException{
		return getScopeItemSummary(planyear,false);
	}

	/**
	 * Returns a collection of temporary <code>ScopeItem</code> objects
	 * that can be utilized to summarize the scope of a project.  The
	 * scope item are distinguished by scope type and facility.  This method 
	 * is used in the summary panel and default title.
	 * 
	 * @parameter int planyear - four digit plan year
	 * @parameter boolean disableScopeItems - To return scope items on disabled projects (Cancelled) set to true. 
	 * 
	 * @return fake <code>ScopeItem</code> objects
	 * @throws SQLException
	 */

	public TreeSet<ScopeItem> getScopeItemSummary(int planyear, boolean disabledScopeItems) throws SQLException{		

		Hashtable<String,ScopeItem> hash = new Hashtable<String,ScopeItem>();
		int c = 0;
		for(SceProjElemCost pec : getSceProjElemCosts()){
			for(ScopeItem si: pec.getScopeItems()){
				if(si.isEnabledBl()||disabledScopeItems){
					String key = getHashKey(new Object[]{si.getScopeTypeId(), pec.getCoTypeId(), pec.getFacilityId()});
					//derive a unique scope item based on SI and facility
					ScopeItem temp = hash.get(key);
					if(temp == null){
						temp = new ScopeItem(c++);
						temp.setScopeTypeId(si.getScopeTypeId());
						temp.setQuantity(0); //Do not need default quantity
						if(pec.getFacilityObject(planyear)!=null){
							temp.setFacilityObject(pec.getFacilityObject(planyear));

							//==============================
							temp.setScopeSummaryIdentifier(key);
							//==============================
							//store temporary scope items unique by facilty and scope type
							hash.put(key, temp);
						}else{
							//System.out.println(" null pec FO: "+pec + " "+planyear);
						}
					}
					//add up total quantities
					//TODO IWP finish math for summary table, no bank PLL/ELL, get last Sub PLL,ELL,N-1
					temp.setQuantity(temp.getQuantity() + si.getQuantityBl(planyear));
				}
			}
		}
		return new TreeSet<ScopeItem>(hash.values());
	}

	public Calendar getInServiceDate() throws SQLException{
		Calendar max = null;
		for(SceProjElemCost spec : getSceProjElemCosts(CostStage.Type.Proposed)){
			if(spec.getInServiceDate() == null)
				return null;
			if((max==null || spec.getInServiceDate().getTimeInMillis()>max.getTimeInMillis())){

				max = spec.getInServiceDate();
			}
		}
		return max;
	}

	/**
	 * XXX enable/disable
	 * Auto-inserts proj elem cost of none are assigned.
	 * 
	 * @param proposedOd
	 * @throws SQLException
	 */
	public void setProposedOdWAuto(Calendar proposedOd)throws SQLException{
		Collection<SceProjElemCost> curCosts = getSceProjElemCosts(CostStage.Type.Proposed);
		if(curCosts.size() > 0)
			for(SceProjElemCost spec:curCosts)
				spec.setNeedDate(proposedOd);
		else{
			try {
				throw new Exception("Trace me");
			} catch (Exception e) {
				e.printStackTrace();
			}

			SceProjElemCost spec = new SceProjElemCost();
			spec.setSceElemId(SceElem.OTHER);
			spec.setCostStageId(CostStage.PLAN_EST);
			spec.setEnabled(true);
			spec.setTitle("Auto Created");
			spec.setScope("Auto created for operating date. To be replaced with real costs in the future");
			spec.setNeedDate(proposedOd);
			addSceProjElemCost(spec);
		}
	}

	/**
	 * 
	 *
	 * 
	 * Auto-creates a proj elem cost if none are assigned.
	 * 
	 * @param inServiceDate
	 * @throws SQLException
	 */
	public void setInServiceDate(Calendar inServiceDate, boolean autoCreate)throws SQLException{
		Collection<SceProjElemCost> curCosts = getSceProjElemCosts(CostStage.Type.Proposed);
		if(curCosts.size() > 0)
			for(SceProjElemCost spec:curCosts)
				spec.setInServiceDate(inServiceDate);
		else{			
			SceProjElemCost spec = new SceProjElemCost();
			spec.setSceElemId(SceElem.OTHER);
			spec.setCostStageId(CostStage.PLAN_EST);
			spec.setEnabled(true);
			spec.setTitle("Auto Created");
			spec.setScope("Auto created for operating date. To be replaced with real costs in the future");
			spec.setInServiceDate(inServiceDate);
			addSceProjElemCost(spec);
		}
	}


	/**
	 * Not to be confused with isActive for archeiving
	 * @return
	 * @throws SQLException
	 */
	public boolean isActiveBl(int planyear, int simId) throws SQLException {
		return isEnabledBl() && isCurRev(planyear, simId);
	}

	/**
	 * What the fuck does Bl mean?
	 * @return
	 * @throws SQLException
	 */
	public boolean isEnabledBl()  throws SQLException {
		return isEnabled();
	}

	/**
	 * Checks if this project is a DSP, TSP, or MISC program
	 * @return boolean
	 */
	public boolean isDEProject() {
		if(getProgramId() == Program.DSP || getProgramId() == Program.TSP_ABANK || getProgramId() == Program.DSERP //|| getProgramId() == Program.MISC
				||	getProgramId() == Program.TSP_STL || getProgramId() == Program.TSP_STV || getProgramId() == Program.DSP_CLRP)
			return true;
		return false;
	}

	/**
	 * Gets the bad project flag.
	 * 
	 * @return the bad project flag
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getBadProjectFlag() throws SQLException{
		Flag flag = Flag.getInstance(Department.getActivePlanYear(), Flag.PROJ_BAD_FLAG);

		//TODO Not sure this flag can be done anymore
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() /*&& getCapAdd()>0*/ && isDEProject() && getProjectStatus() == ACTIVE_STATUS) { 

			//			double areaReserve = this.getSub().getYear(getSimId(),getOpYear()).getReserveNoProj(this);
			//			double areaPLL = getSub().getYear(getSimId(),getOpYear()).getPLLNoProj(this);
			//			//System.out.println("Y: "+getOpYear()+" AT: "+getSub()+" R: "+areaReserve+ " PLL: "+areaPLL);

			//			if(getSub() instanceof Bbank){
			//			for(BbankTie bt:((Bbank)getSub()).getActiveFromTies(getSimId())){
			//			if(bt.getStrength().equals(BbankTie.STRONG))
			//			//System.out.println("Y: "+getOpYear()+" From: "+bt.getToSub()+" R: "+bt.getToSub().getYear(getSimId(),getOpYear()).getReserveNoProj(this)+ " PLL: "+bt.getToSub().getYear(getSimId(),getOpYear()).getPLLNoProj(this));
			//			areaReserve += bt.getToSub().getYear(getSimId(),getOpYear()).getReserveNoProj(this);
			//			areaPLL += bt.getToSub().getYear(getSimId(),getOpYear()).getPLLNoProj(this);
			//			}
			//			for(BbankTie bt:((Bbank)getSub()).getActiveToTies(getSimId())){
			//			if(bt.getStrength().equals(BbankTie.STRONG))
			//			//System.out.println("Y: "+getOpYear()+" To: "+bt.getFromSub()+" R: "+bt.getFromSub().getYear(getSimId(),getOpYear()).getReserveNoProj(this)+ " PLL: "+bt.getFromSub().getYear(getSimId(),getOpYear()).getPLLNoProj(this));
			//			areaReserve += bt.getFromSub().getYear(getSimId(),getOpYear()).getReserveNoProj(this);
			//			areaPLL += bt.getFromSub().getYear(getSimId(),getOpYear()).getPLLNoProj(this);
			//			}
			//			}

			//			//System.out.println("Y: "+getOpYear()+" Area R: "+areaReserve+" Area PLL: "+areaPLL);
			//			if(areaReserve/areaPLL>flag.getValue())
			//			return flag.getFlagId();
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * the Total Project dollars < &value% in the year ahead.
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getYearAheadCostFlag() throws SQLException{
		Flag flag = Flag.getInstance(Department.getActivePlanYear(), Flag.PROJ_NO_PLAN_COST_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && isDEProject() && getProjectStatus() == ACTIVE_STATUS && isEnabledBl())
			if(getTotalCost(CostStage.Type.Proposed,getCalendarYear()-1) < getTotalCost(CostStage.Type.Proposed)*flag.getValue())
				return flag.getFlagId();
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * Total Project dollars <= &value.
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getTotalCostFlag() throws SQLException{
		Flag flag = Flag.getInstance(Department.getActivePlanYear(), Flag.PROJ_NO_COST_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && isCurRev(Department.getActivePlanYear(),getSimId()) && isDEProject() && getProjectStatus() == ACTIVE_STATUS && isEnabledBl() )
			if(getTotalCost(CostStage.Type.Proposed)<=flag.getValue())
				return flag.getFlagId();
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * Total Project dollars changed from the previous plan by greater than |&value%|.
	 * Flag applies only to active projects.
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getTotalCostDeltaFlag(int planyear) throws SQLException{
		Flag flag = Flag.getInstance(planyear, Flag.PROJ_COST_DELTA_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && isDEProject() && getProjectStatus() == NO_CHANGE && getProjectStatus() == ACTIVE_STATUS && isEnabledBl()) {
			SceProjRev prev = getPrevRev();
			if(prev!=null){
				int prevTot = prev.getTotalCost(CostStage.Type.Proposed);
				int currTot = getTotalCost(CostStage.Type.Proposed);
				if(prev!=null && prevTot!=0 && Math.abs((prevTot-currTot)/prevTot) > flag.getValue())
					return flag.getFlagId();
			}
		}
		return 0;
	}



	/**
	 * This function returns the flag id if the
	 * the Total Project dollars < &value% in the year of.
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */

	public int getYearOfCostFlag(int planyear) throws SQLException{
		Flag flag = Flag.getInstance(Department.getActivePlanYear(), Flag.PROJ_YEAR_OF_COST_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && isCurRev(planyear, getSimId()) && isDEProject() && getProjectStatus() == Proj.ACTIVE)
			for(SceProjElemCost spec: getSceProjElemCosts(CostStage.Type.Proposed)){
				if(spec.isActiveBl(planyear, getSimId()) && spec.getOpDatePassedFlag(planyear, getSimId())>0)								
					return flag.getFlagId();
			}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * 'PLL % changed from the previous plan and the project is not Revised status (variance greater than &value%).
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getPLLDeltaFlag() throws SQLException{
		Flag flag = Flag.getInstance(Department.getActivePlanYear(), Flag.PROJ_PLL_DELTA_FLAG);
		//TODO IWP Finish Flag
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && isDEProject() && getProjectStatus() == ACTIVE_STATUS) {
			//			SceProjRev prev = getPrevInstance();
			//			if(prev!=null && prev.getPllAdd()!=0 && Math.abs(getPllAdd()/prev.getPllAdd())-1 > flag.getValue()){
			//			return flag.getFlagId();
			//			}
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * 'ELL % changed from the previous plan and the project is not Revised status (variance greater than &value%).
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getELLDeltaFlag() throws SQLException{
		Flag flag = Flag.getInstance(Department.getActivePlanYear(), Flag.PROJ_ELL_DELTA_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && isDEProject() && getProjectStatus() == ACTIVE_STATUS && isEnabledBl()) {
			//TODO IWP Finish Flag
			//        	SceProjRev prev = getPrevInstance();
			//			if(prev!=null && prev.getEllAdd()!=0 && Math.abs(getEllAdd()/prev.getEllAdd())-1 > flag.getValue()){
			//			return flag.getFlagId();
			//			}
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * 'N1LL % changed from the previous plan and the project is not Revised status (variance greater than &value%).
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getN1DeltaFlag() throws SQLException{
		Flag flag = Flag.getInstance(Department.getActivePlanYear(), Flag.PROJ_N1_DELTA_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && isDEProject() && getProjectStatus() == ACTIVE_STATUS ) {

			//TODO IWP Finish Flag
			//			SceProjRev prev = getPrevInstance();
			//			if(prev!=null && prev.getN1Add()!=0 && Math.abs(getN1Add()/prev.getN1Add())-1 > flag.getValue()){
			//			return flag.getFlagId();
			//			}
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * Today greater than Need Date and the Actual Operating Date is not specified (variance &value days).
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getOpDatePassedFlag(int planyear) throws SQLException{
		Flag flag = Flag.getInstance(Department.getActivePlanYear(), Flag.PROJ_OP_DATE_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && isDEProject() && getProjectStatus() == SceProjRev.ACTIVE_STATUS && !isRetracted() ){

			for(SceProjElemCost spec:getSceProjElemCosts()){
				if(spec.isActiveBl(planyear, getSimId()) && spec.getOpDatePassedFlag(planyear, getSimId())>0){
					//	EspLogger.log(EspLogger.LEVEL.DEBUG, this, spec.getSceProjRev().getProjNum() +" " +  spec.getSceProjRev().getRevNo());
					return flag.getFlagId();
				}
			}
		}
		return 0;
	}


	/**
	 * This function returns the flag id if the
	 * Actual Operating Date is specified in the future (variance &value days).
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getFutureActOpDateFlag() throws SQLException{
		Flag flag = Flag.getInstance(Department.getActivePlanYear(), Flag.PROJ_ACT_OP_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()&& isDEProject() && getProjectStatus() == ACTIVE_STATUS) {
			Calendar today = Calculate.getCal();
			if(getInServiceDate()!=null && getInServiceDate().getTimeInMillis() > today.getTimeInMillis() + (flag.getValue() * 24 * 60 * 60 * 1000) ){
				return flag.getFlagId();
			}
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * Project contains an addition (capacity, circuit, or VAR) that is inconsistent with the Program.
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getAddInconsistentFlag() throws SQLException{
		Flag flag = Flag.getInstance(Department.getActivePlanYear(), Flag.PROJ_INCONSISTENT_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && isDEProject() && getProjectStatus() == ACTIVE_STATUS) {
			//TODO IWP Finish Flag
			//			if(getProgramId() == Prog.ABANK && getCktDelta()!=0){
			//			return flag.getFlagId();
			//			}else if((getProgramId() == Prog.STL || getProgramId() == Prog.STV ) && (getCapAdd()!=0 || getCktDelta()!=0)){
			//			return flag.getFlagId();
			//			}
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * Project contains a capacity addition with Impedance less than &value p.u.
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getZFlag() throws SQLException{
		Flag flag = Flag.getInstance(Department.getActivePlanYear(), Flag.PROJ_Z_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && isDEProject() && getProjectStatus() == ACTIVE_STATUS){
			//			if(getCapAdd()>0 && getCapAddZ()<flag.getValue())
			//			return flag.getFlagId();
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * The nameplate capacity exceeds a certain MVA
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getBbankNameplateExceedsFlag(int planyear) throws SQLException{
		Flag flag = Flag.getInstance(planyear, Flag.BBANK_NAMEPLATE_EXCEEDS_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && isDEProject() 
				&& getProjectStatus() == SceProjRev.ACTIVE_STATUS && !isRetracted() ){
			for(SceProjElemCost spec: getSceProjElemCosts())
				if(spec.getFacilityObject(planyear) instanceof Bbank && spec.getNameplatePost(Department.getActivePlanYear(), getSimId(), null) > flag.getValue())
					return flag.getFlagId();
		}
		return 0;
	}


	public boolean isEngFinalized(){
		return (getFinalized() & ENG_FINALIZED) > 0;
	}

	public void setEngFinalized(boolean finalized) throws SQLException{
		if(finalized)
			setFinalized(getFinalized() | ENG_FINALIZED); //set
		else
			setFinalized(getFinalized() & (-1^ENG_FINALIZED)); //reset
	}

	public boolean isMgrFinalized(){
		return (getFinalized() & MGR_FINALIZED) > 0;
	}

	public void setMgrFinalized(boolean finalized) throws SQLException{
		if(finalized)
			setFinalized(getFinalized() | MGR_FINALIZED); //set
		else
			setFinalized(getFinalized() & (-1^MGR_FINALIZED)); //reset
	}


	public TreeSet<Referee> getFlags(int simId) throws SQLException{
		TreeSet<Referee> flags = new TreeSet<Referee>(); //super.getFlags(simId);


		//TODO IWP Finish Flags

		//			int flagId = getBadProjectFlag();		
		//				if(flagId > 0)
		//					flags.add(new Referee(this,Flag.getInstance(getPlanYear(), flagId)));

		//				int flagId = getYearAheadCostFlag();		
		//				if(flagId > 0)
		//					flags.add(new Referee(this,Flag.getInstance(getPlanYear(), flagId)));
		//
		//				flagId = getTotalCostFlag();		
		//				if(flagId > 0)
		//					flags.add(new Referee(this,Flag.getInstance(getPlanYear(), flagId)));
		//
		//				flagId = getTotalCostDeltaFlag();		
		//				if(flagId > 0)
		//					flags.add(new Referee(this,Flag.getInstance(getPlanYear(), flagId)));
		//
		//				flagId = getYearOfCostFlag();		
		//				if(flagId > 0)
		//					flags.add(new Referee(this,Flag.getInstance(getPlanYear(), flagId)));

		//		int flagId = getPLLDeltaFlag();		
		//		if(flagId > 0)
		//			flags.add(new Referee(this,Flag.getInstance(getPlanYear(), flagId)));

		//		int flagId = getELLDeltaFlag();		
		//		if(flagId > 0)
		//			flags.add(new Referee(this,Flag.getInstance(getPlanYear(), flagId)));

		//		int flagId = getN1DeltaFlag();		
		//		if(flagId > 0)
		//			flags.add(new Referee(this,Flag.getInstance(getPlanYear(), flagId)));

		//		int flagId = getOpDatePassedFlag();		
		//		if(flagId > 0)
		//			flags.add(new Referee(this,Flag.getInstance(getPlanYear(), flagId)));

		//		int flagId = getFutureActOpDateFlag();		
		//		if(flagId > 0)
		//			flags.add(new Referee(this,Flag.getInstance(getPlanYear(), flagId)));

		//		int flagId = getAddInconsistentFlag();		
		//		if(flagId > 0)
		//			flags.add(new Referee(this,Flag.getInstance(getPlanYear(), flagId)));

		//		int flagId = getZFlag();		
		//		if(flagId > 0)
		//			flags.add(new Referee(this,Flag.getInstance(getPlanYear(), flagId)));

		for(SceProjElemCost pec: getSceProjElemCosts())
			flags.addAll(pec.getFlags(simId));

		return flags;		
	}	

	/**
	 * Uses the <code>User</code> Plan Year.
	 * @return selected plan year - User.getActiveUser().getPlanyear()
	 * @throws SQLException 
	 */
	public int getPlanYear() throws SQLException{
		if(getRevTs()!=null)
			return Department.getPlanYear(getRevTs());
		return Department.getPlanYear(this.getInsertTs());
	}

	/**
	 * Pre project?
	 * 
	 * Counts scope items transformer addition/removals
	 * 
	 * @return the total quantity in MVA
	 * @throws SQLException
	 */
	public double getCapacityAddition(int planyear) throws SQLException{
		double count = 0;		
		TreeSet<ScopeItem> sis = getScopeItemSummary(planyear);
		for(ScopeItem si: sis){
			ScopeType st = si.getScopeType();
			if(st.getModelingCoTypeId() == CoType.TRANSFORMER)
				count+=si.getQuantityBl(planyear)*st.getDefaultQuantity();
		}
		return count;
	}

	/**
	 * Returns the total xfmr nameplate before the project.
	 * 
	 * @param planyear
	 * @param simId
	 * @return
	 * @throws SQLException
	 */
	public double getNameplatePre(int planyear,int simId)throws SQLException{
		SceProjElemCost pc = new TreeSet<SceProjElemCost>(getSceProjElemCosts()).first();
		if(pc != null)
			return pc.getNameplatePre(planyear, simId);
		return 0;
	}

	/**
	 * Returns the total xfmr nameplate after the project.
	 * 
	 * @param planyear
	 * @param simId
	 * @param without
	 * @return
	 * @throws SQLException
	 */
	public double getNameplatePost(int planyear,int simId,TreeSet<SceProjElemCost> without)throws SQLException{
		SceProjElemCost pc = new TreeSet<SceProjElemCost>(getSceProjElemCosts()).last();
		if(pc != null)
			return pc.getNameplatePost(planyear, simId, without);
		return 0;
	}

	public TreeSet<Ckt> getCktsPre(int planyear,int simId, Collection<SceProjElemCost> without)throws SQLException{
		SceProjElemCost pc = new TreeSet<SceProjElemCost>(getSceProjElemCosts()).first();
		if(pc != null)
			return pc.getCktsPre(planyear,simId,without);
		return new TreeSet<Ckt>();
	}

	public TreeSet<Ckt> getCktsAdd(int planyear)throws SQLException{
		TreeSet<Ckt> ckts = new TreeSet<Ckt>();
		for(SceProjElemCost pec:getSceProjElemCosts())
			ckts.addAll(pec.getCktsAdd(planyear));
		return ckts;
	}

	public TreeSet<Ckt> getCktsRem(int planyear)throws SQLException{
		TreeSet<Ckt> ckts = new TreeSet<Ckt>();
		for(SceProjElemCost pec:getSceProjElemCosts())
			ckts.addAll(pec.getCktsRem(planyear));
		return ckts;
	}	

	public TreeSet<Ckt> getCktsPost(int planyear,int simId,TreeSet<SceProjElemCost> without)throws SQLException{
		SceProjElemCost pc = new TreeSet<SceProjElemCost>(getSceProjElemCosts()).last();
		if(pc != null)
			return pc.getCktsPost(planyear,simId,without);
		return new TreeSet<Ckt>();
	}

	/**
	 * Counts scope items Capacitor Bank addition/removals
	 *  
	 * @return - the total quantity in MVAR
	 * @throws SQLException
	 */
	public double getMvarAddition(int planyear)throws SQLException{
		double sum = 0;
		for(SceProjElemCost spec:getSceProjElemCosts())
			if(spec.isEnabled())
				sum += spec.getKvarLowSideDelta(planyear);
		return sum/1000.0;
	}

	public String getGo131DText(){
		return GO131D_TEXT[getGo131D()];
	}

	public void setGo131DText(String string) throws SQLException {
		for(int i=0;i<GO131D_TEXT.length;i++){
			if(string.equalsIgnoreCase(GO131D_TEXT[i]))
				setGo131D(i);
		}
	}

	public String getGPCStatus() throws SQLException{
		SceProjRev gpcRev=null;
		GateTracking gpcCT=null;
		if(getGateTrackings()!=null)
			for(GateTracking ct:getGateTrackings())
				if(ct.getGateId() == Gate.GPC)
					gpcCT = ct;
		if(gpcCT == null){
			gpcCT = new GateTracking();
			gpcCT.setSceProjRev(this);
			gpcCT.setGateId(Gate.GPC);
			//this,Gate.GPC
		}
		if(gpcCT.getPrevApprovedInstance()!=null)
			gpcRev = gpcCT.getPrevApprovedInstance().getSceProjRev();
		return getProjStatusStr(gpcRev);
	}

	public Boolean isPmwifed() {
		try {
			if(getGateTrackings()!=null){
				for(GateTracking ct:getGateTrackings()){
					if(ct.getGateId() == Gate.PMWIF && ct.getActualDate() != null)
						return true;
				}
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return false;
	}

	// 	
	public Calendar getPmwifDate() throws SQLException{
		GateTracking pmwifCT=null;
		Calendar pmwifDate = null;
		if(isPmwifed()){
			for(GateTracking ct:getGateTrackings()){
				if(ct.getGateId() == Gate.PMWIF)
					pmwifCT = ct;
			}
			if(pmwifCT!=null){
				if(pmwifCT.getActualDate()!=null)
					return pmwifCT.getActualDate();
				else if(pmwifCT.getExpectedDate()!=null)
					return pmwifCT.getExpectedDate();
				//pmwifDate.set(2010, 12,31);
			}	
		}
		return pmwifDate;
	}

	public String getIWPStatusStr() throws SQLException {
		return getProjStatusStr(getPrevRev(SceProjRev.APPROVED));
	}

	public String getPlanYearStatus(int planyear, int simId) throws SQLException{
		return getProjStatusStr(getSceProj().getCurRev(planyear-1, simId));
	}

	public String getProjStatusStr(SceProjRev rev) throws SQLException{
		switch(getProjStatus(rev)){
			case ABORTED: return "Aborted";
			case CANCELLED: return "Cancelled";
		}
		int ps = getProjStatusActiveDetails(rev);
		switch(ps){
			case NEW: return "New";
			case NO_CHANGE: return "No Change";
			case REVISED: return "Revised";
		}
		if((ps & REVISED) > 0)
			return "Revised";
		return "New";
	}

	/**
	 * Trys to determine if Licensing is required by scope of the project
	 * @return String
	 * @throws SQLException
	 */
	public String getLicensingStatus() throws SQLException{
		return getLicensingStatus(getLicensingStatusId());
	}

	/**
	 * You probably want to use getLicensingStatus()
	 * @param licId - The static final... starts with LIC_
	 * @return String Licensing Status
	 * @throws SQLException
	 */
	public String getLicensingStatus(int licId) throws SQLException{
		switch(licId){
			//			case LIC_NOT_REQ: return "Not Required";
			case LIC_EXEMPT: return "Exempt";
			case LIC_REQUIRED: return "Required"; //131D Approved
			case LIC_131D_REVIEW_IP: return "131D Under Review"; 
			case LIC_131D_REVIEW_REQ: return "131D Review Required"; //DE Approved
			case LIC_REVIEW_IP: return "DE Review In Progress";
			case LIC_REVIEW_REQ: return "Expected";
			//LIC_NOT_EXPECTED
			default: return "Not Expected";
		}		
	}

	/**
	 * Trys to determine if Licensing is required by scope of the project
	 * @return String
	 * @throws SQLException
	 */
	public int getLicensingStatusId() throws SQLException{

		/*
//		Status:
		 * 		0	Not Expected 			default
		 * 		1	Review Required			> 50kV and contains typical licensing element
		 *		2	DE Review In Progress	13 submit
		 * 		3	131D Review Needed 		13 approved
		 * 		4	131D Under Review		14 submit, no resolution
		 * 		5	Licensing Required 		14 approved
		 * 		6	Exempt 					15 approved
		 * 		7	Not Required - Not sure how to do this... admin manually sets this? BJS
		 *  
		 * 
		 * Gate's
		 * 	1	BOT	Budget Oversight Team
		2	GPC	GPC Gate
		3	UMC	Utility Management Gate
		4	BOD	Board of Directors Approval
		5	CPCN	CPCN Approval
		6	FERC	FERC Approval
		7	NERC	NERC Approval
		8	ISO	ISO Approval
		9	ISO MGT	ISO MGT Approval
		10	Line and Bus	Line And Bus Gate
		11	PMWIF	Project Management Work Initiation Form
		13	DE Licensing Review	DE Licensing Review
		14	GO 131D Review	GO 131D Review
		15	GO 131D Exemption	GO 131D Exemption
		16	PLSC	PLSC
		17	TSPOC	TSPOC
		18	BLM	BLM
		19	PTC	PTC
		20	CEC	CEC
		12	ATP	ATP
		 */
		//		Also, if Scope has Changed..... then flag here

		if(getGateTrackings()!=null){

			for(GateTracking ct : getGateTrackings()){
				if(ct.getGateId() == 15 && ct.getResolution() == Gate.DENIED){
					return LIC_EXEMPT;
				}
			}
			for(GateTracking ct : getGateTrackings()){
				if(ct.getGateId() == 14){
					if(ct.getResolution() == Gate.DENIED) return LIC_REQUIRED;
					if(ct.getResolution() == Gate.NO_DECISION) return LIC_131D_REVIEW_IP;
				}
			}
			for(GateTracking ct : getGateTrackings()){
				if(ct.getGateId() == 13){
					if(ct.getResolution() == Gate.DENIED) return LIC_131D_REVIEW_REQ;
					if(ct.getResolution() == Gate.NO_DECISION) return LIC_REVIEW_IP;
				}
			}

		}

		for(SceProjElemCost spec:getSceProjElemCosts(CostStage.Type.Proposed)){

			// > 50 kV
			if(spec.getSub(getPlanYear())!=null && (spec.getSub(getPlanYear()).getPrimaryKv() > 50 || spec.getSub(getPlanYear()).getSecondaryKv() > 50)){

				//Licensing Element
				if(spec.getSceElemId() == SceElem.LICENSING)
					return LIC_REVIEW_REQ;

				//Check new R/W
				else if(spec.getSceElemId() == SceElem.RIGHT_OF_WAY) 
					return LIC_REVIEW_REQ;	

				else if(spec.getSceElemId() == SceElem.SUBTRANS){										
					for(ScopeItem si:spec.getScopeItems()){
						//Scope Item is New UG or OH
						if((si.getScopeTypeId()> 266 && si.getScopeTypeId() < 271) || si.getScopeTypeId() == 278 || si.getScopeTypeId() == 279 ){
							if(si.getQuantity() >= 2000)
								return LIC_REVIEW_REQ;
						}										
						//Scope Item is a Reconductor/Recable/Double Existing
						else if((si.getScopeTypeId()> 270 && si.getScopeTypeId() < 277) || si.getScopeTypeId() == 280 || si.getScopeTypeId() == 281 ){
							return LIC_REVIEW_REQ;
						}
					}
				}
				//Check Telecom
				else if(spec.getSceElemId() == SceElem.TELECOM) 
					return LIC_REVIEW_REQ;
			}
		}

		return LIC_NOT_EXPECTED;
	}


	/**
	 * Gets the grc.
	 * 
	 * @return the grc
	 */
	public String getGrc(){
		if(isGrc())
			return "Yes";
		return "No";
	}

	/**
	 * Sets the grc.
	 * 
	 * @param yn the new grc
	 * 
	 * @throws SQLException the SQL exception
	 */
	public void setGrc(String yn) throws SQLException{
		if(yn!=null && yn.equalsIgnoreCase("yes"))
			setGrc(true);
		else
			setGrc(false);
	}

	public TreeSet<Zone> getZones(int planyear) throws SQLException {
		TreeSet<Zone> zones = new TreeSet<Zone>();
		for(SceProjElemCost spec : getSceProjElemCosts()) {
			Zone z = spec.getZone(planyear);
			if(z != null)
				zones.add(z);
		}
		return zones;
	}

	public TreeSet<Region> getRegions(int planyear) throws SQLException {
		TreeSet<Region> regions = new TreeSet<Region>();
		for(SceProjElemCost spec : getSceProjElemCosts()) {
			Region r = spec.getRegion(planyear);
			if(r != null)
				regions.add(r);
		}
		return regions;
	}

	public TreeSet<Sys> getSyss(int planyear) throws SQLException {
		TreeSet<Sys> syss = new TreeSet<Sys>();
		for(Sub s : getSubs(planyear)) {
			if(s.getYear(this.getSimId(), planyear-1)!=null){
				Sys sys = s.getYear(this.getSimId(), planyear-1).getSys();
				if(sys != null)
					syss.add(sys);
			}
		}
		return syss;
	}

	public TreeSet<District> getDistricts(int planyear) throws SQLException {
		TreeSet<District> ds = new TreeSet<District>();
		for(SceProjElemCost spec : getSceProjElemCosts()) {
			District d = spec.getDistrict(planyear);
			if(d != null)
				ds.add(d);
		}
		return ds;
	}

	private String mpoFormattedDistricString;
	public String getMpoFormattedDistricts(int planyear) throws SQLException {
		if(mpoFormattedDistricString == null) {
			StringBuffer sb = new StringBuffer();
			for(District d : getDistricts(planyear)) {
				if(sb.length() != 0)
					sb.append(" / ");
				sb.append(d.getDistrictNum()+" "+d.getDistrictName());
			}
			mpoFormattedDistricString = sb.toString();
		}
		//don't show foreign district
		mpoFormattedDistricString = mpoFormattedDistricString.replaceAll("0 Foreign /", "");
		mpoFormattedDistricString = mpoFormattedDistricString.replaceAll("0 Foreign", "");
		return mpoFormattedDistricString;
	}

	private String mpoFormattedZonesString;
	public String getMpoFormattedZones(int planyear) throws SQLException {
		if(mpoFormattedZonesString == null) {
			StringBuffer sb = new StringBuffer();
			for(Zone z : getZones(planyear)) {
				if(sb.length() != 0)
					sb.append(" / ");
				sb.append(z.getName());
			}
			mpoFormattedZonesString = sb.toString();
		}
		return mpoFormattedZonesString;
	}

	public TreeSet<Sub> getSubs(int planyear) throws SQLException {
		TreeSet<Sub> subs = new TreeSet<Sub>();
		for(SceProjElemCost spec : getSceProjElemCosts()) {
			Sub sub = spec.getSub(planyear);
			if(sub != null)
				subs.add(sub);
		}
		return subs;
	}

	/**
	 * Net Present Value using the default escalation rate and base year = planYear 
	 * @return
	 * @throws SQLException
	 */
	public int getTotalCostNPV(int planYear) throws SQLException {
		double totalCost=0;
		for(int year=planYear; year<planYear+Department.getInstance(planYear).getPlanFor(); year++){
			totalCost+=Calculate.getNPV(planYear,Department.getInstance(planYear).getEscalationRate(), getTotalCost(CostStage.Type.Proposed,year),year);
		}
		return (int)totalCost+this.getPriorCost(CostStage.Type.Proposed);
	}

	/**
	 * FIXME 
	 * @param planYear
	 * @param simid
	 * @return
	 * @throws SQLException
	 */
	public boolean isNewSubstation(int planYear, int simid) throws SQLException{
		return (getNameplatePre(planYear,simid)==0);
	}	

	/**
	 * Returns a decoded text representation of the project 
	 * title based on default title selection.
	 * 
	 * @return the decoded project title
	 */
	public String getProjectTitle() {	
		return decodeVariables(getActualProjTitle());
	}

	/**
	 * Returns the project title encoded for preprocessors
	 * or it returns the stored database title (based on default
	 * title selection).
	 * 
	 * @return the derived default title based on scope items.
	 */
	public String getActualProjTitle() {
		if(isUseDefaultTitle() || getTitle()==null || getTitle().length()==0){
			try {
				return getActualDefaultTitle();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		return getTitle();
	}

	/**
	 * Decodes VARIABLES used in Project Title and GRC Testimony 
	 * 
	 * @param input
	 * @return String
	 * @throws SQLException 
	 */
	public String decodeVariables(String titleText) {
		//return the original title text if null
		if(titleText!=null && titleText.length()>0) {
			try {//FYI - this is the actual decode method call
				titleText = deriveExpression(titleText);
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		return titleText;
	}

	private String getActualDefaultTitle() throws SQLException {
		String defaultTitle = "";

		//===============================================
		//create a unique table of facilities (SUBSTATIONS)
		//===============================================
		Hashtable<Integer, LinkedList<ScopeItem>> hash = new Hashtable<Integer, LinkedList<ScopeItem>>();
		for(ScopeItem scope : getScopeItemSummary(getPlanYear())) {
			if(hash.get(scope.getFacilityId()) == null) {
				LinkedList<ScopeItem> list = new LinkedList<ScopeItem>();
				list.add(scope);
				hash.put(scope.getFacilityId(), list);
			}
			else
				hash.get(scope.getFacilityId()).add(scope);
		}
		//===============================================
		//iterate through my unique list
		//===============================================
		for(Enumeration<Integer> e = hash.keys(); e.hasMoreElements();) {
			LinkedList<ScopeItem> list = hash.get(e.nextElement());
			int i;
			i = 0;
			while(!list.isEmpty()) {//iterate through each facility
				ScopeItem s = list.poll();

				if(i == 0) {
					defaultTitle += ("&Facility:"+s.getScopeSummaryIdentifier()+ " -");
					i++;
				}
				//===============================================
				//only display meaningful scope items		
				//===============================================
				//===============================================
				//Add a Transformer
				if(s.getScopeType().getModelingCoTypeId()==CoType.TRANSFORMER && s.getScopeType().getDefaultQuantity()==1){

					//check if the project add capacity for the very first time
					if(isNewSubstation(getPlanYear(), getSimId())){
						defaultTitle += "  Construct a new &PrimaryKv:"+s.getScopeSummaryIdentifier()+"/&SecondaryKv:"+s.getScopeSummaryIdentifier()+" kV substation with &CapAdd:"+s.getScopeSummaryIdentifier()+" MVA of transformer capacity.";
					}else{ // Increase Capacity
						defaultTitle += "  Increase transformer capacity from &CapAddPre:"+s.getScopeSummaryIdentifier()+" to &CapAddPost:"+s.getScopeSummaryIdentifier()+" MVA.";
					}
				}
				//Remove a Transformer
				if(s.getScopeType().getModelingCoTypeId()==CoType.TRANSFORMER && s.getScopeType().getDefaultQuantity()==-1){
					defaultTitle += "  Decrease transformer capacity from &CapAddPre:"+s.getScopeSummaryIdentifier()+" to &CapAddPost:"+s.getScopeSummaryIdentifier()+" MVA.";
				}

				//"Add a Circuit"
				if(s.getScopeType().getModelingCoTypeId()==CoType.CIRCUIT && s.getScopeType().getDefaultQuantity()==1){
					defaultTitle += "  Add &CktAdd:"+s.getScopeSummaryIdentifier()+" -&SecondaryKv:"+s.getScopeSummaryIdentifier()+" kV circuit(s) for a total of &CktCountAfter:"+s.getScopeSummaryIdentifier()+ ".";
				}
				//Remove a Circuit
				if(s.getScopeType().getModelingCoTypeId()==CoType.CIRCUIT && s.getScopeType().getDefaultQuantity()==-1){
					defaultTitle += "  Remove &CktRemove:"+s.getScopeSummaryIdentifier()+"-&SecondaryKv:"+s.getScopeSummaryIdentifier()+" kV circuit(s) for a total of &CktCountAfter:"+s.getScopeSummaryIdentifier()+ ".";
				}

				//Add a Capacitor Bank
				if(s.getScopeType().getModelingCoTypeId()==CoType.SUB_VAR && s.getScopeType().getDefaultQuantity()==1){
					defaultTitle += "  Add &VarAdd:"+s.getScopeSummaryIdentifier()+" MVAR of capacitors.";
				}
				//Remove a Capacitor Bank
				if(s.getScopeType().getModelingCoTypeId()==CoType.SUB_VAR && s.getScopeType().getDefaultQuantity()==-1){
					defaultTitle += "  Remove &VarAdd:"+s.getScopeSummaryIdentifier()+" MVAR of capacitors.";
				}

				//defaultTitle+="\n";
			}//end of unique facility
			defaultTitle+="\n\n";

		}
		return defaultTitle;
	}

	/**
	 *  
	 * 
	 * @return
	 * @throws SQLException
	 */
	public TreeSet<ScopeItem> getFacilityScopeSummary() throws SQLException{
		TreeSet<ScopeItem> s = new TreeSet<ScopeItem>();
		//===============================================
		//create a unique table of facilities (SUBSTATIONS)
		//===============================================
		Hashtable<Integer, LinkedList<ScopeItem>> hash = new Hashtable<Integer, LinkedList<ScopeItem>>();
		for(ScopeItem scope : getScopeItemSummary(getPlanYear())) {
			if(hash.get(scope.getFacilityId()) == null) {
				LinkedList<ScopeItem> list = new LinkedList<ScopeItem>();
				list.add(scope);
				hash.put(scope.getFacilityId(), list);
				s.add(scope);
			}
			else
				hash.get(scope.getFacilityId()).add(scope);
		}
		//===============================================
		//iterate through my unique list
		//===============================================
		for(Enumeration<Integer> e = hash.keys(); e.hasMoreElements();) {
			LinkedList<ScopeItem> list = hash.get(e.nextElement());				
			while(!list.isEmpty()) 
				s.add(list.poll());
		}
		return s;
	}

	public TreeSet<ScopeItem> getUniqueFacilityScopeSummary() throws SQLException{
		TreeSet<ScopeItem> s = new TreeSet<ScopeItem>();
		//===============================================
		//create a unique table of facilities (SUBSTATIONS)
		//===============================================
		Hashtable<Integer, LinkedList<ScopeItem>> hash = new Hashtable<Integer, LinkedList<ScopeItem>>();
		for(ScopeItem scope : getScopeItemSummary(getPlanYear())) {
			if(hash.get(scope.getFacilityId()) == null) {
				LinkedList<ScopeItem> list = new LinkedList<ScopeItem>();
				list.add(scope);
				hash.put(scope.getFacilityId(), list);
				s.add(scope);
			}
		}
		return s;
	}

	public Vector<CoType> getUniqueTypes() throws SQLException{
		Vector<CoType> types = new Vector<CoType>();
		Hashtable<Integer,CoType> coTypes = new Hashtable<Integer, CoType>();
		for(ScopeItem scope : getScopeItemSummary(getPlanYear())) {
			if(coTypes.get(scope.getScopeType().getModelingCoTypeId()) == null) {
				coTypes.put(scope.getScopeType().getModelingCoTypeId(), CoType.getInstance(scope.getScopeType().getModelingCoTypeId()));
			}
		}
		for(Enumeration<Integer> e = coTypes.keys(); e.hasMoreElements();) {
			types.add(coTypes.get(e.nextElement()));
		}		
		return types;
	}

	private String deriveExpression(String preprocessorTest) throws SQLException{
		if(preprocessorTest!=null && preprocessorTest.length()>0 && preprocessorTest.contains("&")) {
			Hashtable<Integer, LinkedList<ScopeItem>> hash = new Hashtable<Integer, LinkedList<ScopeItem>>();
			for(ScopeItem scope : getScopeItemSummary(getPlanYear(),isCancelled())) {
				if(hash.get(scope.getFacilityId()) == null) {
					LinkedList<ScopeItem> list = new LinkedList<ScopeItem>();
					list.add(scope);
					hash.put(scope.getFacilityId(), list);
				}
				else
					hash.get(scope.getFacilityId()).add(scope);
			}
			//===============================================
			//iterate through my unique list
			//===============================================
			for(Enumeration<Integer> e = hash.keys(); e.hasMoreElements();) {
				LinkedList<ScopeItem> list = hash.get(e.nextElement());
				//int i = 0;
				while(!list.isEmpty()) {//iterate through each facility
					ScopeItem scopeItem = list.poll();

					//@Facility
					preprocessorTest=preprocessorTest.replaceAll("&Facility:"+scopeItem.getScopeSummaryIdentifier(), scopeItem.getFacilityObject(getPlanYear()).toString());
					//&PrimaryKv
					preprocessorTest=preprocessorTest.replaceAll("&PrimaryKv:"+scopeItem.getScopeSummaryIdentifier(), scopeItem.getFacilityObject(getPlanYear()).getPrimaryKv()+"");
					//&SecondaryKv
					preprocessorTest=preprocessorTest.replaceAll("&SecondaryKv:"+scopeItem.getScopeSummaryIdentifier(), scopeItem.getFacilityObject(getPlanYear()).getSecondaryKv()+"");
					//&CktCountAfter
					preprocessorTest=preprocessorTest.replaceAll("&CktCountAfter:"+scopeItem.getScopeSummaryIdentifier(), ""+getCktsPost(getPlanYear(), getSimId(),null).size());
					//&CktCountBefore
					preprocessorTest=preprocessorTest.replaceAll("&CktCountBefore:"+scopeItem.getScopeSummaryIdentifier(), ""+getCktsPre(getPlanYear(), getSimId(),null).size());

					//&capAdd	
					if(scopeItem.getScopeType().getModelingCoTypeId()==CoType.TRANSFORMER ){

						preprocessorTest=preprocessorTest.replaceAll("&CapAdd:"+scopeItem.getScopeSummaryIdentifier(), ""+Calculate.round(scopeItem.getQuantity(),1));
						//if(scopeItem.getSceProjElemCost()!=null)
						preprocessorTest=preprocessorTest.replaceAll("&CapAddPre:"+scopeItem.getScopeSummaryIdentifier(), 
								""+Calculate.round(getNameplatePre(getPlanYear(), getSimId()),1));
						//if(scopeItem.getSceProjElemCost()!=null)
						preprocessorTest=preprocessorTest.replaceAll("&CapAddPost:"+scopeItem.getScopeSummaryIdentifier(), 
								""+Calculate.round(getNameplatePost(getPlanYear(), getSimId(), null),1));

					}

					//&CktAdd || &CktRemove
					if(scopeItem.getScopeType().getModelingCoTypeId()==CoType.CIRCUIT){
						preprocessorTest=preprocessorTest.replaceAll("&CktAdd:"+scopeItem.getScopeSummaryIdentifier(), ""+Math.round(scopeItem.getQuantity()));
						preprocessorTest=preprocessorTest.replaceAll("&CktRemove:"+scopeItem.getScopeSummaryIdentifier(), ""+Math.round(scopeItem.getQuantity()));
					}

					//&VarAdd || &VarRemove
					if(scopeItem.getScopeType().getModelingCoTypeId()==CoType.SUB_VAR){
						preprocessorTest=preprocessorTest.replaceAll("&VarAdd:"+scopeItem.getScopeSummaryIdentifier(), ""+Calculate.round(scopeItem.getQuantity(),1));
						preprocessorTest=preprocessorTest.replaceAll("&VarRemove:"+scopeItem.getScopeSummaryIdentifier(), ""+Calculate.round(scopeItem.getQuantity(),1));
					}

				}

			}
		}

		return preprocessorTest;
	}

	public double getMvarLowSideDelta() {
		return 0;
	}

	public double getPllAdd() {
		return -999999;
	}

	public String getStatusGeneral() throws SQLException {
		return getProjStatusName();
	}

	public int getPresentWorthValue(int planYear) throws SQLException {
		int presWorthCost=0;
		double escalation = Department.getInstance(planYear).getEscalationRate();
		for(int year=planYear-1; year<planYear+Department.getInstance(planYear).getPlanFor(); year++)
			presWorthCost+=getTotalCost(CostStage.Type.Proposed,year)/Math.pow(1+escalation,year+1-planYear);
		return presWorthCost;
	}

	public int getScopeItemCount() throws SQLException{
		int count=0;
		for(SceProjElemCost spec:getSceProjElemCosts())
			count += spec.getScopeItems().size();
		return count;
	}

	public TreeSet<ScopeItem> getScopeItems() throws SQLException{
		TreeSet<ScopeItem> sis = new TreeSet<ScopeItem>();
		for(SceProjElemCost spec:getSceProjElemCosts())
			sis.addAll(spec.getScopeItems());
		return sis;
	}

	public Vector<String> getDifference(SceProjRev o){
		Vector<String> diffs = super.getDifference(o);
		try {
			if(!isSame(getScopeItemCount(),o.getScopeItemCount()))
				diffs.add("scopeItemCount");
			if(!isSame(getModelDate(),o.getModelDate()))
				diffs.add("opDate");
			if(!isSame(getTotalCost(CostStage.Type.Proposed),o.getTotalCost(CostStage.Type.Proposed)))
				diffs.add("proposedTotalCost");
			if(!isSame(getTotalCost(CostStage.Type.Approved),o.getTotalCost(CostStage.Type.Approved)))
				diffs.add("approvedTotalCost");
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return diffs;
	}


	public String getMultiStatusStr(String str) throws SQLException{
		String status=null;
		SceProjRev gpcRev=null;

		GateTracking gpcCT=null;
		if(getGateTrackings()!=null)
			for(GateTracking ct:getGateTrackings())
				if(ct.getGateId() == Gate.GPC)
					gpcCT = ct;
		if(gpcCT == null){
			gpcCT = new GateTracking();
			gpcCT.setSceProjRev(this);//FIXME
			gpcCT.setGateId(Gate.GPC);
			//this,Gate.GPC
		}
		if(gpcCT.getPrevApprovedInstance()!=null)
			gpcRev = gpcCT.getPrevApprovedInstance().getSceProjRev();
		if(str.equals("iwp"))		
			status = getProjStatusLetter(getPrevRev(APPROVED));
		if(str.equals("py"))		{
			try{
				if(getSceProj()!=null && getSceProj().getCurRev(getPlanYear()-1, getSimId())!=null)
					status = getProjStatusLetter(getSceProj().getCurRev(getPlanYear()-1, getSimId()));
			}catch(Exception e){
				e.printStackTrace();
			}
		}
		if(str.equals("gpc"))		
			status = getProjStatusLetter(gpcRev);
		return status;
	}

	/**
	 * Returns the project status compared to the previously
	 * approved project, e.g., new, canceled, no change, revised, or other.
	 * 
	 * @return the integer state derived from SceProjRev
	 * 
	 * @throws SQLException
	 */
	public int getIWPStatus() throws SQLException {
		return getProjStatusFull(getPrevRev(SceProjRev.APPROVED));
	}

	/**
	 * Returns a default file number if a value is not assigned.
	 * 
	 * @return The fileNo
	 */
	public int getFileNumber(){	
		if(getFileNo()==0)
			return getDefaultFileNo();
		return getFileNo();
	}

	private int getDefaultFileNo() {
		switch(getProgramId()){
			case Program.DSP: 	return 13;
			case Program.TSP_STL: 	return 12;
			case Program.TRANS: return 9;
		}
		return 0;
	}

	public CoType getPreprocessorCoType(String string) throws SQLException {
		if(string.equals("&VarAdd")||string.equals("&VarRem")) return CoType.getInstance(CoType.SUB_VAR);
		if(string.equals("&CapAdd")||string.equals("&CapAddPost") || string.equals("&CapAddPre")) return CoType.getInstance(CoType.TRANSFORMER);
		if(string.equals("&CktAdd")||string.equals("&CktRemove")) return CoType.getInstance(CoType.CIRCUIT);
		if(string.equals("&CapAdd")||string.equals("&CapAddPost") || string.equals("&CapAddPre")) return CoType.getInstance(CoType.BBANK);

		return null;
	}

	public static TreeSet<SceProj> getRevsByCoType(CoType csco) throws SQLException{
		Hashtable<String,SceProj> resultsHash = new Hashtable<String,SceProj>();
		TreeSet<SceProj> data = new TreeSet<SceProj>();
		String qry = null;
		PreparedStatement ps = null; ResultSet rs = null;
		try{//SceProjElementCost Scope field
			qry = "SELECT DISTINCT Sce_Proj_Rev_Id  FROM MDI."+SceProjElemCost.class.getAnnotation(Table.class).name()+" pec WHERE "+
					"CO_TYPE_ID="+csco.getCoTypeId()+
					"AND DELETED_TS IS NULL "+
					"AND SCE_PROJ_REV_ID IN (SELECT DISTINCT SCE_PROJ_REV_ID FROM MDI."+SceProjRev.class.getAnnotation(Table.class).name()+")";

			EspLogger.debug(SceProjRev.class, qry);
			ps = PDBConnection.getInstance().getConnection().prepareStatement(qry);
			rs = ps.executeQuery();

			CriteriaBuilderImpl cb = (CriteriaBuilderImpl) EntityManagerHelper.getEntityManager().getCriteriaBuilder();
			CriteriaQueryImpl<SceProjRev> criteriaQuery = new CriteriaQueryImpl(SceProjRev.class, "o");

			while(rs.next()){
				criteriaQuery.addRestriction(Restrictions.eq("Sce_Proj_Rev_Id", rs.getInt("Sce_Proj_Rev_Id")));
				//				if(resultsHash.get(SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj().getHashKey())==null){
				//					resultsHash.put(SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj().getHashKey(),SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj());
				//					data.add(SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj());
				//				}
			}
			TypedQuery<SceProjRev> tq = EntityManagerHelper.getEntityManager().createQuery(criteriaQuery.toString(),SceProjRev.class);
			for(SceProjRev rev: tq.getResultList()){
				if(resultsHash.get(rev.getSceProj().getHashKey())==null){
					resultsHash.put(rev.getSceProj().getHashKey(),rev.getSceProj());
					data.add(rev.getSceProj());
					criteriaQuery.addRestriction(Restrictions.eq("Sce_Proj_Rev_Id", rs.getInt("Sce_Proj_Rev_Id")));
					//				if(resultsHash.get(SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj().getHashKey())==null){
					//					resultsHash.put(SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj().getHashKey(),SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj());
					//					data.add(SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj());
					//				}
					rs.close();
					ps.close();
				}
			}
		}catch(Exception e){
			e.printStackTrace();
		}
		resultsHash.clear();
		return data;
	}


	/**
	 * 
	 * Searches Project title, need, description, alternative, pin,
	 * Substation location and project element cost scope fields.
	 * 
	 * @param cs a char sequence used for querying.
	 * @return a collection of unique <Code>SceProj</Code> objects.
	 * @throws SQLException
	 */
	public static Collection<SceProj> search(CharSequence cs) throws SQLException{
		Hashtable<String,SceProj> resultsHash = new Hashtable<String,SceProj>();
		String qry = null;
		PreparedStatement ps = null; ResultSet rs = null;

		try{//Search SceProjRev Relevant fields
			qry = "select revs.Sce_Proj_Rev_Id from  MDI."+SceProjRev.class.getAnnotation(Table.class).name()+" revs"+
					" WHERE REGEXP_LIKE(revs.Need, '"+cs.toString()+"', 'i')"+
					" or  REGEXP_LIKE(revs.Title,  '"+cs.toString()+"', 'i')"+
					" or  REGEXP_LIKE(revs.Proj_Num, '"+cs.toString()+"', 'i')"+
					" or  REGEXP_LIKE(revs.Description, '"+cs.toString()+"', 'i')"+
					" or  REGEXP_LIKE(revs.ALT_PROJ_NOTE, '"+cs.toString()+"', 'i')" +
					" AND DELETED_TS IS NULL";

			EspLogger.debug(SceProjRev.class, qry);
			ps = PDBConnection.getInstance().getConnection().prepareStatement(qry);
			rs = ps.executeQuery();

			while(rs.next()){
				if(!resultsHash.containsKey(SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj().getHashKey())){
					resultsHash.put(SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj().getHashKey(),SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj());
				}								
			}
			rs.close();
			ps.close();
		}catch(Exception e){
			e.printStackTrace();
		}
		try{//Search Substation name field
			qry = "SELECT DISTINCT Sce_Proj_Rev_Id  FROM MDI."+SceProjElemCost.class.getAnnotation(Table.class).name()+" pec, " +
					"(SELECT distinct BBANK_SUB_ID FROM MDI."+Bbank.class.getAnnotation(Table.class).name()+" WHERE REGEXP_LIKE(SUB_NAME, '"+cs.toString()+"', 'i')) b"+
					" WHERE ( (CO_TYPE_ID=7 OR CO_TYPE_ID=6 OR CO_TYPE_ID=1)"+
					"  AND FACILITY_ID=(b.BBANK_SUB_ID) "+
					" AND DELETED_TS IS NULL "+
					" AND SCE_PROJ_REV_ID IN (SELECT DISTINCT SCE_PROJ_REV_ID FROM MDI."+SceProjRev.class.getAnnotation(Table.class).name()+"))";

			EspLogger.debug(SceProjRev.class, qry);
			ps = PDBConnection.getInstance().getConnection().prepareStatement(qry);
			rs = ps.executeQuery();
			while(rs.next()){
				if(!resultsHash.containsKey(SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj().getHashKey())){
					resultsHash.put(SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj().getHashKey(),SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj());
				}	
			}
			rs.close();
			ps.close();
		}catch(Exception e){
			e.printStackTrace();
		}
		try{//Search SceProjElementCost Scope field
			qry = "SELECT DISTINCT Sce_Proj_Rev_Id  FROM MDI."+SceProjElemCost.class.getAnnotation(Table.class).name()+" pec WHERE REGEXP_LIKE(SCOPE, '"+cs.toString()+"', 'i')"+
					"AND DELETED_TS IS NULL "+
					"AND SCE_PROJ_REV_ID IN (SELECT DISTINCT SCE_PROJ_REV_ID FROM MDI."+SceProjRev.class.getAnnotation(Table.class).name()+")";

			EspLogger.debug(SceProjRev.class, qry);
			ps = PDBConnection.getInstance().getConnection().prepareStatement(qry);
			rs = ps.executeQuery();
			while(rs.next()){
				if(!resultsHash.containsKey(SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj().getHashKey())){
					resultsHash.put(SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj().getHashKey(),SceProjRev.getInstance(rs.getInt("Sce_Proj_Rev_Id")).getSceProj());
				}			
			}
			rs.close();
			ps.close();
		}catch(Exception e){
			e.printStackTrace();
		}
		return resultsHash.values();
	}


	/**
	 * Returns any changes at ElemCostYear level aka Costs, if not available, CostElement level aka scope, if not available, ProjRev level aka title and reason.
	 * If last modified is not available insert is used
	 * @return LastModified object, User and Time
	 * @throws SQLException
	 */
	public LastModified getLastModified() throws SQLException {

		LastModified revLm = new LastModified(getModifiedUser(), getModifiedTs());

		for(SceProjElemCost spec : getSceProjElemCosts(CostStage.Type.Proposed)){
			LastModified specLm = spec.getLastModified();
			if(specLm.getModifiedTs()!=null && (revLm.getModifiedTs()==null || specLm.getModifiedTs().getTimeInMillis()>revLm.getModifiedTs().getTimeInMillis())){
				revLm = specLm;
			}
		}

		if(revLm.getModifiedTs() == null)
			revLm = new LastModified(getInsertUser(), getInsertTs());
		return revLm;
	}

	public TreeSet<SceSimAlt> getSceSimAlts() throws SQLException {
		TreeSet<SceSimAlt> alts = new TreeSet<SceSimAlt>();
		for(SceSimAlt alt:getSceProj().getSceSimAlts())
			if(alt.getSimId() == getSimId())
				alts.add(alt);
		return alts;
	}

	public String getProjPriorityString() {
		return (getProjPriority()==LOW_PRIORITY ? LOW_PRIORITY_STRING : HIGH_PRIORITY_STRING );
	}

	/**
	 * if is using calculated then will return subyear reserve no proj
	 * else return user inputed reserve no proj
	 * @return reserve no proj
	 * @throws SQLException
	 */
	public double getReserveNoProjIsCalc() throws SQLException {
		if(isUseCalcJust()) {
			if(!getSubs(getPlanYear()).isEmpty()){
				Sub sub = getSubs(getPlanYear()).first();
				SubYear sy = sub.getYear(getSimId(), getPeakYear(getPlanYear()));

				if(sy != null )
					return sy.getReserveNoProj(this);
			}
			return 0;
		}
		return getReserveNoProj();
	}

	public double getReserveN1NoProjIsCalc() throws SQLException {
		if(isUseCalcJust()) {
			if(!getSubs(getPlanYear()).isEmpty()){
				Sub sub = getSubs(getPlanYear()).first();
				SubYear sy = sub.getYear(getSimId(), getPeakYear(getPlanYear()));

				if(sy != null && sy instanceof BbankYear)
					return ((BbankYear)sy).getReserveN1NoProj(this);
			}
			return 0;
		}
		return 0;
	}

	public double getReserveHCNoProjIsCalc() throws SQLException {
		if(isUseCalcJust()) {
			if(!getSubs(getPlanYear()).isEmpty()){
				Sub sub = getSubs(getPlanYear()).first();
				SubYear sy = sub.getYear(getSimId(), getPeakYear(getPlanYear()));

				if(sy != null)
					return sy.getReserveHCNoProj(this);
			}
			return 0;
		}
		return getReserveHcNoProj();
	}

	public boolean isCancelled(){
		return !isActive();
	}

	/**
	 * 
	 * @param simId
	 * @param field
	 * @return
	 * @throws SQLException
	 */
	public boolean isEditable(int simId, String field) throws SQLException{
		if(field.equals("INSERT_TS")) return isVersionEditable(simId);

		if(simId != getSimId())
			return false;
		if(isNewInstance()) 
			return true;

		if(simId != getSimId())
			return false;
		if(isNewInstance()) 
			return true;

		if(INFO_FIELDS.contains(field))return isInfoEditable(simId);
		if(BSS_FIELDS.contains(field))return isBSSEditable(simId);
		if(ALWAYS_FIELDS.contains(field))return isAlwaysEditable(simId);
		if(ADMIN_FIELDS.contains(field))return isAdminEditable(simId);
		if(SPI_FIELDS.contains(field))return isSPIEditable(simId);
		if(SUBMIT_FIELDS.contains(field))return isSubmitEditable(simId);
		if(RETRACT_FIELDS.contains(field))return isRetractEditable(simId);
		if(CANCEL_FIELDS.contains(field))return isCancelEditable(simId);
		return false;
	}

	private boolean isVersionEditable(int simId) throws SQLException{
		if(isLocked())
			return false;
		return true;
		//		return User.getActiveUser().getUserRole().isUser() || User.getActiveUser().getUserRole().isAdmin() && this.getProgramId()!=Program.DSP;//XXX added dsp to lock down projects
		//		return ( this.getProgramId()!=Program.DSP && User.getActiveUser().getUserRole().isAdmin();
		//return (User.getActiveUser().getUserRole().isUser() && this.getProgramId()!=Program.DSP ) || User.getActiveUser().getUserRole().isAdmin();//XXX added dsp to lock down projects
	}

	public boolean isInfoEditable(int simId) throws SQLException{
		if(isLocked())
			return false;
		if(simId != getSimId())
			return false;
		if(User.getActiveUser().getUserRole().isMgr() || User.getActiveUser().getUserRole().isIWPUser())
			return (getIWPState() & (CONCEPTUAL | EMERGENT | APPROVED)) > 0 && !isPlanFinalized() && !isCancelled();
			if(User.getActiveUser().getUserRole().isUser())
				return (getIWPState() & (CONCEPTUAL | EMERGENT | APPROVED)) > 0 && !isMgrFinalized() && !isPlanFinalized() && !isCancelled() && isCurRev(Department.getActivePlanYear(),simId);
				return false;
	}

	protected boolean isCancelEditable(int simId) throws SQLException{
		if(isLocked())//XXX added dsp to lock down projects
			return false;
		if(simId != getSimId())
			return false;
		if(User.getActiveUser().getUserRole().isMgr() || User.getActiveUser().getUserRole().isIWPUser())
			return (getIWPState() & (CONCEPTUAL | EMERGENT | APPROVED)) > 0 && !isPlanFinalized();
			if(User.getActiveUser().getUserRole().isUser())
				return (getIWPState() & (CONCEPTUAL)) > 0 && !isMgrFinalized() && !isPlanFinalized() && isCurRev(Department.getActivePlanYear(),simId);
				return false;
	}

	public boolean isBSSEditable(int simId) throws SQLException{
		if(isLocked())//XXX added dsp to lock down projects
			return false;

		/* If it's new then it's inside the new project wizard which means sim is different than getSimId().
		 * Since this rev is not inserted yet its getSimId() method will return 0 which will not be equal to the simId passed in
		 * which causes the shopping cart to be disabled.  That is why I have placed the isNewInstance check before checking simId
		 * equality. GUS 6/15/12
		 */
		if(!isNewInstance()) {
			if(simId != getSimId())
				return false;
		}
		if(User.getActiveUser().getUserRole().isIWPUser())
			return (getIWPState() & (CONCEPTUAL | EMERGENT)) > 0 && !isPlanFinalized() && !isCancelled();
			if(User.getActiveUser().getUserRole().isMgr())
				return (getIWPState() & (CONCEPTUAL)) > 0 && !isPlanFinalized() && !isCancelled();
				if(User.getActiveUser().getUserRole().isUser())
					return (getIWPState() & (CONCEPTUAL)) > 0 && !isMgrFinalized() && !isPlanFinalized() && !isCancelled() && isCurRev(Department.getActivePlanYear(),simId);
					return false;
	}

	protected boolean isAdminEditable(int simId) throws SQLException{
		if(isLocked())//XXX added dsp to lock down projects
			return false;
		if(simId != getSimId())
			return false;
		if(User.getActiveUser().getUserRole().isMgr())
			return (getIWPState() & (CONCEPTUAL | EMERGENT | APPROVED)) > 0 && !isPlanFinalized();
			return false;
	}

	protected boolean isAlwaysEditable(int simId) throws SQLException{
		if(simId != getSimId())
			return false;
		if(User.getActiveUser().getUserRole().isMgr())
			return  !isCancelled();
		if(User.getActiveUser().getUserRole().isUser())
			return !isCancelled();
		return false;
	}

	protected boolean isSPIEditable(int simId) throws SQLException{
		if(simId != getSimId())
			return false;
		if(User.getActiveUser().getOrgId() == Org.SPI || User.getActiveUser().getOrgId() == Org.TIG || User.getActiveUser().getOrgId() == Org.ESP)
			return !isCancelled();
		return false;
	}

	protected boolean isSubmitEditable(int simId) throws SQLException{
		if(isLocked())//XXX added dsp to lock down projects
			return false;
		if(simId > 0) return false;
		if(User.getActiveUser().getUserRole().isMgr())
			return getIWPState() == CONCEPTUAL && isCurRev(Department.getActivePlanYear(),simId);
		if(User.getActiveUser().getUserRole().isUser())
			return getIWPState() == CONCEPTUAL && (User.getActiveUser().getOrgId()!=Org.DE || isMgrFinalized()) && isCurRev(Department.getActivePlanYear(),simId);
		return false;
	}

	protected boolean isRetractEditable(int simId) throws SQLException{
		if(isLocked())//XXX added dsp to lock down projects
			return false;
		if(simId != getSimId())
			return false;
		if(User.getActiveUser().getUserRole().isUser())
			return getIWPState() == EMERGENT;
		return false;
	}

	//=============================================================================

	/**
	 * if is using calculated then will return subyear ACL no proj
	 * else return user inputed ACL no proj
	 * @return ACL no proj
	 * @throws SQLException
	 */
	public double getAvgCktLoadNoProjIsCalc() throws SQLException {
		if(isUseCalcJust()) {
			if(!getSubs(getPlanYear()).isEmpty()){
				Sub sub = getSubs(getPlanYear()).first();
				SubYear sy = sub.getYear(getSimId(), getPeakYear(getPlanYear()));

				if(sy != null)
					return sy.getAvgCktLoadNoProj(this);
			}
		}
		return getAvgCktLoadNoProj();
	}


	public double getAvgCktLoadHCNoProjIsCalc() throws SQLException {
		if(isUseCalcJust()) {
			if(!getSubs(getPlanYear()).isEmpty()){
				Sub sub = getSubs(getPlanYear()).first();
				SubYear sy = sub.getYear(getSimId(), getPeakYear(getPlanYear()));

				if(sy != null)
					return sy.getAvgCktLoadNoProj(this);
			}
		}
		return 0; //XXX no db field
	}

	public int getCktAboveCriteriaNoProj() throws SQLException {
		int olCkt = 0;
		for(Sub sub : getSubs(getPlanYear())) {
			if(sub instanceof Bbank) {
				SubYear sy = sub.getYear(getSimId(), getPeakYear(getPlanYear()));
				olCkt +=  sy.getCktAboveCriteriaNoProj(this);
			}
		}
		return olCkt;
	}

	public int getCktAboveCriteriaHCNoProj() throws SQLException {
		int olCkt = 0;
		for(Sub sub : getSubs(getPlanYear())) {
			if(sub instanceof Bbank) {
				SubYear sy = sub.getYear(getSimId(), getPeakYear(getPlanYear()));
				olCkt +=  sy.getCktAboveCriteriaHCNoProj(this);
			}
		}
		return olCkt;
	}

	public String toStringCalendar(int planyear) throws SQLException{

		String projectType = "";
		int status = getProjectStatus();
		int year = getPeakYear(planyear);
		int costs = getTotalCost(CostStage.Type.Proposed);

		if (status != SceProjRev.NEW && status != SceProjRev.NO_CHANGE) {
			SceProjRev prevProj = getSceProj().getCurRev(planyear-1, getSimId());
			if(prevProj != null) {
				projectType = getProjStatusName()+"\n";
				if (year == prevProj.getPeakYear(planyear))
					projectType += "(Same Year)\n";
				else
					projectType += "(Was " + prevProj.getPeakYear(planyear) +")\n";
				int prevCost = prevProj.getTotalCost(CostStage.Type.Proposed);
				if (costs == prevCost)
					projectType += "(Same Cost)\n";
				else
					projectType += "(Was $" + FormatText.NUMBER.format(prevCost) + ")\n";							
			}//end while(rsWasYear.next())
			//show cancelled
		} else 
			projectType = "(" + getProjStatusName() + ")\n";

		return "" + getProgram()+"\n"+"#" + getProjNum() + "\n" + projectType + getProjectTitle() +  "\n$" + FormatText.NUMBER.format(costs) + "\n Licensing Req? " +getGo131DText();
	}


	public synchronized static Collection<SceProjRev> getAllActiveQc(){//XXX new Qc treeset
		try {
			return getCollection("SELECT o FROM SceProjRev o WHERE o.PROJ_NUM is not null and extract(year from INSERT_TS)>2010 AND o.DELETED_TS IS NULL");
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return null;
	}

	public TreeSet<Change> getRecommendedChanges() throws SQLException{
		TreeSet<Change> rcs = new TreeSet<Change>();
		for(RecommendedDriver rd:getRecommendedDrivers())
			rcs.add(rd.getChange());
		return rcs;
	}
	public TreeSet<DriverCriteria> getReccommendedDriverCriterias() throws SQLException{
		TreeSet<DriverCriteria> rcs = new TreeSet<DriverCriteria>();
		for(RecommendedDriver rd:getRecommendedDrivers())
			rcs.add(rd.getDriverCriteria());
		return rcs;
	}

	public TreeSet<RecommendedDriver> getRecommendedDrivers() throws SQLException {
		Program program = getProgram();
		TreeSet<RecommendedDriver> recDrivers = new TreeSet<RecommendedDriver>();
		for(SceProjElemCost spec:getSceProjElemCosts())
			for(ScopeItem si:spec.getScopeItems()){
				TreeSet<RecommendedDriver> rds = RecommendedDriver.getInstance(program,si.getScopeType());
				if(rds != null)
					recDrivers.addAll(rds);
			}
		return recDrivers;
	}

	public void setNeedDateWAuto(Calendar needDate)throws SQLException{
		Collection<SceProjElemCost> curCosts = getSceProjElemCosts(CostStage.Type.Proposed);
		if(curCosts.size() > 0)
			for(SceProjElemCost spec:curCosts)
				spec.setNeedDate(needDate);
		else{
			try {
				throw new Exception("Trace me");
			} catch (Exception e) {
				e.printStackTrace();
			}

			SceProjElemCost spec = new SceProjElemCost();
			spec.setSceElemId(SceElem.OTHER);
			spec.setCostStageId(CostStage.PLAN_EST);
			spec.setEnabled(true);
			spec.setTitle("Auto Created");
			spec.setScope("Auto created for need date. To be replaced with real costs in the future");
			spec.setNeedDate(needDate);
			addSceProjElemCost(spec);
		}
	}

	/**
	 * Gets the Type of Major Project.
	 * @return Major Project Priority
	 * @throws SQLException
	 */
	public int getMajorProjectPriority() throws SQLException {

		//		if(getGO131DDecision()== "Exempt") 	//To come once more enhancements are made
		//			return "No";
		if(getGo131D() == 1 )//|| getLicExpUser() == 2)
			return 2;
		if(getGo131D() == 2 && (getLicensingStatusId() == 1 || getLicensingStatusId() == 5))
			return 3;
		ProjContingency pc = ProjContingency.getBestMatch(getProgramId(), CostStage.PLAN_EST, null, getRevTs());
		double cost = getSubTotalCost(CostStage.Type.Proposed);
		double prior = getPriorCost(CostStage.Type.Proposed);
		double proj = cost - prior;
		proj = proj * (1+(pc!=null?pc.getMajorCont():0.35)) + prior;

		if(proj > 25000000)
			return 1;
		if(getGo131D() == 2)
			return 4;
		//		else if(getGo131DText() == ""){ 			//To come once more enhancements are made
		//			if(getLicExpCalc() == "Expected")
		//				return "Yes";
		//			else if(getLicExpCalc() == "Not Expected")
		//				return "No";
		//		}
		return 0;
	}

	/**
	 * Gets the Description of the Major Project Priority.
	 * @return Major Project Priority Description
	 * @throws SQLException
	 */
	public String getMajorProjectText() throws SQLException {

		int priority = getMajorProjectPriority();
		switch (priority){
			case 1: return "Major Project: Project Cost is > $25M with Added 35% Contingency";
			case 2: return "Major Project: The Project Sponsor is Expecting Licensing";
			case 3: return "May be a Major Project: The Project Sponsor is unsure if Licensing is needed. The Calculation in MDI shows that the Project is expecting Licensing";
			case 4: return "May be a Major Project: The Project Sponsor is unsure if Licensing is needed";	
		}
		return "Not a Major Project";
	}

	/**
	 * If Project is a major project return TRUE
	 * else return FALSE
	 * (Major Project defined as having a priority of 1 2 or 3)
	 * @return Major Project Status (TRUE or FALSE)
	 * @throws SQLException
	 */
	// May want to make a string and add a "Maybe" answer
	public Boolean isMajorProject() throws SQLException {
		if (getMajorProjectPriority() == 1 || getMajorProjectPriority() ==2 || getMajorProjectPriority() == 3) // Priority 3 & 4 are more of Maybes and should be treated as such
			return true;
		return false;
	}
	/**
	 * Returns the Factor of the total cost that is PUC.
	 * @return PUC Factor
	 * @throws SQLException
	 */
	public double getPUCFactor() throws SQLException {
		double pucTotal=0.0;
		double totalCost=0.0;
		double pf=0.0;

		for(SceProjElemCost spec : getSceProjElemCosts(CostStage.Type.Proposed)){
			if(spec.isEnabled()){
				double tc = (double)spec.getTotalCost();
				totalCost += tc;
				pucTotal += spec.getPUCFactor() * tc;
			}
		}
		pf = pucTotal/totalCost;
		if(totalCost ==  0.0)
			return 0.0;		
		return pf; 
	}

	public void setProperty(String prop, Object newValue, Object oldValue) throws SQLException{
		super.setProperty(prop, newValue, oldValue);
		if(prop!=null && (prop.equals("ACTIVE") || prop.equals("DELETED_TS")) && !isNewInstance()){
			for(SceProjElemCost spec:getSceProjElemCosts())
				spec.setProperty(null, null, null);
		}
	}

	public Collection<SceProjElemCost> getSceProjElemCosts(CostStage.Type costType) throws SQLException {
		//		if(isNewInstance()){
		TreeSet<SceProjElemCost> specs = new TreeSet<SceProjElemCost>();
		for(SceProjElemCost spec:getSceProjElemCosts())
			if(costType.ordinal()==spec.getCostStage().getCostType())
				specs.add(spec);
		return specs;
		//		}
		//		return SceProjElemCost.getCollection(new String[]{"SCE_PROJ_REV_ID","COST_TYPE","DELETED_TS"},getSceProjRevId(),costType.ordinal(),null);
	}

	public SceProjElem getSceProjElem(SceElem elem){
		return new SceProjElem(this,elem);
	}
	public double getContFactor(CostStage.Type costType) throws SQLException{
		double tc = getTotalCost(costType);
		if(tc!=0)
			return tc/(tc-getContAmount(costType))-1;
		return 0;
	}
	public int getContAmount(CostStage.Type costType) throws SQLException{
		int total=0;
		for(SceProjElemCost spec : getSceProjElemCosts(costType))
			if(spec.isEnabled())
				total+=spec.getContAmount();
		return total;
	}



	/**gets the project Elements for a particular project revision
	 * @param projRev
	 * @return
	 * @throws SQLException
	 */
	public Collection<SceProjElem> getSceProjElem(SceProjRev projRev) throws SQLException{
		TreeSet<SceProjElem> elems = new TreeSet<SceProjElem>();
		for(SceProjElemCost spec:getSceProjElemCosts(CostStage.Type.Proposed))// as the scope still needs to be approved
			elems.add(new SceProjElem(projRev, spec.getSceElem()));
		return elems;
	}

	public String getProjName(){
		String name = getName();
		if(name==null){
			name = getProjectTitle();
			if(name != null && name.length()>49)
				name = name.substring(0,48)+"...";
		}
		return name;
	}

	public double getDelta(){

		try {
			if(this.getOpDate()!=null)
				return  Math.round(((this.getOpDate().getTimeInMillis()-this.getNeedDate().getTimeInMillis())/(86400*1000.0*30)));
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return 0.0;
	}

	/**
	 * Sets the task(s) to the rev.
	 *
	 * @param task  the task to set to the rev
	 */
	public void setScheduleToRev(ScheduleTracking templateTask) throws SQLException{
		// First Create a new Task
		ScheduleTracking newSchedTrack = new ScheduleTracking();			
		newSchedTrack.setScheduleId(Schedule.getScheduleId(templateTask.getTaskName()));
		newSchedTrack.setTaskName(templateTask.getTaskName());	
		newSchedTrack.setTaskType(templateTask.getTaskType());
		newSchedTrack.insert();
		setTaskId(newSchedTrack.getTaskId());

		EspLogger.debug(this, "newSchedTrack.getTaskId(): " + newSchedTrack.getTaskId());	

		// if no schedule was previously assigned to the rev.
		if(getTaskId()==0){
			EspLogger.debug(this, "No Task Assigned to Rev-inserting: " + getTaskId());	
			try{
				ScheduleTracking newTask; 
				for(ScheduleTracking childTask: newSchedTrack.getScheduleTrackingChildren()){							
					newTask = new ScheduleTracking();
					newTask.setScheduleId(Schedule.getScheduleId(newSchedTrack.getTaskName()));
					newTask.setTaskName(childTask.getTaskName());
					newTask.setParentTaskId(getTaskId()); 
					newTask.setDuration(childTask.getDuration());
					newTask.setShift(childTask.getShift());	newTask.insert();

				}
				EspLogger.debug(this, "Sched Track ID:"+newSchedTrack.getScheduleTrackingId());
			}catch(Exception e){
				e.printStackTrace();
			}
		}
		//When Template already exists in a rev - update
		else{
			EspLogger.debug(this, "Existing Task Assigned to REV Loop: "+ getTaskId());
			//This hash contains the tmplateCmbo box current selected template
			Hashtable<String,ScheduleTracking> curChildTaskHash = new Hashtable<String,ScheduleTracking>();

			for(ScheduleTracking childTask:(ScheduleTracking.getInstanceByTaskId(getTaskId())).getScheduleTrackingChildren()){
				curChildTaskHash.put(childTask.toString(), childTask);
			}

			//Get currently assigned task
			ScheduleTracking currentParentSchedTracking = ScheduleTracking.getInstanceByTaskId(getTaskId());			
			EspLogger.debug(this, "currentParentSchedTracking.getTaskId():" + currentParentSchedTracking.getTaskId());
			//currentParentSchedTracking.setScheduleId(Schedule.getScheduleId(templateTask.getTaskName()));

			//Gather all child tasks associated with the currently assigned tasks
			TreeSet<ScheduleTracking> newChildTasks = new TreeSet<ScheduleTracking>();

			for(ScheduleTracking testSch:(ScheduleTracking.getInstanceByTaskId(getTaskId())).getScheduleTrackingChildren())
				EspLogger.debug(this, "NEW CHILD TASK:"+testSch.toString() +" TASK_ID: "+testSch.getTaskId());
			newChildTasks.addAll(templateTask.getScheduleTrackingChildren());

			ScheduleTracking curChildTaskUpdate;
			ScheduleTracking newChildTaskInsert;
			//problem here

			for(ScheduleTracking newChildTask:newChildTasks){
				//If an existing task matches ( by name ) update the duration with the selected templates duration
				//				EspLogger.debug(this,"child-task - Existing Template:" + newChildTask.toString()+" schedule tracking id:"+newChildTask.getScheduleTrackingId());
				if(curChildTaskHash.containsKey(newChildTask.toString())){
					//probably easier to create new ones rather than update existing ones
					EspLogger.debug(this,"Existing Template - Task in previous schedule:" + newChildTask.toString()+" schedule tracking id:"+newChildTask.getScheduleTrackingId());
					// will clean this up shortly.
					newChildTaskInsert  = new ScheduleTracking();
					newChildTaskInsert.setTaskName(newChildTask.getTaskName());
					newChildTaskInsert.setScheduleId(newChildTask.getScheduleId());
					newChildTaskInsert.setDuration(newChildTask.getDuration());
					newChildTaskInsert.setShift(newChildTask.getShift());
					newChildTaskInsert.setParentTask(newSchedTrack);
					newChildTaskInsert.setActualDate((curChildTaskHash.get(newChildTask.toString())).getActualDate());
					newChildTaskInsert.insert();
				}
			}
		}
	}


	/**
	 * Determines if this is a Substation Project according to the RGT Criteria
	 * The criteria is: adding a capacitor or adding a transformer
	 * @return true if it is an rgt substation project
	 */
	public boolean isRgtSubProj() {
		try {
			for(ScopeItem si: getScopeItemSummary(getPlanYear())) {
				if(si.getScopeTypeId() == ScopeType.ADD_CAPACITOR || si.getScopeTypeId() == ScopeType.ADD_XFMR) {
					return true;
				}
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return false;
	}

	public SceProjRev getSceProjRev(){
		return this;
	}

	@Override
	public double getTotSceCost(int costGroupId) throws SQLException {
		double total = 0;
		for(SceProjElemCost spec : getSceProjElemCosts(CostStage.Type.Proposed))
			total += spec.getTotSceCost(costGroupId);
		return total;
	}
	@Override
	public double getTotConCost(int costGroupId) throws SQLException {
		double total = 0;
		for(SceProjElemCost spec : getSceProjElemCosts(CostStage.Type.Proposed))
			total += spec.getTotConCost(costGroupId);
		return total;
	}
	@Override
	public double getUnitCost(CostType ct) throws SQLException {
		double total = 0;
		for(SceProjElemCost spec : getSceProjElemCosts(CostStage.Type.Proposed))
			total += spec.getUnitCost(ct);
		return total;
	}
	public Calendar getUnitCostBasisDate() {
		Calendar basis = super.getUnitCostBasisDate();
		if(basis==null)
			return basis = getRevTs();
		return basis;
	}
	@Override
	public Collection<? extends AbstractTask> getTasks() throws SQLException {
		return getProjTasks();
	}
	public void addTask(AbstractTask task) throws SQLException{
		addProjTask(new ProjTask(task,this));
	}
	public void setSchedule(Schedule schedule) {
		try {
			ProjTask pTask;
			for(AbstractTask at : schedule.getTasks()) {
				if(at.getParent() == null) {
					pTask = new ProjTask(at, this);
					addTask(pTask);
				}
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	Tspoc t; // used to speed up app
	public Tspoc getTspoc() throws SQLException {
		if(t != null) return t;

		//		t = (Tspoc) getCachedValue("getInstanceBySceProjRev", this); //get the cached tspoc instance for this sce proj rev
		//if there is no cached instance then get it from the database
		if(t == null) {
			t = Tspoc.getTspoc(this); //returns the desired tspoc instance
			//			setCachedValue(t, "getInstanceBySceProjRev", this); //get retrieved tspoc instance and cache it for quicker access later
		}
		return t;
	}

	public int getTspocId() throws SQLException {
		return getTspoc().getId();
	}

	public String getMpoProjNamePrevious() throws SQLException {
		return getTspoc().getMpoProjNamePrevious();
	}

	public void setMpoProjNamePrevious(String mpoProjNamePrevious) throws java.sql.SQLException{
		getTspoc().setMpoProjNamePrevious(mpoProjNamePrevious);
	}

	public String getMpoProjNameSce() throws SQLException{
		return getTspoc().getMpoProjNameSce();
	}
	public void setMpoProjNameSce(String mpoProjNameSce) throws java.sql.SQLException{
		getTspoc().setMpoProjNameSce(mpoProjNameSce);
	}

	public String getMpoProjNameCust() throws SQLException{
		return getTspoc().getMpoProjNameCust();
	}
	public void setMpoProjNameCust(String mpoProjNameCust) throws java.sql.SQLException{
		getTspoc().setMpoProjNameCust(mpoProjNameCust);
	}

	public String getMpoProjNameCustPrev() throws SQLException{
		return getTspoc().getMpoProjNameCustPrev();
	}
	public void setMpoProjNameCustPrev(String mpoProjNameCustPrev) throws java.sql.SQLException{
		getTspoc().setMpoProjNameCustPrev(mpoProjNameCustPrev);
	}

	public String getMpoProjNameAssocProj() throws SQLException{
		return getTspoc().getMpoProjNameAssocProj();
	}
	public void setMpoProjNameAssocProj(String mpoProjNameAssocProj) throws java.sql.SQLException{
		getTspoc().setMpoProjNameAssocProj(mpoProjNameAssocProj);
	}

	public String getMpoProjSeg() throws SQLException{
		return getTspoc().getMpoProjSeg();
	}
	public void setMpoProjSeg(String mpoProjSeg) throws java.sql.SQLException{
		getTspoc().setMpoProjSeg(mpoProjSeg);
	}

	public String getMpoFlagProjSysSplit() throws SQLException{
		return getTspoc().getMpoFlagProjSysSplit();
	}
	public void setMpoFlagProjSysSplit(String mpoFlagProjSysSplit) throws java.sql.SQLException{
		getTspoc().setMpoFlagProjSysSplit(mpoFlagProjSysSplit);
	}

	public String getMpoProjLocRegion() throws SQLException {
		return getTspoc().getMpoProjLocRegion();
	}

	public String getMpoProjLocCity() throws SQLException{
		return getTspoc().getMpoProjLocCity();
	}
	public void setMpoProjLocCity(String mpoProjLocCity) throws java.sql.SQLException{
		getTspoc().setMpoProjLocCity(mpoProjLocCity);
	}

	public String getMpoProjLocCounty() throws SQLException{
		return getTspoc().getMpoProjLocCounty();
	}
	public void setMpoProjLocCounty(String mpoProjLocCounty) throws java.sql.SQLException{
		getTspoc().setMpoProjLocCounty(mpoProjLocCounty);
	}

	public String getMpoPublishedReportComment() throws SQLException{
		return getTspoc().getMpoPublishedReportComment();
	}
	public void setMpoPublishedReportComment(String mpoPublishedReportComment) throws java.sql.SQLException{
		getTspoc().setMpoPublishedReportComment(mpoPublishedReportComment);
	}

	public int getMpoGroupLeadId() throws SQLException{
		return getTspoc().getMpoGroupLeadId();
	}
	public void setMpoGroupLeadId(int mpoGroupLeadId) throws java.sql.SQLException{
		getTspoc().setMpoGroupLeadId(mpoGroupLeadId);
	}

	public String getMpoGroupLeadPaxNum() throws SQLException{
		return getTspoc().getMpoGroupLeadPaxNum();
	}
	public void setMpoGroupLeadPaxNum(String mpoGroupLeadPaxNum) throws java.sql.SQLException{
		getTspoc().setMpoGroupLeadPaxNum(mpoGroupLeadPaxNum);
	}

	public int getMpoDevPmUserId() throws SQLException{
		return getTspoc().getMpoDevPmUserId();
	}
	public void setMpoDevPmUserId(int mpoDevPmUserId) throws java.sql.SQLException{
		getTspoc().setMpoDevPmUserId(mpoDevPmUserId);
	}

	public String getMpoDevPmPaxNum() throws SQLException{
		return getTspoc().getMpoDevPmPaxNum();
	}
	public void setMpoDevPmPaxNum(String mpoDevPmPaxNum) throws java.sql.SQLException{
		getTspoc().setMpoDevPmPaxNum(mpoDevPmPaxNum);
	}

	public int getMpoExecPmUserId() throws SQLException{
		return getTspoc().getMpoExecPmUserId();
	}
	public void setMpoExecPmUserId(int mpoExecPmUserId) throws java.sql.SQLException{
		getTspoc().setMpoExecPmUserId(mpoExecPmUserId);
	}

	public String getMpoExecPmPaxNum() throws SQLException{
		return getTspoc().getMpoExecPmPaxNum();
	}
	public void setMpoExecPmPaxNum(String mpoExecPmPaxNum) throws java.sql.SQLException{
		getTspoc().setMpoExecPmPaxNum(mpoExecPmPaxNum);
	}

	public int getMpoProjAnalystUserId() throws SQLException{
		return getTspoc().getMpoProjAnalystUserId();
	}
	public void setMpoProjAnalystUserId(int mpoProjAnalystUserId) throws java.sql.SQLException{
		getTspoc().setMpoProjAnalystUserId(mpoProjAnalystUserId);
	}

	public String getMpoProjAnalystPaxNum() throws SQLException{
		return getTspoc().getMpoProjAnalystPaxNum();
	}
	public void setMpoProjAnalystPaxNum(String mpoProjAnalystPaxNum) throws java.sql.SQLException{
		getTspoc().setMpoProjAnalystPaxNum(mpoProjAnalystPaxNum);
	}

	public int getMpoPceSchedulerUserId() throws SQLException{
		return getTspoc().getMpoPceSchedulerUserId();
	}
	public void setMpoPceSchedulerUserId(int mpoPceSchedulerUserId) throws java.sql.SQLException{
		getTspoc().setMpoPceSchedulerUserId(mpoPceSchedulerUserId);
	}

	public String getMpoPceSchedulerPaxNum() throws SQLException{
		return getTspoc().getMpoPceSchedulerPaxNum();
	}
	public void setMpoPceSchedulerPaxNum(String mpoPceSchedulerPaxNum) throws java.sql.SQLException{
		getTspoc().setMpoPceSchedulerPaxNum(mpoPceSchedulerPaxNum);
	}

	public int getMpoPceCostUserId() throws SQLException{
		return getTspoc().getMpoPceCostUserId();
	}
	public void setMpoPceCostUserId(int mpoPceCostUserId) throws java.sql.SQLException{
		getTspoc().setMpoPceCostUserId(mpoPceCostUserId);
	}

	public String getMpoPceCostPaxNum() throws SQLException{
		return getTspoc().getMpoPceCostPaxNum();
	}
	public void setMpoPceCostPaxNum(String mpoPceCostPaxNum) throws java.sql.SQLException{
		getTspoc().setMpoPceCostPaxNum(mpoPceCostPaxNum);
	}

	public String getMpoPmwifNum() throws SQLException{
		return getTspoc().getMpoPmwifNum();
	}
	public void setMpoPmwifNum(String mpoPmwifNum) throws java.sql.SQLException{
		getTspoc().setMpoPmwifNum(mpoPmwifNum);
	}

	public boolean isSpiPmwifAssignedDir() throws SQLException{
		return getTspoc().isSpiPmwifAssignedDir();
	}
	public void setSpiPmwifAssignedDir(boolean spiPmwifAssignedDir) throws java.sql.SQLException{
		getTspoc().setSpiPmwifAssignedDir(spiPmwifAssignedDir);
	}

	public boolean isMpoPmwifAssignedM3() throws SQLException{
		return getTspoc().isMpoPmwifAssignedM3();
	}
	public void setMpoPmwifAssignedM3(boolean mpoPmwifAssignedM3) throws java.sql.SQLException{
		getTspoc().setMpoPmwifAssignedM3(mpoPmwifAssignedM3);
	}

	public boolean isMpoPmwifAssignedPm() throws SQLException{
		return getTspoc().isMpoPmwifAssignedPm();
	}
	public void setMpoPmwifAssignedPm(boolean mpoPmwifAssignedPm) throws java.sql.SQLException{
		getTspoc().setMpoPmwifAssignedPm(mpoPmwifAssignedPm);
	}

	public Calendar getMpoPublishedOperatingDate() throws SQLException{
		return getTspoc().getMpoPublishedOperatingDate();
	}
	public void setMpoPublishedOperatingDate(Calendar mpoPublishedOperatingDate) throws java.sql.SQLException{
		getTspoc().setMpoPublishedOperatingDate(mpoPublishedOperatingDate);
	}

	public String getMpoDbMgrNote() throws SQLException{
		return getTspoc().getMpoDbMgrNote();
	}
	public void setMpoDbMgrNote(String mpoDbMgrNote) throws java.sql.SQLException{
		getTspoc().setMpoDbMgrNote(mpoDbMgrNote);
	}

	public int getGo131DStatus() throws SQLException{
		return getTspoc().getGo131DStatus();
	}
	public void setGo131DStatus(int go131DStatus) throws java.sql.SQLException{
		getTspoc().setGo131DStatus(go131DStatus);
	}

	public String getMpoEpefComment() throws SQLException{
		return getTspoc().getMpoEpefComment();
	}
	public void setMpoEpefComment(String mpoEpefComment) throws java.sql.SQLException{
		getTspoc().setMpoEpefComment(mpoEpefComment);
	}

	public boolean isArra() throws SQLException{
		return getTspoc().isArra();
	}
	public void setArra(boolean arra) throws java.sql.SQLException{
		getTspoc().setArra(arra);
	}

	public int getRefListId() throws SQLException{
		return getTspoc().getRefListId();
	}
	public void setRefListId(int refListId) throws java.sql.SQLException{
		getTspoc().setRefListId(refListId);
	}

	public int getProjListSeq() throws SQLException{
		return getTspoc().getProjListSeq();
	}
	public void setProjListSeq(int projListSeq) throws java.sql.SQLException{
		getTspoc().setProjListSeq(projListSeq);
	}

	public String getMpoProjReasonListed() throws SQLException {
		return getTspoc().getMpoProjReasonListed();
	}
	public void setMpoProjReasonListed(String value) throws SQLException {
		getTspoc().setMpoProjReasonListed(value);
	}

	public User getMpoGroupLead()throws java.sql.SQLException{
		return getTspoc().getMpoGroupLead();
	}
	public void setMpoGroupLead(User mpoGroupLead)throws java.sql.SQLException{
		getTspoc().setMpoGroupLead(mpoGroupLead);
	}
	public User getMpoDevPm()throws java.sql.SQLException{
		return getTspoc().getMpoDevPm();
	}
	public void setMpoDevPm(User mpoDevPm)throws java.sql.SQLException{
		getTspoc().setMpoDevPm(mpoDevPm);
	}
	public User getMpoExecPm()throws java.sql.SQLException{
		return getTspoc().getMpoExecPm();
	}
	public void setMpoExecPm(User mpoExecPm)throws java.sql.SQLException{
		getTspoc().setMpoExecPm(mpoExecPm);
	}
	public User getMpoProjAnalyst()throws java.sql.SQLException{
		return getTspoc().getMpoProjAnalyst();
	}
	public void setMpoProjAnalyst(User mpoProjAnalyst)throws java.sql.SQLException{
		getTspoc().setMpoProjAnalyst(mpoProjAnalyst);
	}
	public User getMpoPceScheduler()throws java.sql.SQLException{
		return getTspoc().getMpoPceScheduler();
	}
	public void setMpoPceScheduler(User mpoPceScheduler)throws java.sql.SQLException{
		getTspoc().setMpoPceScheduler(mpoPceScheduler);
	}
	public User getMpoPceCost()throws java.sql.SQLException{
		return getTspoc().getMpoPceCost();
	}
	public void setMpoPceCost(User mpoPceCost)throws java.sql.SQLException{
		getTspoc().setMpoPceCost(mpoPceCost);
	}
	public LookUp getGo131DLookUp()throws java.sql.SQLException{
		return getTspoc().getLookUp();
	}
	public void setGo131DLookUp(LookUp lookUp)throws java.sql.SQLException{
		getTspoc().setLookUp(lookUp);
	}
	public TspocRefList getRefList()throws java.sql.SQLException{
		return getTspoc().getRefList();
	}
	public void setRefList(TspocRefList refList)throws java.sql.SQLException{
		getTspoc().setRefList(refList);
	}
	public Collection<Trend> getTrends() throws SQLException {
		return getTspoc().getTrends();
	}
	public Collection<ChangeRequest> getChangeRequests() throws SQLException {
		return getTspoc().getChangeRequests();
	}
	public LookUp getTspocListCategory() throws SQLException {
		return getTspoc().getTspocListCategory();
	}
	public int getTspocRefListId() throws SQLException {
		return getTspoc().getRefListId();
	}
	public String getMpoProjName() throws SQLException {
		return getTspoc().getMpoProjName();
	}
	public String getMpoRegion() throws SQLException {
		return getTspoc().getMpoProjLocRegion();
	}
	public void setMpoRegion(String regionString) throws SQLException {
		getTspoc().setMpoProjLocRegion(regionString);
	}
	public void setMpoProjName(String stringCellValue) throws SQLException {
		getTspoc().setMpoProjName(stringCellValue);
	}
	public String getMpoLocation() throws SQLException {
		return getTspoc().getMpoProjLocCity()+", "+getTspoc().getMpoProjLocCounty();
	}
	public String getTspocAnalystNotes() throws SQLException {
		return getTspoc().getTspocAnalystNotes();
	}
	public void setTspocAnalystNotes(String notes) throws SQLException {
		getTspoc().setTspocAnalystNotes(notes);
	}

	/**
	 * Indicates if a previous version of this project was approved. Useful for groups such as MPO and E&TS RPPM to 
	 * determine if any emergent projects were at one time approved
	 * 
	 * @return true if previous revision of this project was approved
	 */
	public boolean isPreviouslyApproved(){
		try {
			if(getPrevRev(APPROVED)!=null)
				return true;
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return false;
	}
	public boolean isLocked(){
		return false;
		//		try {
		//			
		//			if(User.getActiveUser().isSPIUser())
		//				return false;
		//			return ((this.getProgramId()==Program.TSP_ABANK || this.getProgramId()==Program.TSP_STL || this.getProgramId()==Program.TSP_STV) &&  !User.getActiveUser().getUserRole().isAdmin());
		//		} catch (SQLException e) {
		//			e.printStackTrace();
		//		}
		//		return true;
	}
	public Collection<LookUp> getProjRoles() throws SQLException {
		TreeSet<LookUp> roles = new TreeSet<LookUp>();
		for(ProjTask pt:getProjTasks())
			for(TaskResource tr:pt.getResources())
				roles.add(tr.getProjRole());
		return roles;
	}
	public Collection<User> getProjUsers() throws SQLException {
		TreeSet<User> roles = new TreeSet<User>();
		for(ProjTask pt:getProjTasks())
			for(TaskResource tr:pt.getResources())
				roles.add(tr.getUser());
		return roles;
	}
	public Collection<TaskResource> getTaskResources(LookUp projRole) throws SQLException {
		TreeSet<TaskResource> trs = new TreeSet<TaskResource>();
		for(ProjTask pt:getProjTasks())
			for(TaskResource tr:pt.getResources())
				if(tr.getProjRole()==projRole)
					trs.add(tr);
		return trs;
	}
	@Override
	public Collection<SceElem> getSceElems() throws SQLException {
		TreeSet<SceElem> elems = new TreeSet<SceElem>();
		for(SceProjElemCost spec:getSceProjElemCosts(CostStage.Type.Proposed))
			elems.add(spec.getSceElem());
		return elems;
	}
	public Object getDescriptiveValue(String ptName, String dtVarName) throws SQLException {
		if(ptName.equalsIgnoreCase("Project")){
			if(dtVarName.equalsIgnoreCase("OdYear"))
				return getCalendarYear();
			return null;
		}
		for(SceProjElemCost spec: getSceProjElemCosts(CostStage.Type.Proposed)){
			for(ScopeItem si: spec.getScopeItems())
				if(si.getScopeType().getPartType() != null  && si.getScopeType().getPartType().getName().equalsIgnoreCase(ptName))
					return si.getDescriptiveValue(dtVarName);
		}
		return null;
	}
}
