/*
 * Copyright (c) 2002-2010 ESP Suite. All Rights Reserved.
 *
 *     
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Authors: Technology Integration Group, SCE
 * Developers: Eddie Mayfield, Frank Gonzales, Augustin Muniz,
 * Kate Suwan, Hiro Kushida, Andrew McNaughton, Brian Stonerock,
 * Russell Ragsdale, Patrick Ridge, Everett Aragon.
 * 
 */
package com.sce.esp.hst;

import java.sql.SQLException;
import java.util.Calendar;
import java.util.Vector;

import com.sce.esp.object.model.Ckt;
import com.sce.esp.object.model.CktDaily;
import com.sce.esp.object.model.ForecastWeather;
import com.sce.esp.object.model.Sub;
import com.sce.esp.object.model.Weatherstation;
import com.sce.esp.util.Calculate;
import com.sce.esp.util.FormatText;

/**
 *
 *
 * @author Distribution Staff Engineering
 * @version 2.0
 */
public class ForecastCkt extends NeuralNetForecast{
	private Ckt ckt;
	private Calendar cal;
	private Vector<Double> lrValues=null;
	private ForecastWeather[] day=null;

	public ForecastCkt(Ckt ckt, Calendar cal){
		this.ckt=ckt;
		this.cal=cal;
	}
	public Ckt getCkt(){
		return ckt;
	}
	
	public Sub getSub() throws SQLException{
		return ckt.getBbank(0);
	}
	
	public Calendar getDate(){
		return cal;
	}

	/**
	 * disabled from view for now
	 * @param dayNumber
	 * @return
	 * @throws SQLException 
	 */
	protected double getLinearForecast(int dayNumber) throws SQLException{
		return getLRForecast().get(dayNumber);		
	}

	//====================================================================
	//Linear Regression Forecast - Actual Model
	//====================================================================
	/**
	 * @return a collection of values in MVA
	 */
	public Vector<Double> getLRForecast() throws SQLException{		
		if(lrValues==null)
			refreshLRForecast();

		if(cal.getTimeInMillis() < Calculate.getCal().getTimeInMillis()){
			//System.out.println("Calendar is less than today's calendar instance");
			lrValues = new Vector<Double>();			
			lrValues.add(getDayOne());
			lrValues.add(getDayTwo());
			lrValues.add(getDayThree());
			lrValues.add(getDayFour());
			lrValues.add(getDayFive());
			return lrValues;
		}		
		return lrValues;
	}
	
	private void refreshLRForecast() throws SQLException{
		lrValues = new Vector<Double>();
		getNoaaForecast();
		double calc=0;
		if(!(day==null)){
			Calendar c1 = (Calendar)cal.clone();
			Calendar c2= (Calendar)cal.clone();
			for(int dayNum=0;dayNum<5;dayNum++){

				c1.add(Calendar.DATE, -1+dayNum);
				c2.add(Calendar.DATE, 0+dayNum);

				if(dayNum==0){
					calc=(1+((day[dayNum].getEffTemp()-
							ckt.getDailyPeak(c1).getTemperature().getEffTemp())*
							ckt.getYear(0, FormatText.getCalendarYear(cal)).getSens()));
					//get yesterday's recorded peak	
					lrValues.add(ckt.getDailyPeak(c1).getRecordedPeak()*calc);
					//or else use a fake number
					//values.add(2000*calc);
				}else{
					calc=(1+((day[dayNum].getEffTemp()- 
							day[dayNum-1].getEffTemp())*
							ckt.getYear(0, FormatText.getCalendarYear(cal)).getSens()));
					//System.out.println("=========>");
					//System.out.println("calc=(1+("+day[dayNum].getEffTemp()+"- "+day[dayNum-1].getEffTemp()+")*"+sub.getYear(0, FormatText.getCalendarYear(cal)).getTempSens()+"))");
							
					lrValues.add(lrValues.get(dayNum-1)*calc);
				}
			}
		}else{
			for(int dayNum=0;dayNum<5;dayNum++){
				lrValues.add(0.0);
			}
		}
	}

	private void getNoaaForecast() throws SQLException{
		int count=0;
		for(Weatherstation w: ckt.getWeatherStationsByInstance()){
			//System.out.println("Obtaining forecast for");
			if(count==0){
				if(w.getLatitude()>0 && w.getLongitude()<0){
					day = w.getNoaaForecast();
					count++;					
				}
			}
		}
	}
	
	public String toString(){
		return ckt.toString();
	}
	
	/* (non-Javadoc)
	 * @see com.sce.mdi.hst.NeuralNetForecast#getPLL()
	 */
	@Override
	public double getPLL() throws SQLException {	
		return ckt.getYear(0, ckt.getPlanyear()-1).getPLLBizLogic();
	}
	/**
	 * @see com.sce.mdi.hst.ann.nnf.NeuralNetForecast#runANN()
	 */
	@Override
	public void runANN() throws SQLException{
		
		String[][] trainingSet = new String[14][4];
		Calendar startDate  = (Calendar)cal.clone();
		startDate.add(Calendar.DATE, -14);
		for(int i = 0; i<14; i++){
			CktDaily d = CktDaily.getInstance(ckt.getPlanyear(), ckt.getCktId(), startDate);
			trainingSet[i][0] = FormatText.MYSQL_DATE.format(startDate.getTime());
			trainingSet[i][1] = d.getTemperature().getMinTemp()+"";
			trainingSet[i][2] = d.getTemperature().getMaxTemp()+"";
			trainingSet[i][3] = d.getActualPeak()*d.getLSE().getMVAFactor()+"";			
			startDate.add(Calendar.DATE, 1);
		}
		trainANN(new Effect(), trainingSet);		
		
		trainingSet = new String[15][4];
		startDate  = (Calendar)cal.clone();
		startDate.add(Calendar.DATE, -16);
		for(int i = 0; i<15; i++){
			CktDaily d = CktDaily.getInstance(ckt.getPlanyear(), ckt.getCktId(), startDate);
			trainingSet[i][0] = FormatText.MYSQL_DATE.format(startDate.getTime());
			trainingSet[i][1] = d.getTemperature().getMinTemp()+"";
			trainingSet[i][2] = d.getTemperature().getMaxTemp()+"";
			trainingSet[i][3] = d.getActualPeak()*d.getLSE().getMVAFactor()+"";
			startDate.add(Calendar.DATE, 1);
		}
		
		try {
			testTraining(new Effect(), trainingSet);
		} catch (Exception e) {			
			e.printStackTrace();
		}
		
		trainingSet = new String[5][4];
		getNoaaForecast();
		if(day!=null){
			Calendar c = Calendar.getInstance();
			for(int i = 0; i<day.length;i++){				
				trainingSet[i][0] = FormatText.MYSQL_DATE.format(c.getTime());				
				trainingSet[i][1] = day[i].getMinT()+"";
				trainingSet[i][2] = day[i].getEffTemp()+"";
				trainingSet[i][3] = getLRForecast().get(i)+"";
				c.add(Calendar.DATE,1);
			}
			try {
				predict(new Effect(), trainingSet);
			} catch (Exception e) {			
				e.printStackTrace();
			}
		}		
	}
	
	//====================================================================
	//Linear Regression Forecast - Historical Test Model
	//====================================================================
	public double getDayOne() throws SQLException{
		Calendar c1 = (Calendar)cal.clone();
		Calendar c2= (Calendar)cal.clone();
		c1.add(Calendar.DATE, -1);
		c2.add(Calendar.DATE, 0);
		double calc=(1+((ckt.getDailyPeak(c2).getTemperature().getEffTemp()-
				ckt.getDailyPeak(c1).getTemperature().getEffTemp())*
				ckt.getYear(0, FormatText.getCalendarYear(cal)).getSens()));

		return Math.round(ckt.getDailyPeak(c1).getRecordedPeak())*calc;
	}

	public double getDayTwo() throws SQLException{
		Calendar c1 = (Calendar)cal.clone();
		Calendar c2= (Calendar)cal.clone();
		c1.add(Calendar.DATE, 0);
		c2.add(Calendar.DATE, 1);
		double calc=(1+((ckt.getDailyPeak(c2).getTemperature().getEffTemp()-
				ckt.getDailyPeak(c1).getTemperature().getEffTemp())*
				ckt.getYear(0, FormatText.getCalendarYear(cal)).getSens()));

		return Math.round(getDayOne())*calc;
	}

	public double getDayThree() throws SQLException{
		Calendar c1 = (Calendar)cal.clone();
		Calendar c2= (Calendar)cal.clone();
		c1.add(Calendar.DATE, 1);
		c2.add(Calendar.DATE, 2);
		double calc=(1+((ckt.getDailyPeak(c2).getTemperature().getEffTemp()-
				ckt.getDailyPeak(c1).getTemperature().getEffTemp())*
				ckt.getYear(0, FormatText.getCalendarYear(cal)).getSens()));	
		return Math.round(getDayTwo())*calc;
	}

	public double getDayFour() throws SQLException{
		Calendar c1 = (Calendar)cal.clone();
		Calendar c2= (Calendar)cal.clone();
		c1.add(Calendar.DATE, 2);
		c2.add(Calendar.DATE, 3);
		double calc=(1+((ckt.getDailyPeak(c2).getTemperature().getEffTemp()-
				ckt.getDailyPeak(c1).getTemperature().getEffTemp())*
				ckt.getYear(0, FormatText.getCalendarYear(cal)).getSens()));

		return Math.round(getDayThree())*calc;
	}

	public double getDayFive() throws SQLException{
		Calendar c1 = (Calendar)cal.clone();
		Calendar c2= (Calendar)cal.clone();
		c1.add(Calendar.DATE, 3);
		c2.add(Calendar.DATE, 4);
		double calc=(1+((ckt.getDailyPeak(c2).getTemperature().getEffTemp()-
				ckt.getDailyPeak(c1).getTemperature().getEffTemp())*
				ckt.getYear(0, FormatText.getCalendarYear(cal)).getSens()));

		return Math.round(getDayFour())*calc;
	}
}