/*
 * Copyright (c) 2002-2010 ESP Suite. All Rights Reserved.
 *
 *     
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Authors: Technology Integration Group, SCE
 * Developers: Eddie Mayfield, Frank Gonzales, Augustin Muniz,
 * Kate Suwan, Hiro Kushida, Andrew McNaughton, Brian Stonerock,
 * Russell Ragsdale, Patrick Ridge, Everett Aragon.
 * 
 */
package com.sce.javadna;

import java.sql.SQLException;
import java.sql.Time;
import java.util.Calendar;
import java.util.TreeSet;

import com.sce.esp.object.jpa.EntityManagerHelper;
import com.sce.esp.object.model.AutomatedEquipment;
import com.sce.esp.object.model.Ckt;
import com.sce.esp.object.model.CktEdnaRead;
import com.sce.esp.object.model.Department;
import com.sce.esp.object.model.User;
import com.sce.esp.util.Calculate;
import com.sce.esp.util.ESPProperties;
import com.sce.esp.util.FormatText;
import com.sce.esp.util.db.PDBConnection;

public class PeakGetter {
	private TreeSet<AutomatedEquipment> aes = new TreeSet<AutomatedEquipment>();
	private boolean dryRun=true;
	public PeakGetter(){
	}

	public void setDryRun(boolean dryRun){
		this.dryRun = dryRun;
	}

	public boolean isDryRun(){
		return dryRun;
	}

	public void addSub(AutomatedEquipment ae){
		aes.add(ae);
	}
	
	
	/**
	 * Obtain coincident peak
	 * @param dataPoint - a valid data point
	 * @param date Date of peak
	 * @param hour in military time
	 * @param minute 
	 * @param second
	 * @return HistoryRead object
	 */
	public static HistoryRead getCoinPeakRead(String dataPoint, Calendar date, int hour, int minute, int second){
		Calendar pt = Calculate.getCal();
		pt.set(Calendar.HOUR_OF_DAY,hour);
		pt.set(Calendar.MINUTE,second);
		pt.set(Calendar.SECOND,minute);
		pt.add(Calendar.MINUTE,-5);
		String peakStartDate=FormatText.USER_DATE.format(date.getTime())+" "+JavaDNA.TIME.format(pt.getTime());
		pt.add(Calendar.MINUTE,10);
		String peakEndDate=FormatText.USER_DATE.format(date.getTime())+" "+JavaDNA.TIME.format(pt.getTime());
		
		long key = JavaDNA.initHistMax(dataPoint, peakStartDate, peakEndDate, "10");
		return JavaDNA.getNextHistory(key);
	}

	public MinMaxHistRead getBounds(AutomatedEquipment ae, Calendar startDate, Calendar endDate, Time sTime, Time eTime){
		MinMaxHistRead mmhr = new MinMaxHistRead();
		Calendar date = (Calendar)startDate.clone();
		long key;
		while(endDate.compareTo(date) > -1){
			long period = ((eTime.getTime()-sTime.getTime())/60000);
			String sdt = ""+JavaDNA.DATE.format(date.getTime())+" "+sTime;
			String edt = ""+JavaDNA.DATE.format(date.getTime())+" "+eTime;
			//System.out.println(sdt+" "+edt+" "+period);
			if(ae.getADp() != null){
				key = JavaDNA.initHistMax(ae.getADp(), sdt, edt, ""+period);
				HistoryRead maxHr = JavaDNA.getNextHistory(key);
				if(mmhr.getMaxHr() == null || maxHr.getValue() > mmhr.getMaxHr().getValue())
					mmhr.setMaxHr(maxHr,"A");
				key = JavaDNA.initHistMin(ae.getADp(), sdt, edt, ""+period);
				HistoryRead minHr = JavaDNA.getNextHistory(key);
				if(mmhr.getMinHr() == null || minHr.getValue() < mmhr.getMinHr().getValue())
					mmhr.setMinHr(minHr,"A");
			}
			if(ae.getBDp() != null){
				key = JavaDNA.initHistMax(ae.getBDp(), sdt, edt, ""+period);
				HistoryRead maxHr = JavaDNA.getNextHistory(key);
				if(mmhr.getMaxHr() == null || maxHr.getValue() > mmhr.getMaxHr().getValue())
					mmhr.setMaxHr(maxHr,"B");
				key = JavaDNA.initHistMin(ae.getBDp(), sdt, edt, ""+period);
				HistoryRead minHr = JavaDNA.getNextHistory(key);

				if(mmhr.getMinHr() == null || minHr.getValue() < mmhr.getMinHr().getValue())
					mmhr.setMinHr(minHr,"B");
			}
			if(ae.getCDp() != null){
				key = JavaDNA.initHistMax(ae.getCDp(), sdt, edt, ""+period);
				HistoryRead maxHr = JavaDNA.getNextHistory(key);
				if(mmhr.getMaxHr() == null || maxHr.getValue() > mmhr.getMaxHr().getValue())
					mmhr.setMaxHr(maxHr,"C");
				key = JavaDNA.initHistMin(ae.getCDp(), sdt, edt, ""+period);
				HistoryRead minHr = JavaDNA.getNextHistory(key);
				if(mmhr.getMinHr() == null || minHr.getValue() < mmhr.getMinHr().getValue())
					mmhr.setMinHr(minHr,"C");
			}
			date.add(Calendar.DATE, 1);
		}
		return mmhr;
	}

	public MinMaxHistRead getBounds(AutomatedEquipment ae, Calendar startDate, Calendar endDate){
		MinMaxHistRead mmhr = new MinMaxHistRead();
		long period = ((endDate.getTimeInMillis()-startDate.getTimeInMillis())/60000);
		String sdt = ""+JavaDNA.DATE.format(startDate.getTime())+" 00:00:00";
		String edt = ""+JavaDNA.DATE.format(endDate.getTime())+" 23:59:59";
		//System.out.println(sdt+" "+edt+" "+period);
		if(ae.getADp() != null){
			long key = JavaDNA.initHistMax(ae.getADp(), sdt, edt, ""+period);
			HistoryRead maxHr = JavaDNA.getNextHistory(key);
			key = JavaDNA.initHistMin(ae.getADp(), sdt, edt, ""+period);
			HistoryRead minHr = JavaDNA.getNextHistory(key);
			if(mmhr.getMaxHr() == null || maxHr.getValue() > mmhr.getMaxHr().getValue())
				mmhr.setMaxHr(maxHr,"A");
			if(mmhr.getMinHr() == null || minHr.getValue() < mmhr.getMinHr().getValue())
				mmhr.setMinHr(minHr,"A");
		}
		if(ae.getBDp() != null){
			long key = JavaDNA.initHistMax(ae.getBDp(), sdt, edt, ""+period);
			HistoryRead maxHr = JavaDNA.getNextHistory(key);
			key = JavaDNA.initHistMin(ae.getBDp(), sdt, edt, ""+period);
			HistoryRead minHr = JavaDNA.getNextHistory(key);
			if(mmhr.getMaxHr() == null || maxHr.getValue() > mmhr.getMaxHr().getValue())
				mmhr.setMaxHr(maxHr,"B");
			if(mmhr.getMinHr() == null || minHr.getValue() < mmhr.getMinHr().getValue())
				mmhr.setMinHr(minHr,"B");
		}
		if(ae.getCDp() != null){
			long key = JavaDNA.initHistMax(ae.getCDp(), sdt, edt, ""+period);
			HistoryRead maxHr = JavaDNA.getNextHistory(key);
			key = JavaDNA.initHistMin(ae.getCDp(), sdt, edt, ""+period);
			HistoryRead minHr = JavaDNA.getNextHistory(key);
			if(mmhr.getMaxHr() == null || maxHr.getValue() > mmhr.getMaxHr().getValue())
				mmhr.setMaxHr(maxHr,"C");
			if(mmhr.getMinHr() == null || minHr.getValue() < mmhr.getMinHr().getValue())
				mmhr.setMinHr(minHr,"C");
		}
		return mmhr;
	}
	public void insertRecord(AutomatedEquipment ae, String period, MinMaxHistRead mmhr) throws SQLException{
		if(mmhr == null) return;
		CktEdnaRead ccr = new CktEdnaRead(ae.getPlanyear(),((Ckt)ae).getCktId(),period);
		if(mmhr.getMinHr() != null){
			ccr.setMinValue(mmhr.getMinHr().getValue());
			ccr.setMinTime(mmhr.getMinHr().getCalendar());
			ccr.setMinStatus(mmhr.getMinHr().getStatus());
			ccr.setMinPhase(mmhr.getMinPhase());
		}
		if(mmhr.getMaxHr() != null){
			ccr.setMaxValue(mmhr.getMaxHr().getValue());
			ccr.setMaxTime(mmhr.getMaxHr().getCalendar());
			ccr.setMaxStatus(mmhr.getMaxHr().getStatus());
			ccr.setMaxPhase(mmhr.getMaxPhase());
		}
		try{
			ccr.insert();
		}
		catch(Exception e){
			System.out.println(e.getMessage());
		}
	}

	public void run() throws SQLException{
		System.out.println("Running for: "+aes.size()+" objects");
		for(AutomatedEquipment ae:aes){
			long sTime = System.currentTimeMillis();
			if(!dryRun)
				System.out.print(ae);
			MinMaxHistRead mmhr;
			if(CktEdnaRead.getInstance(ae.getPlanyear(), ((Ckt)ae).getCktId(),"2009 WINTER") == null){
				if(!dryRun){
					mmhr = getBounds(ae,Calculate.getCal(2008, Calendar.DECEMBER, 20),Calculate.getCal(2009, Calendar.MARCH, 19), Calculate.getTime(7, 30, 0), Calculate.getTime(17, 0, 0));
					System.out.println(" "+mmhr.getMaxHr()+" "+mmhr.getMinHr());
					insertRecord(ae,"2009 WINTER",mmhr);
				}
				else
					System.out.println(ae+" 2009 WINTER");
			}
			if(CktEdnaRead.getInstance(ae.getPlanyear(), ((Ckt)ae).getCktId(),"2009 SPRING") == null){
				if(!dryRun){
					mmhr = getBounds(ae,Calculate.getCal(2009, Calendar.MARCH, 20),Calculate.getCal(2009, Calendar.JUNE, 19), Calculate.getTime(5, 0, 0), Calculate.getTime(19, 0, 0));
					System.out.println(ae+" "+mmhr.getMaxHr()+" "+mmhr.getMinHr());
					insertRecord(ae,"2009 SPRING",mmhr);
				}
				else
					System.out.println(ae+" 2009 SPRING");
			}
			if(CktEdnaRead.getInstance(ae.getPlanyear(), ((Ckt)ae).getCktId(),"2009 SUMMER") == null){
				if(!dryRun){
					mmhr = getBounds(ae,Calculate.getCal(2009, Calendar.JUNE, 20),Calculate.getCal(2009, Calendar.SEPTEMBER, 19), Calculate.getTime(5, 0, 0), Calculate.getTime(19, 0, 0));
					System.out.println(ae+" "+mmhr.getMaxHr()+" "+mmhr.getMinHr());
					insertRecord(ae,"2009 SUMMER",mmhr);
				}
				else
					System.out.println(ae+" 2009 SUMMER");
			}
			if(CktEdnaRead.getInstance(ae.getPlanyear(), ((Ckt)ae).getCktId(),"2009 FALL") == null){
				if(!dryRun){
					mmhr = getBounds(ae,Calculate.getCal(2009, Calendar.SEPTEMBER, 20),Calculate.getCal(2009, Calendar.DECEMBER, 19), Calculate.getTime(6, 30, 0), Calculate.getTime(17, 0, 0));
					System.out.println(ae+" "+mmhr.getMaxHr()+" "+mmhr.getMinHr());
					insertRecord(ae,"2009 FALL",mmhr);
				}
				else
					System.out.println(ae+" 2009 FALL");
			}
			if(CktEdnaRead.getInstance(ae.getPlanyear(), ((Ckt)ae).getCktId(),"2009") == null){
				if(!dryRun){
					mmhr = getBounds(ae,Calculate.getCal(2009, Calendar.JANUARY, 1),Calculate.getCal(2009, Calendar.DECEMBER, 31));
					System.out.println(ae+" "+mmhr.getMaxHr()+" "+mmhr.getMinHr());
					insertRecord(ae,"2009",mmhr);
				}
				else
					System.out.println(ae+" 2009");
			}
			if(!dryRun)
				System.out.println("Object Time: "+((System.currentTimeMillis()-sTime)/1000)+" secs");
		}
	}



	public static void mergeDataSets() throws SQLException{
		int count = Department.getInstance(2010).getCktEdnaReads().size();
		int done=0;
		for(CktEdnaRead ccr:Department.getInstance(2010).getCktEdnaReads()){
			if(ccr.getPeriod().length() > 5 && !ccr.getPeriod().contains(" MIN-NAX") && ccr.getMaxTime() == null){
				CktEdnaRead ccr2 = CktEdnaRead.getInstance(ccr.getPlanyear(), ccr.getCktId(), ccr.getPeriod()+" MIN-NAX");
				System.out.println(ccr2.getHashKey()+" ==> "+ccr.getHashKey());
				ccr.setMaxValue(ccr2.getMaxValue());
				ccr.setMaxTime(ccr2.getMaxTime());
				ccr.setMaxStatus(ccr2.getMaxStatus());
				ccr.setMaxPhase(ccr2.getMaxPhase());
			}
			done++;
			System.out.println("Completed "+done+" of "+count);
		}
	}
	public static void finalDataCheck() throws SQLException{
		int count=0;
		System.out.print("Gathering data...");
		Department.getInstance(2010).getCkts();
		Department.getInstance(2010).getCktEdnaReads();
		System.out.println("done");
		for(CktEdnaRead ccr:Department.getInstance(2010).getCktEdnaReads()){
			CktEdnaRead win=null, spr=null, sum=null, fall=null;
			boolean error=false;
			if(ccr.getPeriod().equals("2009")){
				win = CktEdnaRead.getInstance(ccr.getPlanyear(), ccr.getCktId(), "2009 WINTER");
				if(win.getMaxValue() > ccr.getMaxValue()){
					ccr.setMaxValue(win.getMaxValue());
					ccr.setMaxTime(win.getMaxTime());
					ccr.setMaxPhase(win.getMaxPhase());
					ccr.setMaxStatus(win.getMaxStatus());
				}
				if(win.getMinValue() < ccr.getMinValue()){
					ccr.setMinValue(win.getMinValue());
					ccr.setMinTime(win.getMinTime());
					ccr.setMinPhase(win.getMinPhase());
					ccr.setMinStatus(win.getMinStatus());
				}
				spr = CktEdnaRead.getInstance(ccr.getPlanyear(), ccr.getCktId(), "2009 SPRING");
				if(spr.getMaxValue() > ccr.getMaxValue()){
					ccr.setMaxValue(spr.getMaxValue());
					ccr.setMaxTime(spr.getMaxTime());
					ccr.setMaxPhase(spr.getMaxPhase());
					ccr.setMaxStatus(spr.getMaxStatus());
				}
				if(spr.getMinValue() < ccr.getMinValue()){
					ccr.setMinValue(spr.getMinValue());
					ccr.setMinTime(spr.getMinTime());
					ccr.setMinPhase(spr.getMinPhase());
					ccr.setMinStatus(spr.getMinStatus());
				}
				sum = CktEdnaRead.getInstance(ccr.getPlanyear(), ccr.getCktId(), "2009 SUMMER");
				if(sum.getMaxValue() > ccr.getMaxValue()){
					ccr.setMaxValue(sum.getMaxValue());
					ccr.setMaxTime(sum.getMaxTime());
					ccr.setMaxPhase(sum.getMaxPhase());
					ccr.setMaxStatus(sum.getMaxStatus());
				}
				if(sum.getMinValue() < ccr.getMinValue()){
					ccr.setMinValue(sum.getMinValue());
					ccr.setMinTime(sum.getMinTime());
					ccr.setMinPhase(sum.getMinPhase());
					ccr.setMinStatus(sum.getMinStatus());
				}
				fall = CktEdnaRead.getInstance(ccr.getPlanyear(), ccr.getCktId(), "2009 FALL");
				if(fall.getMaxValue() > ccr.getMaxValue()){
					ccr.setMaxValue(fall.getMaxValue());
					ccr.setMaxTime(fall.getMaxTime());
					ccr.setMaxPhase(fall.getMaxPhase());
					ccr.setMaxStatus(fall.getMaxStatus());
				}
				if(fall.getMinValue() < ccr.getMinValue()){
					ccr.setMinValue(fall.getMinValue());
					ccr.setMinTime(fall.getMinTime());
					ccr.setMinPhase(fall.getMinPhase());
					ccr.setMinStatus(fall.getMinStatus());
				}
				if(error){				
					count++;
					System.out.println("**************************************Error with "+ccr.getCkt()+"*************************************");
					System.out.println(ccr);
					System.out.println(win);
					System.out.println(spr);
					System.out.println(sum);
					System.out.println(fall);
				}
			}
		}
		System.out.println(count+" need to be fixed");
	}
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		boolean merge=false, finalDataCheck=true;
		long sTime = System.currentTimeMillis();
		System.out.println("Peak Getter Started");
		PeakGetter pg = new PeakGetter();
		//pg.setDryRun(true);
		try {
			String userName=System.getProperty("user.name").toLowerCase();
			EntityManagerHelper.init(ESPProperties.getInstance().getDevDbUrl(), userName, "edison");
			if(merge)
				mergeDataSets();
			else if(finalDataCheck)
				finalDataCheck();
			else{
				for(Ckt ckt:Department.getInstance(2010).getCkts()){
					if(ckt.isPAutomated())
						pg.addSub(ckt);
					//					runRaw(ckt,"min",Calculate.getCal(2008, Calendar.DECEMBER, 20),Calculate.getCal(2010, Calendar.JANUARY, 1),"30");
					//				CktEdnaRaw.getHashtable().clear();
				}
				//pg.addSub(Sub.getInstanceBySubName(2010, "Alder", 12));
				//pg.addSub(Sub.getInstanceBySubName(2010, "Randall", 12));
				pg.run();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println("Total Time: "+((System.currentTimeMillis()-sTime)/1000)+" secs");
	}


	private class MinMaxHistRead{
		private HistoryRead maxHr;
		private HistoryRead minHr;
		private String maxPhase;
		private String minPhase;

		public void setMaxHr(HistoryRead maxHr, String phase){
			setMaxHr(maxHr);
			setMaxPhase(phase);
		}
		public void setMinHr(HistoryRead minHr, String phase){
			setMinHr(minHr);
			setMinPhase(phase);
		}
		public void setMaxHr(HistoryRead maxHr){
			this.maxHr = maxHr;
		}
		public void setMinHr(HistoryRead minHr){
			this.minHr = minHr;
		}
		public HistoryRead getMaxHr(){
			return maxHr;
		}
		public HistoryRead getMinHr(){
			return minHr;
		}
		public void setMinPhase(String minPhase){
			this.minPhase = minPhase;
		}
		public String getMinPhase(){
			return minPhase;
		}
		public void setMaxPhase(String maxPhase){
			this.maxPhase = maxPhase;
		}
		public String getMaxPhase(){
			return maxPhase;
		}
	}

}

/*
create table mdix10_ckt_edna_raw(
		  planyear number(9,0) not null,
		  ckt_id number(9,0) not null,
		  Phase varchar2(2) not null,
		  Read_type varchar2(3) not null,
		  Hour_Interval float(24) not null,
		  time_stamp TIMESTAMP,
		  read_value float(24),
		  status  varchar(32),
		  insert_ts date,
			insert_user_id number(9,0),
			modified_ts date,
			modified_user_id number(9,0),
			deleted_ts date,
			deleted_user_id number(9,0),
		  constraint mdix10_pk primary key(planyear,ckt_id,phase,read_type,time_stamp),
		  constraint mdix10_fk01 foreign key(planyear,ckt_id) references mdi220_ckt(planyear,ckt_id),
		  CONSTRAINT mdix10_fk02 FOREIGN KEY(insert_user_id) REFERENCES mdi.mdi000_user(username_id),
			CONSTRAINT mdix10_fk03 FOREIGN KEY(modified_user_id) REFERENCES mdi.mdi000_user(username_id),
			CONSTRAINT mdix10_fk04 FOREIGN KEY(deleted_user_id) REFERENCES mdi.mdi000_user(username_id)
		);

		create table mdix20_ckt_cpuc_req(
		  planyear number(9,0) not null,
		  ckt_id number(9,0) not null,
		  Period varchar2(20) not null,
		  min_value float(24),
      min_time timestamp,
      min_status varchar(32),
      min_phase varchar2(5),
		  max_value float(24),
		  max_time TIMESTAMP,
		  max_status  varchar(32),
		  max_phase varchar2(5),
		  insert_ts date,
			insert_user_id number(9,0),
			modified_ts date,
			modified_user_id number(9,0),
			deleted_ts date,
			deleted_user_id number(9,0),
		  constraint mdix20_pk primary key(planyear,ckt_id,period),
		  constraint mdix20_fk01 foreign key(planyear,ckt_id) references mdi220_ckt(planyear,ckt_id),
		  CONSTRAINT mdix20_fk02 FOREIGN KEY(insert_user_id) REFERENCES mdi.mdi000_user(username_id),
			CONSTRAINT mdix20_fk03 FOREIGN KEY(modified_user_id) REFERENCES mdi.mdi000_user(username_id),
			CONSTRAINT mdix20_fk04 FOREIGN KEY(deleted_user_id) REFERENCES mdi.mdi000_user(username_id)
		);

		GRANT SELECT, UPDATE, INSERT, DELETE ON MDI.mdix20_ckt_cpuc_req TO MDI_R_USER
		/
 */
