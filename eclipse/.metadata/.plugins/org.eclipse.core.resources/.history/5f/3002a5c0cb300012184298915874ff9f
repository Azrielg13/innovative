/*
 * Copyright (c) 2002-2010 ESP Suite. All Rights Reserved.
 *
 *     
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Authors: Technology Integration Group, SCE
 * Developers: Eddie Mayfield, Frank Gonzales, Augustin Muniz,
 * Kate Suwan, Hiro Kushida, Andrew McNaughton, Brian Stonerock,
 * Russell Ragsdale, Patrick Ridge, Everett Aragon.
 * 
 */
package com.sce.esp.component;

import java.awt.Component;

import com.sce.esp.util.Calculate;
import com.sce.esp.util.ESPFont;
import com.sce.esp.util.StringNoEdit;

/**
 * The Class TotalRow.
 * 
 * @author Distribution Staff Engineering
 * @version 2.0
 */
public abstract class TotalRow extends ESPExpandableRow {

	/** The Constant BLANKSTRING. */
	public final static String BLANKSTRING = "___";

	/** The Constant BLANKSTRING. */
	public final static String UNKNOWN = " ? ";

	/** The Constant BLANK. */
	public final static int BLANK = 0;

	/** The Constant SUM. */
	public final static int SUM = 1;

	/** The Constant AVG. */
	public final static int AVG = 2;

	/** The Constant BOOL. */
	public final static int BOOL = 3;

	/** The Constant SUM_MVA_2_AMPS. */
	public final static int SUM_MVA_2_AMPS = 4;

	/** The Constant CHILDVALUE. */
	public final static int CHILDVALUE = 5;

	/** The Constant AVG_2_DECIMAL. */
	public final static int AVG_2_DECIMAL = 6;

	/** The Constant SUM_MVA. */
	public final static int SUM_MVA = 7;

	/** The Constant CONCAT. */
	public final static int CONCAT = 8;

	public final static int NOTHING = 9;

	public final static int SUM_NO_ZERO = 10;

	public final static int AVG_NO_ZERO = 11;

	/** The title. */
	private String title;

	/** The mva factor. */
	private double mvaFactor;

	private Component c;

	/**
	 * The Constructor.
	 * 
	 * @param title
	 *            the title
	 */
	public TotalRow(Component c, String title) {
		this(c, title, 0);
	}

	/**
	 * The Constructor.
	 * 
	 * @param title
	 *            the title
	 * @param mvaFactor
	 *            the mva factor
	 */
	public TotalRow(Component c, String title, double mvaFactor) {
		this.c = c;
		this.title = title;
		this.mvaFactor = mvaFactor;
	}

	/**
	 * Gets the title.
	 * 
	 * @return the title
	 */
	public String getTitle() {
		return title;
	}

	/**
	 * Sets the title.
	 * 
	 * @param title
	 *            the title
	 */
	public void setTitle(String title) {
		this.title = title;
	}

	public double getMVAFactor() {
		return mvaFactor;
	}

	/**
	 * Gets the column behavior.
	 * 
	 * @param col
	 *            the col
	 * 
	 * @return the column behavior
	 */
	public abstract int getColumnBehavior(int col);

	/**
	 * Returns object at a column.
	 * 
	 * @param col
	 *            the col
	 * @param columnIndex
	 *            index of column in row
	 * 
	 * @return value of the column
	 */
	public Object getValueAt(int col) {
		if (col == 0)
			return title;
		switch (getColumnBehavior(col)) {
			case BLANK :
				return BLANKSTRING;
			case SUM : {
				double sum = getChildSum(col);
				if (sum != (int) sum) // Determine if value should be a Double
										// or Integer
					return Calculate.round(sum, 1);
				else
					return Math.round(sum);
			}
			case SUM_NO_ZERO : {
				double sum = getChildSum(col);
				if (sum == 0)
					return null;
				if (sum != (int) sum) // Determine if value should be a Double
										// or Integer
					return Calculate.round(sum, 1);
				else
					return Math.round(sum);
			}
			case SUM_MVA_2_AMPS :
				return Math.round(getChildMVASum(col) * mvaFactor);
			case SUM_MVA :
				return Calculate.round(getChildMVASum(col), 1);
			case AVG :
				return Calculate
						.round(getChildSum(col) / getChildrenCount(), 1);
			case BOOL :
				return allChildrenTrue(col);
			case CHILDVALUE :
				return ((ESPExpandableRow) getChildAt(0)) != null
						? ((ESPExpandableRow) getChildAt(0)).getValueAt(col)
						: BLANKSTRING;
			case AVG_2_DECIMAL :
				return Calculate
						.round(getChildSum(col) / getChildrenCount(), 2);
			case CONCAT :
				return getChildConcat(col);
			case NOTHING :
				return null;
		}
		return null;
	}

	/**
	 * Gets the child concat.
	 * 
	 * @param col
	 *            the col
	 * 
	 * @return the child concat
	 */
	private StringNoEdit getChildConcat(int col) {
		String str = "";
		for (int x = 0; x < getChildrenCount(); x++) {
			Object value = ((ESPExpandableRow) getChildAt(x)).getValueAt(col);
			if (value != null && !value.toString().equals(BLANKSTRING)
					&& !value.toString().equals(UNKNOWN))
				str += value.toString() + ";  ";
		}
		return new StringNoEdit(str);
	}

	/**
	 * Gets the child sum.
	 * 
	 * @param col
	 *            the col
	 * 
	 * @return the child sum
	 */
	public double getChildSum(int col) {
		double sum = 0;
		for (int x = 0; x < getChildrenCount(); x++) {
			Object value = ((ESPExpandableRow) getChildAt(x)).getValueAt(col);
			if (value != null && !value.toString().equals(BLANKSTRING)
					&& !value.toString().equals(UNKNOWN))
				if (isAN(value))
					sum += Double.parseDouble(value.toString());
		}
		return sum;
	}

	private boolean isAN(Object value) {
		try {
			Double.parseDouble(value.toString());
		} catch (NumberFormatException nfe) {
			return false;
		}
		return true;
	}

	/**
	 * Gets the child MVA sum.
	 * 
	 * @param col
	 *            the col
	 * 
	 * @return the child MVA sum
	 */
	public double getChildMVASum(int col) {
		double sum = 0;
		for (int x = 0; x < getChildrenCount(); x++) {
			Object value;
			if (getChildAt(x) instanceof TotalRow)
				value = ((TotalRow) getChildAt(x)).getChildMVASum(col);
			else
				value = ((AbstractDataRow) getChildAt(x)).getMVAValueAt(col);
			if (value != null && !value.toString().equals(BLANKSTRING)
					&& !value.toString().equals(UNKNOWN))
				sum += Double.parseDouble(value.toString());
		}
		return sum;
	}

	/**
	 * All children true.
	 * 
	 * @param col
	 *            the col
	 * 
	 * @return true, if all children true
	 */
	public boolean allChildrenTrue(int col) {
		for (int x = 0; x < getChildrenCount(); x++) {
			if (!Boolean.parseBoolean(((ESPExpandableRow) getChildAt(x))
					.getValueAt(col).toString()))
				return false;
		}
		return true;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.jidesoft.grid.Row#isCellEditable(int)
	 */
	/**
	 * Checks if is cell editable.
	 * 
	 * @param col
	 *            the col
	 * 
	 * @return true, if is cell editable
	 */
	public boolean isCellEditable(int col) {
		return (getColumnBehavior(col) == BOOL);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.jidesoft.grid.Row#setValueAt(java.lang.Object, int)
	 */
	/**
	 * Sets the value at.
	 * 
	 * @param col
	 *            the col
	 * @param value
	 *            the value
	 */
	public void setValueAt(Object value, int col) {
		if (getColumnBehavior(col) == BOOL) {
			for (int x = 0; x < getChildrenCount(); x++)
				((ESPExpandableRow) getChildAt(x)).setValueAt(value, col);
		}
		c.repaint();
	}

	/**
	 * Gets the font.
	 * 
	 * @param col
	 *            the col
	 * 
	 * @return the font
	 */
	public ESPFont getFont(int col) {
		return ESPFont.CIRCUIT_TOTAL;
	}
}
