/*
 * Copyright (c) 2002-2010 ESP Suite. All Rights Reserved.
 *
 *     
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Authors: Technology Integration Group, SCE
 * Developers: Eddie Mayfield, Frank Gonzales, Augustin Muniz,
 * Kate Suwan, Hiro Kushida, Andrew McNaughton, Brian Stonerock,
 * Russell Ragsdale, Patrick Ridge, Everett Aragon.
 * 
 */
package com.sce.esp.component;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.sql.SQLException;
import java.util.Collection;

import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;

import com.jidesoft.combobox.TableComboBox;
import com.jidesoft.combobox.TableComboBoxSearchable;
import com.jidesoft.grid.JideTable;
import com.sce.esp.security.TopFlight;

public abstract class DynamicTableComboBox /*
											 * extends TableComboBoxSearchable
											 * implements ItemListener {
											 */extends TableComboBox
		implements
			ItemListener {

	private Object obj;
	protected boolean update;
	protected boolean isEditing;
	private Component c;
	private int userRole;

	/**
	 * The Constructor.
	 * 
	 * @param obj
	 *            the obj
	 * @param field
	 *            the field
	 * @param treeSet
	 * @param
	 */
	public DynamicTableComboBox(Component c, DefaultTableModel cm, Object obj, int userRole, Collection<?> items, boolean allowNull) {
		this(c, cm, obj, userRole);
		if (allowNull)
			addItem(null);
		for (Object item : items)
			addItem(item);
	}

	public DynamicTableComboBox(Component c, DefaultTableModel cm, Object obj,
			int userRole) {
		super(cm);
		this.c = c;
		this.obj = obj;
		this.userRole = userRole;

		this.setEditable(false); // combobox searchable only works when combobox
									// is not editable.
		addItemListener(this);

		new TableComboBoxSearchable(this);
		JideTable searchTable = new JideTable(cm);
		searchTable.setRowHeight(50);
		searchTable.setColumnAutoResizable(true);
		TableColumn col2 = searchTable.getColumnModel().getColumn(0);
//		col2.setMaxWidth(275);
//		col2.setMinWidth(275);
		
		TableColumn col3 = searchTable.getColumnModel().getColumn(1);
//		col3.setMaxWidth(274);
//		col3.setMinWidth(274);
		
//		searchTable.setRowHeight(75);
		
		searchTable.setPreferredScrollableViewportSize(new Dimension(600, 100));
		searchTable.setColumnSelectionAllowed(false);
		searchTable.setRowSelectionAllowed(true);
//		SearchableUtils.installSearchable(searchTable);
	}
	
	/**
	 * Gets the object.
	 * 
	 * @return the object
	 */
	public Object getObject() {
		return obj;
	}

	/**
	 * Adds the item.
	 * 
	 * @param o
	 *            the o
	 */
	public void addItem(Object o) {
		update = false;
		super.addItem(o);
		update = true;
	}
	
//	@Override
//	protected JTable createTable(TableModel model) {
//    	SortableTable t = new SortableTable(model);
//    	t.setRowHeight(500);
//    	t.setColumnAutoResizable(true);
//        return  t;
//    }

	/**
	 * Paint component.
	 * 
	 * @param g
	 *            the g
	 */
	public void paintComponent(Graphics g) {
		Object o = getObject();
		try {
			if (!hasFocus()
					&& !isEditing
					&& o != null
					&& (getSelectedItem() != getObjectValue() || (getObjectValue() == null && getSelectedIndex() != 0))) {
				update = false;
				if (getObjectValue() == null) {
					if (this.getModel().getSize() > 0)
						// if(this.getgetItemCount() > 0){//BME ESP need the
						// same fix here
						setSelectedIndex(0);
					// }
				} else {
					setSelectedItem(getObjectValue());
				}
				update = true;
			}
			if (shouldBeEnabled() != isEnabled())
				setEnabled(shouldBeEnabled());
		} catch (Exception e) {
			e.printStackTrace();
		}
		super.paintComponent(g);
	}

	// public abstract boolean shouldBeEnabled() throws SQLException;
	public boolean shouldBeEnabled() throws SQLException {
		return getObject() != null && hasPermission();
	}

	public boolean hasPermission() throws SQLException {
		return TopFlight.getInstance().hasAccessRight(userRole);
	}

	/**
	 * Item state changed.
	 * 
	 * @param ie
	 *            the ie
	 */

	public void itemStateChanged(ItemEvent ie) {
		try {
			if (update && ie.getStateChange() == ItemEvent.SELECTED) {
				updateObject();
				c.repaint();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	public abstract void updateObject() throws SQLException;
	public abstract Object getObjectValue() throws SQLException;
	public void makeSponsorOrgComboBx() {

	}
}
