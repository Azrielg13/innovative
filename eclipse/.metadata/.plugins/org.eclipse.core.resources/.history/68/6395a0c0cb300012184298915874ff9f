package com.sce.esp.component;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.dnd.Autoscroll;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DragGestureEvent;
import java.awt.dnd.DragGestureListener;
import java.awt.dnd.DragGestureRecognizer;
import java.awt.dnd.DragSource;
import java.awt.dnd.DragSourceDragEvent;
import java.awt.dnd.DragSourceDropEvent;
import java.awt.dnd.DragSourceEvent;
import java.awt.dnd.DragSourceListener;
import java.awt.dnd.DropTarget;
import java.awt.dnd.DropTargetContext;
import java.awt.dnd.DropTargetDragEvent;
import java.awt.dnd.DropTargetDropEvent;
import java.awt.dnd.DropTargetEvent;
import java.awt.dnd.DropTargetListener;
import java.io.IOException;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;

import com.jidesoft.grid.Property;
import com.jidesoft.grid.PropertyPane;
import com.jidesoft.grid.PropertyTable;
import com.jidesoft.grid.PropertyTableModel;
import com.jidesoft.swing.JideBoxLayout;
import com.jidesoft.swing.JideSplitPane;
import com.jidesoft.swing.JideSwingUtilities;
import com.sce.esp.object.model.Cable;
import com.sce.esp.object.model.User;
import com.sce.esp.util.IconsFactory;

/**
 *
 * @author Distribution Staff Engineering
 *
 */
public class CableDragTree extends JFrame implements TreeSelectionListener {

	protected TreeDragSource ds;
	protected TreeDropTarget dt;

	protected JTree tree;
	protected HashMap<String,Object> cableMap = new HashMap<String,Object>();

	public CableDragTree(int planyear) throws SQLException {
		super("Cable Library");
		setSize(550, 525);
		setIconImage(IconsFactory.getImageIcon(IconsFactory.DUCTBANK.DUCT).getImage());
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);

		final TreeModel treeModel = MDITreeModel.createCableTreeModel(planyear);
		tree = new AutoScrollingJTree(treeModel);

		PropertyTable cablePropertiesTable = new PropertyTable();
		cablePropertiesTable.setModel(createCableModel());
		cablePropertiesTable.expandFirstLevel();
		cablePropertiesTable.setPreferredScrollableViewportSize(new Dimension(400, 400));
		PropertyPane propertyPane = new PropertyPane(cablePropertiesTable);
		JPanel propertiesPanel = new JPanel(new BorderLayout());
		propertiesPanel.add(propertyPane,BorderLayout.WEST);

		JideSplitPane navSplit = new JideSplitPane(JideSplitPane.HORIZONTAL_SPLIT);
		navSplit.add(new JScrollPane(tree), JideBoxLayout.FLEXIBLE);
		navSplit.add(new JScrollPane(propertiesPanel), JideBoxLayout.VARY);

		getContentPane().add(navSplit, BorderLayout.CENTER);

		// If we only support move operations...
		//ds = new TreeDragSource(tree, DnDConstants.ACTION_MOVE);
		ds = new TreeDragSource(tree, DnDConstants.ACTION_COPY_OR_MOVE);
		//dt = new TreeDropTarget(tree);

		addTreeListener(tree);
		tree.setSelectionRow(1);

		JideSwingUtilities.globalCenterWindow(this);
		setVisible(true);
	}

	private void addTreeListener(final JTree jTree){
		jTree.addTreeSelectionListener(this);
	}

	private PropertyTableModel<CableProperty> createCableModel() {

		ArrayList<CableProperty> list = new ArrayList<CableProperty>();

		try {

			CableProperty property = null;

			property = new CableProperty("Cable Id", "", String.class, "Cable Properties");
			property.setEditable(false);
			list.add(property);

			property = new CableProperty("Cable Size", "", String.class, "Cable Properties");
			property.setEditable(false);
			list.add(property);

			property = new CableProperty("Cable Rating", "", String.class, "Cable Properties");
			property.setEditable(false);
			list.add(property);

			property = new CableProperty("Cable Material", "", String.class, "Cable Properties");
			property.setEditable(false);
			list.add(property);

			property = new CableProperty("Cable Construction", "", String.class, "Cable Properties");
			property.setEditable(false);
			list.add(property);

			property = new CableProperty("Insulation Material", "", String.class, "Cable Insulation");
			property.setEditable(false);
			list.add(property);

			property = new CableProperty("Insulation Construction", "", String.class, "Cable Insulation");
			property.setEditable(false);
			list.add(property);

			property = new CableProperty("USAMP ID", "", String.class, "Cable Codes");
			property.setEditable(false);
			list.add(property);

			property = new CableProperty("SCE Material Code", "", String.class, "Cable Codes");
			property.setEditable(false);
			list.add(property);

			//SCE SAP No.
			property = new CableProperty("SCE SAP No.", "", String.class, "Cable Codes");
			property.setEditable(false);
			list.add(property);


			property = new CableProperty("Conductor Diameter", "", String.class, "Cable Data");
			property.setEditable(User.getActiveUser().getUserRole().isAdmin());
			list.add(property);

			property = new CableProperty("Shield Thickness", "", String.class, "Cable Data");
			list.add(property);

			property = new CableProperty("Insulation Shield Thickness", "", String.class, "Cable Data");
			list.add(property);

			property = new CableProperty("Jacket Thickness", "", String.class, "Cable Data");
			list.add(property);

			property = new CableProperty("Rdc @25 deg. C", "", String.class, "Cable Data");
			list.add(property);

			property = new CableProperty("Shield Diameter", "", String.class, "Cable Data");
			list.add(property);

			property = new CableProperty("Shield Wires", "", String.class, "Cable Data");
			list.add(property);

			property = new CableProperty("Lay Factor", "", String.class, "Cable Data");
			list.add(property);

			property = new CableProperty("Skin Effect", "", String.class, "Cable Data");
			list.add(property);


			//PropertyTableModel model = new StripePropertyTableModel(list);

		} catch (SQLException e) {
			e.printStackTrace();
		}

		return  new StripePropertyTableModel(list);
	}

	class CableProperty extends Property {
		public CableProperty(String name, String description, Class type, String category) {
			super(name, description, type, category);
			init();
		}
		private void init() {
		}
		/* (non-Javadoc)
		 * @see com.jidesoft.grid.Property#getValue()
		 */
		@Override
		public Object getValue() {
			Object value = cableMap.get(getFullName());
			return value;
		}
		/* (non-Javadoc)
		 * @see com.jidesoft.grid.Property#hasValue()
		 */
		@Override
		public boolean hasValue() {
			return cableMap.get(getFullName()) != null;
		}
		/* (non-Javadoc)
		 * @see com.jidesoft.grid.Property#setValue(java.lang.Object)
		 */
		@Override
		public void setValue(Object arg0) {
			//DO NOTHING/something
		}
	}

	public class AutoScrollingJTree extends JTree implements Autoscroll {
		private int margin = 12;
		public AutoScrollingJTree() {
			super();
		}
		public AutoScrollingJTree(TreeModel d) {
			super(d);
		}
		public void autoscroll(Point p) {
			int realrow = getRowForLocation(p.x, p.y);
			Rectangle outer = getBounds();
			realrow = (p.y + outer.y <= margin ? realrow < 1 ? 0 : realrow - 1
					: realrow < getRowCount() - 1 ? realrow + 1 : realrow);
			scrollRowToVisible(realrow);
		}
		public Insets getAutoscrollInsets() {
			Rectangle outer = getBounds();
			Rectangle inner = getParent().getBounds();
			return new Insets(inner.y - outer.y + margin, inner.x - outer.x
					+ margin, outer.height - inner.height - inner.y + outer.y
					+ margin, outer.width - inner.width - inner.x + outer.x
					+ margin);
		}
	}

	public static void main(String args[]) {
		try {
			new CableDragTree(2007);
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	/* (non-Javadoc)
	 * @see javax.swing.event.TreeSelectionListener#valueChanged(javax.swing.event.TreeSelectionEvent)
	 */
	public void valueChanged(TreeSelectionEvent tse) {
		TreePath path = tree.getSelectionPath();
		if (path != null) {
			Object o  = ((DefaultMutableTreeNode)path.getLastPathComponent()).getUserObject();
			if(o instanceof Cable){
				Cable c = (Cable)o;
				cableMap = new HashMap<String,Object>();
				cableMap.put("Cable Id",c.getCableId());
				cableMap.put("Cable Size",c.getCableSize());
				cableMap.put("Cable Rating",c.getRating());
				cableMap.put("Cable Material",c.getMaterial());
				cableMap.put("Cable Construction",c.getConstruction());
				cableMap.put("Insulation Material",c.getInsulMaterial());
				cableMap.put("Insulation Construction",c.getInsulConst());
				cableMap.put("USAMP Id",c.getUsampId());
				cableMap.put("SCE Material Code",c.getSceMatcode());
				cableMap.put("SCE SAP No.",c.getSapNum());
				
				cableMap.put("Rdc @25 deg. C",c.getCondDcresRdc());//XXX

				cableMap.put("Conductor Diameter",c.getCondDiamDc());
				cableMap.put("Shield Thickness",c.getThickShldTcs());
				cableMap.put("Insulation Shield Thickness",c.getThickInsulShldTcs());
				cableMap.put("Jacket Thickness",c.getThickJacketTj());

				//"Shield Diameter" - D
				cableMap.put("Shield Diameter",c.getShldDiamD());
				//"Shield Wires" - N
				cableMap.put("Shield Wires",c.getShldWiresN());
				//"Lay Factor" - lF
				cableMap.put("Lay Factor",c.getLayFactorLf());
				//"Skin Effect" - Ks
				cableMap.put("Skin Effect",c.getSkinEffectKs());
				
				this.repaint();
			}
		}
	}
}

//TreeDragSource.java
//A drag source wrapper for a JTree. This class can be used to make
//a rearrangeable DnD tree with the TransferableTreeNode class as the
//transfer data type.
class TreeDragSource implements DragSourceListener, DragGestureListener {

	DragSource source;
	DragGestureRecognizer recognizer;
	TransferableCableNode transferable;
	DefaultMutableTreeNode oldNode;
	JTree sourceTree;

	public TreeDragSource(JTree tree, int actions) {
		sourceTree = tree;
		source = new DragSource();
		recognizer = source.createDefaultDragGestureRecognizer(sourceTree,actions, this);
	}

	/*
	 * Drag Gesture Handler
	 */
	public void dragGestureRecognized(DragGestureEvent dge) {
		TreePath path = sourceTree.getSelectionPath();
		if ((path == null) || (path.getPathCount() <= 1)) {
			// We can't move the root node or an empty selection
			return;
		}
		oldNode = (DefaultMutableTreeNode) path.getLastPathComponent();
		transferable = new TransferableCableNode(path);

		//source.startDrag(dge, DragSource.DefaultMoveNoDrop, transferable, this);

		// If you support dropping the node anywhere, you should probably
		// start with a valid move cursor:
		source.startDrag(dge, DragSource.DefaultCopyDrop, transferable,this);
	}

	/*
	 * Drag Event Handlers
	 */
	public void dragEnter(DragSourceDragEvent dsde) {
	}

	public void dragExit(DragSourceEvent dse) {
	}

	public void dragOver(DragSourceDragEvent dsde) {
	}

	public void dropActionChanged(DragSourceDragEvent dsde) {
		System.out.println("Action: " + dsde.getDropAction());
		System.out.println("Target Action: " + dsde.getTargetActions());
		System.out.println("User Action: " + dsde.getUserAction());
	}

	public void dragDropEnd(DragSourceDropEvent dsde) {
		/*
		 * to support move or copy, we have to check which occurred:
		 */
		System.out.println("Drop Action: " + dsde.getDropAction());
		if (dsde.getDropSuccess()
				&& (dsde.getDropAction() == DnDConstants.ACTION_MOVE)) {
			((DefaultTreeModel) sourceTree.getModel())
			.removeNodeFromParent(oldNode);
		}

		/*
		 * to support move only... if (dsde.getDropSuccess()) {
		 * ((DefaultTreeModel)sourceTree.getModel()).removeNodeFromParent(oldNode); }
		 */
	}
}


//A quick DropTarget that's looking for drops from draggable JTrees.
class TreeDropTarget implements DropTargetListener {

	DropTarget target;

	JTree targetTree;

	public TreeDropTarget(JTree tree) {
		targetTree = tree;
		target = new DropTarget(targetTree, this);
	}

	/*
	 * Drop Event Handlers
	 */
	private TreeNode getNodeForEvent(DropTargetDragEvent dtde) {
		Point p = dtde.getLocation();
		DropTargetContext dtc = dtde.getDropTargetContext();
		JTree tree = (JTree) dtc.getComponent();
		TreePath path = tree.getClosestPathForLocation(p.x, p.y);
		return (TreeNode) path.getLastPathComponent();
	}

	public void dragEnter(DropTargetDragEvent dtde) {
		TreeNode node = getNodeForEvent(dtde);
		if (node.isLeaf()) {
			dtde.rejectDrag();
		} else {
			// start by supporting move operations
			//dtde.acceptDrag(DnDConstants.ACTION_MOVE);
			dtde.acceptDrag(dtde.getDropAction());
		}
	}

	public void dragOver(DropTargetDragEvent dtde) {
		TreeNode node = getNodeForEvent(dtde);
		if (node.isLeaf()) {
			dtde.rejectDrag();
		} else {
			// start by supporting move operations
			//dtde.acceptDrag(DnDConstants.ACTION_MOVE);
			dtde.acceptDrag(dtde.getDropAction());
		}
	}

	public void dragExit(DropTargetEvent dte) {
	}

	public void dropActionChanged(DropTargetDragEvent dtde) {
	}

	public void drop(DropTargetDropEvent dtde) {
		Point pt = dtde.getLocation();
		DropTargetContext dtc = dtde.getDropTargetContext();
		JTree tree = (JTree) dtc.getComponent();
		TreePath parentpath = tree.getClosestPathForLocation(pt.x, pt.y);
		DefaultMutableTreeNode parent = (DefaultMutableTreeNode) parentpath
		.getLastPathComponent();
		if (parent.isLeaf()) {
			dtde.rejectDrop();
			return;
		}

		try {
			Transferable tr = dtde.getTransferable();
			DataFlavor[] flavors = tr.getTransferDataFlavors();
			for (int i = 0; i < flavors.length; i++) {
				if (tr.isDataFlavorSupported(flavors[i])) {
					dtde.acceptDrop(dtde.getDropAction());
					TreePath p = (TreePath) tr.getTransferData(flavors[i]);
					DefaultMutableTreeNode node = (DefaultMutableTreeNode) p
					.getLastPathComponent();
					DefaultTreeModel model = (DefaultTreeModel) tree.getModel();
					model.insertNodeInto(node, parent, 0);
					dtde.dropComplete(true);
					return;
				}
			}
			dtde.rejectDrop();
		} catch (Exception e) {
			e.printStackTrace();
			dtde.rejectDrop();
		}
	}
}


class TransferableCableNode implements Transferable {

	public static DataFlavor PATH_FLAVOR = new DataFlavor(Cable.class,"Cable");

	DataFlavor flavors[] = { PATH_FLAVOR };

	TreePath path;

	Cable cable;

	public TransferableCableNode(TreePath tp) {
		path = tp;
		if (path != null) {
			Object o  = ((DefaultMutableTreeNode)path.getLastPathComponent()).getUserObject();
			cable = (Cable)o;
		}
	}

	public synchronized DataFlavor[] getTransferDataFlavors() {
		return flavors;
	}

	public boolean isDataFlavorSupported(DataFlavor flavor) {
		return (flavor.getRepresentationClass() == Cable.class);
	}

	public synchronized Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException {
		if (isDataFlavorSupported(flavor)) {
			if (path != null) {
				Object o  = ((DefaultMutableTreeNode)path.getLastPathComponent()).getUserObject();
				cable = (Cable)o;
			}
			return (Object) cable;
		} else {
			throw new UnsupportedFlavorException(flavor);
		}
	}
}


//A Transferable TreePath to be used with Drag & Drop applications.
class TransferableTreeNode implements Transferable {

	public static DataFlavor TREE_PATH_FLAVOR = new DataFlavor(TreePath.class,"Tree Path");

	DataFlavor flavors[] = { TREE_PATH_FLAVOR };

	TreePath path;

	public TransferableTreeNode(TreePath tp) {
		path = tp;
	}

	public synchronized DataFlavor[] getTransferDataFlavors() {
		return flavors;
	}

	public boolean isDataFlavorSupported(DataFlavor flavor) {
		return (flavor.getRepresentationClass() == TreePath.class);
	}

	public synchronized Object getTransferData(DataFlavor flavor)
	throws UnsupportedFlavorException, IOException {
		if (isDataFlavorSupported(flavor)) {
			return (Object) path;
		} else {
			throw new UnsupportedFlavorException(flavor);
		}
	}
}
