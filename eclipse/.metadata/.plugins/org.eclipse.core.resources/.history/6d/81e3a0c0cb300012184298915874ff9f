/*
 * Copyright (c) 2002-2010 ESP Suite. All Rights Reserved.
 *
 *     
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Authors: Technology Integration Group, SCE
 * Developers: Eddie Mayfield, Frank Gonzales, Augustin Muniz,
 * Kate Suwan, Hiro Kushida, Andrew McNaughton, Brian Stonerock,
 * Russell Ragsdale, Patrick Ridge, Everett Aragon.
 * 
 */
package com.sce.esp.component;

import java.awt.Color;
import java.util.HashMap;

import javax.swing.UIManager;
import javax.swing.plaf.ColorUIResource;

/**
 * To allow advanced customization of the application environments, all static
 * colors can be accessed and set through a common color table. In that way,
 * labels, buttons, help text, etc. can be easily localized and customized
 * without affecting the actual login of the application.
 */

public final class ColorTableManager {
	private static HashMap<String, Color> colorTable = new HashMap<String, Color>();

	/**
	 * Adjusts the luminance of a color by the specified amount. Amounts greater
	 * than 1 result in more brightness, and less than 1 result in less
	 * brightness.
	 * 
	 * @param color
	 *            the color to be adjusted
	 * @param percent
	 *            the amount to alter the brightness as a percentage with 1.0
	 *            being 100%
	 * @return the adjusted color
	 */
	public static Color adjustColor(Color color, double percent) {
		int r = (int) (color.getRed() * percent);
		int g = (int) (color.getGreen() * percent);
		int b = (int) (color.getBlue() * percent);
		return new Color(r > 0 ? (r < 256 ? r : 255) : 0, g > 0 ? (g < 256
				? g
				: 255) : 0, b > 0 ? (b < 256 ? b : 255) : 0);
	}

	public static Color adjustColorLuminance(Color color, double percent) {
		return adjustColor(color, 1, (float) percent, 1);
	}

	/**
	 * Blends two colors together with a weighted balance. Essentially the base
	 * color gets an added color placed on top of it and uses the intensity as
	 * an alpha blend value to mix the colors. If the intensity of the added
	 * color is 1.0, then the new color will be entirely the added color. If the
	 * intesity is 0.0, then the color will remain the base colo.
	 * 
	 * @param baseColor
	 *            the base color
	 * @param addedColor
	 *            the color to be added
	 * @param intensity
	 *            the intensity (alpha blend) value
	 * @return the blended color
	 */
	public static Color blendColors(Color baseColor, Color addedColor,
			double intensity) {
		int r = (int) ((baseColor.getRed() * (1.0 - intensity)) + (addedColor
				.getRed() * (intensity)));
		int g = (int) ((baseColor.getGreen() * (1.0 - intensity)) + (addedColor
				.getGreen() * (intensity)));
		int b = (int) ((baseColor.getBlue() * (1.0 - intensity)) + (addedColor
				.getBlue() * (intensity)));
		return new Color(r > 0 ? (r < 256 ? r : 255) : 0, g > 0 ? (g < 256
				? g
				: 255) : 0, b > 0 ? (b < 256 ? b : 255) : 0);
	}

	/**
	 * Sets a color entry in the color table. The lookup key is case
	 * insensitive.
	 * <p>
	 * 
	 * @param key
	 *            the key value that will be used to lookup the color later.
	 *            This parameter should never be null
	 * @param value
	 *            the value stored for later retrieval from the color table
	 */
	public static void setColor(String key, Color value) {
		colorTable.put(key.toUpperCase(), value);
	}

	/**
	 * Gets a color entry from the color table. The lookup key is case
	 * insensitive.
	 * <p>
	 * 
	 * @param key
	 *            the key value used to lookup the color in the table
	 * @return a color entry from the color table
	 */
	public static Color getColor(String key_p) {
		String key = key_p.toUpperCase();
		if (!colorTable.containsKey(key))
			colorTable.put(key, Color.WHITE);
		return (Color) colorTable.get(key);
	}

	private ColorTableManager() { /* This class should never be instantiated */
	}

	public enum Colors {
		PANEL_BACKGROUND(new Color(UIManager.getColor("Panel.background")
				.getColorSpace(), UIManager.getColor("Panel.background")
				.getColorComponents(null), UIManager.getColor(
				"Panel.background").getAlpha() / 255.0f)), PANEL_BACKGROUND_DARK(
				adjustColor(PANEL_BACKGROUND.color(), 0.825)),

		BACKGROUND_SELECTION(
				new Color(UIManager.getColor("List.selectionBackground")
						.getColorSpace(), UIManager.getColor(
						"List.selectionBackground").getColorComponents(null),
						UIManager.getColor("List.selectionBackground")
								.getAlpha() / 255.0f)), FOREGROUND_SELECTION(
				new Color(UIManager.getColor("List.selectionForeground")
						.getColorSpace(), UIManager.getColor(
						"List.selectionForeground").getColorComponents(null),
						UIManager.getColor("List.selectionForeground")
								.getAlpha() / 255.0f)),

		FIELD_COLOR(new Color(0xFFFFFF)), FIELD_CHANGED(new Color(0xFFFFDD)), FIELD_ERRORED(
				new Color(0xFFAAAA)),

		TABLE_ISSUE_CLOSED(new Color(0xFFFFFF)), TABLE_ISSUE_ITERATION(
				new Color(0xFFD4D4)), TABLE_ISSUE_CRITICAL(new Color(0xFFF6D4)), TABLE_ISSUE_REQUIRED(
				new Color(0xD4FFD4)),

		GRAPH_DEFAULT_BACKGROUND(new Color(255, 255, 255)), GRAPH_DEFAULT_ROW_GUIDE(
				new Color(178, 176, 141, 127)), GRAPH_DEFAULT_COLUMN_GUIDE(
				new Color(208, 202, 167)),

		GRAPH_TIME_REMAINING(new Color(255, 127, 127)), GRAPH_TIME_COMPLETE(
				new Color(127, 255, 127)), GRAPH_TIME_ESTIMATE(new Color(255,
				0, 0)), GRAPH_TIME_INITIAL_ESTIMATE(new Color(255, 170, 0)), GRAPH_TIME_ACTUAL(
				new Color(28, 244, 28)), GRAPH_COUNT_ISSUES(new Color(127, 255,
				127)), GRAPH_COUNT_TESTED(new Color(35, 248, 0)), GRAPH_COUNT_VERIFIED(
				new Color(248, 245, 166)), GRAPH_COUNT_REMAINING(new Color(255,
				127, 127)), GRAPH_COUNT_ISSUES_TRANSPARENT(new Color(200, 200,
				200, 33)), GRAPH_COUNT_TESTED_TRANSPARENT(new Color(35, 248, 0,
				63)), GRAPH_COUNT_VERIFIED_TRANSPARENT(new Color(248, 245, 166,
				127)),

		DATE_RANGE_BACKGROUND(FIELD_COLOR.color()), DATE_RANGE_CHANGED_BACKGROUND(
				FIELD_CHANGED.color()), DATE_RANGE_NEW_RANGE(
				new Color(0xFFAAAA)), DATE_RANGE_SELECTED_RANGE(new Color(
				0xAAFFAA)), DATE_RANGE_TODAY_COLOR(new Color(0xAAAAFF)), DATE_RANGE_CURSOR_COLOR(
				new Color(0xFFAAAA)),

		CARD_LIST_BACKGROUND(PANEL_BACKGROUND.color()), CARD_BACKGROUND(
				PANEL_BACKGROUND.color()), CARD_SHADE(PANEL_BACKGROUND.color()
				.brighter()),

		RECORD_TITLE_BACKGROUND(PANEL_BACKGROUND.color()), RECORD_LIST_BACKGROUND(
				CARD_LIST_BACKGROUND.color()), RECORD_EMPTY(new Color(0xAAAAAA)), RECORD_TITLE(
				new Color(0xFFFFFF)),

		SEARCH_LIST_BACKGROUND(CARD_LIST_BACKGROUND.color()), SEARCH_BACKGROUND(
				CARD_BACKGROUND.color()), SEARCH_SHADE(CARD_SHADE.color()),

		MESSAGE_TEMPLATE_LIST_BACKGROUND(CARD_LIST_BACKGROUND.color()), MESSAGE_TEMPLATE_BACKGROUND(
				CARD_BACKGROUND.color()), MESSAGE_TEMPLATE_SHADE(CARD_SHADE
				.color()),

		RELEASE_LIST_BACKGROUND(CARD_LIST_BACKGROUND.color()), RELEASE_VIEW_BACKGROUND(
				CARD_LIST_BACKGROUND.color()), RELEASE_BACKGROUND(
				CARD_BACKGROUND.color()), RELEASE_SHADE(CARD_SHADE.color()), RELEASE_NAME_PLANNED(
				Color.BLACK), RELEASE_NAME_NORMAL(new Color(0x00AA00)), RELEASE_NAME_RELEASED(
				new Color(0xAA0000)),

		PROJECT_LIST_BACKGROUND(CARD_LIST_BACKGROUND.color()), PROJECT_VIEW_BACKGROUND(
				CARD_LIST_BACKGROUND.color()), PROJECT_BACKGROUND(
				CARD_BACKGROUND.color()), PROJECT_SHADE(CARD_SHADE.color()), PROJECT_NAME_PREPARE(
				new Color(0x00AA00)), PROJECT_NAME_OPEN(Color.BLACK), PROJECT_NAME_RESOLVED(
				new Color(0xAA0000)),

		INQUIRY_LIST_BACKGROUND(CARD_LIST_BACKGROUND.color()), INQUIRY_VIEW_BACKGROUND(
				CARD_LIST_BACKGROUND.color()), INQUIRY_BACKGROUND(
				CARD_BACKGROUND.color()), INQUIRY_SHADE(CARD_SHADE.color()),

		REPORT_LIST_BACKGROUND(CARD_LIST_BACKGROUND.color()), REPORT_VIEW_BACKGROUND(
				CARD_LIST_BACKGROUND.color()), REPORT_BACKGROUND(
				CARD_BACKGROUND.color()), REPORT_SHADE(CARD_SHADE.color()),

		STATE_LIST_BACKGROUND(CARD_LIST_BACKGROUND.color()), STATE_VIEW_BACKGROUND(
				CARD_LIST_BACKGROUND.color()), STATE_BACKGROUND(CARD_BACKGROUND
				.color()), STATE_SHADE(CARD_SHADE.color()), STATE_NAME_PREPARE(
				new Color(0x00AA00)), STATE_NAME_OPEN(Color.BLACK), STATE_NAME_RESOLVED(
				new Color(0xAA0000)),

		ITERATION_LIST_BACKGROUND(CARD_LIST_BACKGROUND.color()), ITERATION_VIEW_BACKGROUND(
				CARD_LIST_BACKGROUND.color()), ITERATION_BACKGROUND(
				CARD_BACKGROUND.color()), ITERATION_SHADE(CARD_SHADE.color()), ITERATION_NAME_ACTIVE(
				Color.BLACK), ITERATION_NAME_NORMAL(new Color(0x00AA00)), ITERATION_NAME_FINISHED(
				new Color(0xAA0000)),

		USER_LIST_BACKGROUND(CARD_LIST_BACKGROUND.color()), USER_BACKGROUND(
				CARD_BACKGROUND.color()), USER_SHADE(CARD_SHADE.color()), USER_NAME_ENABLED(
				Color.BLACK), USER_NAME_DISABLED(new Color(0x999999)),

		ROLE_LIST_BACKGROUND(CARD_LIST_BACKGROUND.color()), ROLE_BACKGROUND(
				CARD_BACKGROUND.color()), ROLE_SHADE(CARD_SHADE.color()),

		TIME_LIST_BACKGROUND(CARD_LIST_BACKGROUND.color()),

		HISTORY_BACKGROUND(new Color(0xFFFFFF)),

		COMMENTS_BACKGROUND(new Color(0xFFFFFF)),

		TEMPLATE_LIST_BACKGROUND(CARD_LIST_BACKGROUND.color()),

		ISSUE_LIST_BACKGROUND(CARD_LIST_BACKGROUND.color()), ISSUE_VIEW_BACKGROUND(
				CARD_LIST_BACKGROUND.color()), ISSUE_BACKGROUND(CARD_BACKGROUND
				.color()), ISSUE_SHADE(CARD_SHADE.color()), ISSUE_TIME_ITERATION(
				new Color(0x0000AA)), ISSUE_TIME_SUB_TASK(new Color(0xAAAAAA)), ISSUE_NAME_PREPARE(
				new Color(0x00AA00)), ISSUE_NAME_OPEN(Color.BLACK), ISSUE_NAME_RESOLVED(
				new Color(0xAA0000)), ISSUE_TIMER_ACTIVE(new Color(0x0000FF)), ISSUE_ITERATION_INSERT(
				new Color(0xFFA500)),

		CALENDAR_NEIGHBOR_MONTH_BACKGROUND(Color.WHITE), CALENDAR_NEIGHBOR_DAY_BACKGROUND(
				Color.LIGHT_GRAY), CALENDAR_MONTH_BORDER_BACKGROUND(Color.GRAY), CALENDAR_MONTH_BACKGROUND(
				Color.WHITE), CALENDAR_DAY_BORDER(ColorTableManager
				.adjustColor(Color.WHITE, 0.92)), CALENDAR_DAY_HIGHLIGHT_BACKGROUND(
				new Color(0x88FF88)), CALENDAR_DAY_LABEL(Color.BLACK), CALENDAR_DAY_HIGHLIGHT_LABEL(
				Color.WHITE), CALENDAR_DAY_OF_WEEK_LABEL(Color.LIGHT_GRAY), CALENDAR_WEEK_OF_YEAR_LABEL(
				Color.LIGHT_GRAY),

		CALENDAR_SELECTION_BACKGROUND(BACKGROUND_SELECTION.color()), CALENDAR_SELECTION_BORDER(
				BACKGROUND_SELECTION.color()), CALENDAR_SELECTION_TEXT(
				FOREGROUND_SELECTION.color()), CALENDAR_ITERATION_BACKGROUND(
				new Color(0xFFEFD8)), CALENDAR_ITERATION_BORDER(new Color(
				0xE8CEA8)), CALENDAR_ITERATION_TEXT(Color.BLACK), CALENDAR_TASK_BACKGROUND(
				null), CALENDAR_TASK_TEXT(Color.BLACK),

		BACKGROUND_CHANGED(new Color(0xFFFFAA)), BORDER_TITLE(new Color(
				0x888888)), BUTTON_MAIN(new Color(0xFFFFCC));

		Colors(Color color) {
			setColor(name(), color);
		}

		public Color color() {
			return getColor(name());
		}
	}

	public static int hlsToRGB(float h, float l, float s) {
		float m2 = (l <= .5f) ? (l * (1 + s)) : (l + s - l * s);
		float m1 = 2.0f * l - m2;
		float r, g, b;

		if (s == 0.0) {
			if (h == 0.0) {
				r = l;
				g = l;
				b = l;
			} else {
				r = 0;
				g = 0;
				b = 0;;
			}
		} else {
			r = hlsValue(m1, m2, h + 120);
			g = hlsValue(m1, m2, h);
			b = hlsValue(m1, m2, h - 120);
		}
		return (((int) (r * 255)) << 16) | (((int) (g * 255.0)) << 8)
				| ((int) (b * 255));
	}

	private static float hlsValue(float n1, float n2, float h) {
		if (h > 360)
			h -= 360;
		else if (h < 0)
			h += 360;
		if (h < 60)
			return n1 + (n2 - n1) * h / 60.0f;
		else if (h < 180)
			return n2;
		else if (h < 240)
			return n1 + (n2 - n1) * (240.0f - h) / 60.0f;
		return n1;
	}

	public static float[] rgbToHLS(int rgb) {
		float r = ((rgb & 0xFF0000) >> 16) / 255.0f;
		float g = ((rgb & 0xFF00) >> 8) / 255.0f;
		float b = (rgb & 0xFF) / 255.0f;

		float max = Math.max(Math.max(r, g), b);
		float min = Math.min(Math.min(r, g), b);
		float l = (max + min) / 2.0f;
		float s = 0;
		float h = 0;

		if (max != min) {
			float delta = max - min;
			s = (l <= .5f)
					? (delta / (max + min))
					: (delta / (2.0f - max - min));
			if (r == max)
				h = (g - b) / delta;
			else if (g == max)
				h = 2.0f + (b - r) / delta;
			else
				h = 4.0f + (r - g) / delta;
			h *= 60.0f;
			if (h < 0)
				h += 360.0f;
		}
		float[] hls = new float[3];
		hls[0] = h;
		hls[1] = l;
		hls[2] = s;
		return hls;
	}

	public static Color adjustColor(Color color, float hFactor, float lFactor,
			float sFactor) {
		float[] hls = rgbToHLS(color.getRGB());
		float h = Math.min(360, hFactor * hls[0]);
		float l = Math.min(1, lFactor * hls[1]);
		float s = Math.min(1, sFactor * hls[2]);
		return new ColorUIResource(hlsToRGB(h, l, s));
	}
}