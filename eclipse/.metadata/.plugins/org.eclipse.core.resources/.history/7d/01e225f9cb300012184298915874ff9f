/**
 * 
 */
package com.sce.esp.object.model;

import java.io.Serializable;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Collection;
import java.util.TreeSet;

import javax.persistence.Entity;
import javax.persistence.NamedNativeQueries;
import javax.persistence.NamedNativeQuery;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;

import com.sce.esp.log.EspLogger;
import com.sce.esp.object.dao.SceProjDAO;
import com.sce.esp.util.db.PDBConnection;
@Entity
@Table(schema="MDI",name="MDIS35_SCE_PROJ")
@NamedQueries({
	@NamedQuery(name = "findByID", query="SELECT o FROM SceProj o WHERE o.SCE_PROJ_ID=?1"),//AUTO-GENERATED
	@NamedQuery(name = "findAll", query="SELECT o FROM SceProj o"),//AUTO-GENERATED
	@NamedQuery(name = "findAllActive", query="SELECT o FROM SceProj o WHERE o.DELETED_TS IS NULL"),//AUTO-GENERATED
})
@NamedNativeQueries({
	@NamedNativeQuery(name = "refresh", query="SELECT o.* FROM MDIS35_SCE_PROJ o WHERE o.SCE_PROJ_ID=?"),//AUTO-GENERATED
})
public class SceProj extends SceProjDAO implements Serializable{

	private static final long serialVersionUID = -6596447253090794972L;

	/**
	 * Public constructor for creating a generic SceProj
	 * object for record insertion through a wizard.
	 * WARNING!! This should not be used for anything else.
	 */
	public SceProj(){
		super(0);
	}

	/**
	 * @param sceProjId
	 */
	public SceProj(int sceProjId) {
		super(sceProjId);
	}

	public SceProj(SceProj sceProj) {
		super(sceProj);
	}


	/**
	 * Returns the latest <code>SceProjRev</code> version.  The status
	 * can be at any state, i.e. conceptual, emergent or approved.
	 * @return the <code>SceProjRev</code>
	 * @throws SQLException
	 */
	public SceProjRev getCurRev() throws SQLException {
		return getCurRev(null,-1,null);
	}
	
	/**
	 * 
	 * @param allowedStates: -1 for All, SceProjRev.APPROVED, SceProjRev.DENIED, SceProjRev.RETRACTED, SceProjRev.EMERGENT, SceProjRev.CONCEPTIONAL
	 * @return 
	 * @throws SQLException
	 */
	public SceProjRev getCurRev(int allowedStates) throws SQLException {
		return getCurRev(null,allowedStates,null);
	}

	/**
	 * Returns the latest <code>SceProjRev</code> version.  The status
	 * can be at any state, i.e. conceptual, emergent or approved.
	 * @param asOf
	 * @return the <code>SceProjRev</code>
	 * @throws SQLException
	 */
	public SceProjRev getCurRev(Calendar asOf) throws SQLException {
		return getCurRev(asOf,-1,null);
	}
	
	/**
	 * @param asOf
	 * @param allowedStates: -1 for All, SceProjRev.APPROVED, SceProjRev.DENIED, SceProjRev.RETRACTED, SceProjRev.EMERGENT, SceProjRev.CONCEPTIONAL
	 * @return 
	 * @throws SQLException
	 */
	public SceProjRev getCurRev(Calendar asOf, int allowedStates)throws SQLException{
		return getCurRev(asOf,allowedStates,null);
	}
	
	public SceProjRev getCurRev(int planyear, int simId) throws SQLException{
		if(Department.getInstance(planyear) == null)return null;
		return getCurRev(Department.getInstance(planyear).getDropDate(),-1,Simulation.getInstance(planyear, simId));
	}

	public SceProjRev getCurRev(Calendar asOf, int allowedStates, Simulation sim) throws SQLException {
		if(getSceProjRevs().size()>0){
			for(SceProjRev rev:getSceProjRevs()){
				if(asOf == null || rev.getRevTs().compareTo(asOf) <= 0){
					if((sim == null || sim.getSimId() == rev.getSimId()) && (rev.getIWPState() & allowedStates) > 0)
						return rev;
					else if(rev.getIWPState() < allowedStates)
						return null;
				}
			}
		}
		if(sim == null || sim.getBaseSimId() < 0)
			return null;
		return getCurRev(asOf,allowedStates,Simulation.getInstance(sim.getPlanyear(), sim.getBaseSimId()));
	}

	public static TreeSet<SceProj> getAll(Calendar asOf, int allowedStates) throws SQLException{
		TreeSet<SceProj> projs = new TreeSet<SceProj>();
		for(SceProj proj:getAll())
			if(proj.getCurRev(asOf, allowedStates) != null)
				projs.add(proj);
		return projs;
	}

	public static TreeSet<SceProj> getAllActive(Calendar asOf, int allowedStates, Simulation simulation) throws SQLException {
		EspLogger.debug(SceProj.class, "getAllActive");
		TreeSet<SceProj> projs = new TreeSet<SceProj>();
		for(SceProj proj:getAllActive()){
			SceProjRev curRev = proj.getCurRev(asOf, allowedStates, simulation);
			if(curRev != null && !curRev.isDeleted())
				projs.add(proj);
		}
		return projs;
	}

	public boolean isDeleted(){
		try {
			return super.isDeleted() || getSceProjRevs().size()==0 && getAllSceProjRevs().size()>0;
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return false;
	}

	public Collection<SceProjRev> getAllSceProjRevs() throws SQLException{
		return getSceProjRevs();
	}

	public String toString(){
		try {
			SceProjRev rev = getCurRev(SceProjRev.APPROVED);
			if(rev == null)
				rev = getCurRev();
			if(rev!=null)
				return rev+"";
//				return rev+"  ("+rev.getRevStatus()+")";
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "";
	}

	public int compareTo(Object o){
		if(o instanceof SceProj){
			SceProj sp = (SceProj)o;
			if(getSceProjId() < sp.getSceProjId())
				return -1;
			if(getSceProjId() > sp.getSceProjId())
				return 1;
		}
		return super.compareTo(o);
	}
	public static TreeSet<SceProjElemCostYear> getCurAppSpecys() throws SQLException{
		TreeSet<SceProjElemCostYear> speccys = new TreeSet<SceProjElemCostYear>();

		TreeSet<SceProjRev> data = new TreeSet<SceProjRev>();
		try{
			for(SceProj proj: SceProj.getAllActive(Calendar.getInstance(), SceProjRev.APPROVED, Simulation.getInstance(Department.getActivePlanYear(), 0)))
				data.add(proj.getCurRev(SceProjRev.APPROVED));
		}catch(Exception e){
			e.printStackTrace();
		}
		for(SceProjRev rev : data) {	
			if(rev.getProjectStatus()!=SceProjRev.CANCELLED){ 
				for(SceProjElemCost spec: rev.getSceProjElemCosts(CostStage.Type.Proposed)){
					for(SceProjElemCostYear specy: spec.getSceProjElemCostYears()){
						if(specy.getCost()>0 || specy.getPriorityBypass()>0)
							speccys.add(specy);
					}
				}
			}
		}
		data.clear();
		return speccys;
	}

	
	/**
	 * Returns a collections of SceProj objects based on sim id.
	 * @param simId the simulation id
	 * @return sceproj matches
	 * @throws SQLException
	 */
	public static TreeSet<SceProj> getSceProjQry(int simId) throws SQLException{
		TreeSet<SceProj> sceProjs = new TreeSet<SceProj>();
		String query = "SELECT DISTINCT SCE_PROJ_ID FROM MDIS35_SCE_PROJ " +
				"WHERE (SCE_PROJ_ID) IN (SELECT SCE_PROJ_ID FROM MDI.MDIS40_SCE_PROJ_REV WHERE  SIM_ID=?)";
		PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement(query);
		ps.setInt(1,simId);
		
		ResultSet rs = ps.executeQuery();
		while(rs.next())
			sceProjs.add(SceProj.getInstance(rs.getInt("SCE_PROJ_ID")));
		rs.close();
		ps.close();
		return sceProjs;
	}

	public boolean isEditable(String field) throws SQLException {
		if(field.equals("DELETED_TS"))
			return User.getActiveUser().getUserRole().isAdmin();
		return false;
	}
	

}
//=======
///**
// * 
// */
//package com.sce.esp.object.model;
//
//import java.sql.PreparedStatement;
//import java.sql.ResultSet;
//import java.sql.SQLException;
//import java.util.Calendar;
//import java.util.TreeSet;
//
//import jconch.cache.CacheMap;
//import jconch.functor.Transformer5;
//import jconch.multikey.DuoKey;
//
//import com.sce.esp.log.EspLogger;
//import com.sce.esp.object.cache.IRevCache;
//import com.sce.esp.object.dao.SceProjDAO;
//import com.sce.esp.util.db.PDBConnection;
//
//public class SceProj extends SceProjDAO{
//
//	private static final long serialVersionUID = -2077792113553232807L;
//	public static boolean CACHE_METHODS = false;
//	private CurrentRevGetter method01 = new CurrentRevGetter();
//
//	/**
//	 * Public constructor for creating a generic SceProj
//	 * object for record insertion through a wizard.
//	 * WARNING!! This should not be used for anything else.
//	 */
//	public SceProj(){
//		super(0);
//	}
//
//	/**
//	 * @param sceProjId
//	 */
//	public SceProj(int sceProjId) {
//		super(sceProjId);
//	}
//
//	public SceProj(SceProj sceProj) {
//		super(sceProj);
//	}
//
//	//	public SceProjRev getCurRev(int planyear, int simId) throws SQLException{
//	//		if(Department.getInstance(planyear) == null)return null;
//	//		return getCurRev(Department.getInstance(planyear).getDropDate(),-1,Simulation.getInstance(planyear, simId));
//	//	}
//
//	public SceProjRev getCurRev(int planyear, int simId) throws SQLException{
//		if(Department.getInstance(planyear) == null)return null;
//		if(SceProj.CACHE_METHODS){
//			return method01.arbitraryMethod(planyear,simId);//XXX
//		}
//		else{
//			return getCalculatedRev(Department.getInstance(planyear).getDropDate(),-1,Simulation.getInstance(planyear, simId));
//		}
//	}
//
//	private static final class CurRevMethodKey extends DuoKey<Integer,Integer> {
//		public CurRevMethodKey(Integer planyear, Integer simId) {
//			super(planyear,simId);
//		}
//	}
//
//	private SceProjRev getCalculatedRev(Calendar asOf, int allowedStates, Simulation sim){
//		try{
//			if(getSceProjRevs().size()>0){
//				for(SceProjRev rev:getSceProjRevs()){
//					if(asOf == null || rev.getRevTs().compareTo(asOf) <= 0){
//						if((sim == null || sim.getSimId() == rev.getSimId()) && (rev.getIWPState() & allowedStates) > 0)
//							return rev;
//						else if(rev.getIWPState() < allowedStates)
//							return null;
//					}
//				}
//			}
//			if(sim == null || sim.getBaseSimId() < 0)
//				return null;
//			return getCurRev(asOf,allowedStates,Simulation.getInstance(sim.getPlanyear(), sim.getBaseSimId()));	
//		}catch(SQLException sqle){
//			sqle.printStackTrace();
//		}
//		return null;
//	}
//
//	class CurrentRevGetter implements IRevCache<SceProjRev> {
//		private SceProjRev getCurRevMethodImpl(Integer planyear, Integer simId) {
//			try {
//				return getCalculatedRev(Department.getInstance(planyear).getDropDate(),-1,Simulation.getInstance(planyear, simId));
//			} catch (SQLException e) {
//				e.printStackTrace();
//			}
//			return null;
//		}
//
//		private final CacheMap<CurRevMethodKey, SceProjRev> curRevCache = new CacheMap<CurRevMethodKey, SceProjRev>(
//				new Transformer5<CurRevMethodKey, SceProjRev>() {
//					public SceProjRev transform(final CurRevMethodKey multiKey) {
//						return getCurRevMethodImpl(multiKey.getKey1(), multiKey.getKey2());
//					}
//
//				});
//
//		public SceProjRev arbitraryMethod(Integer planyear,Integer simId) {
//			return curRevCache.get(new CurRevMethodKey(planyear, simId));
//		}
//
//		@Override
//		public void invalidateCache() {
//			curRevCache.clear();
//		}
//	}
//
//	/**
//	 * Returns the latest <code>SceProjRev</code> version.  The status
//	 * can be at any state, i.e. conceptual, emergent or approved.
//	 * @return the <code>SceProjRev</code>
//	 * @throws SQLException
//	 */
//	public SceProjRev getCurRev() throws SQLException {
//		return getCurRev(null,-1,null);
//	}
//
//	/**
//	 * 
//	 * @param allowedStates: -1 for All, SceProjRev.APPROVED, SceProjRev.DENIED, SceProjRev.RETRACTED, SceProjRev.EMERGENT, SceProjRev.CONCEPTIONAL
//	 * @return the <code>SceProjRev</code>
//	 */
//	public SceProjRev getCurRev(int allowedStates) throws SQLException {
//		return getCurRev(null,allowedStates,null);
//	}
//
//	/**
//	 * Returns the latest <code>SceProjRev</code> version.  The status
//	 * can be at any state, i.e. conceptual, emergent or approved.
//	 * @param asOf
//	 * @return the <code>SceProjRev</code>
//	 */
//	public SceProjRev getCurRev(Calendar asOf) throws SQLException {
//		return getCurRev(asOf,-1,null);
//	}
//
//	/**
//	 * @param asOf
//	 * @param allowedStates: -1 for All, SceProjRev.APPROVED, SceProjRev.DENIED, SceProjRev.RETRACTED, SceProjRev.EMERGENT, SceProjRev.CONCEPTIONAL
//	 * @return the <code>SceProjRev</code>
//	 */
//	public SceProjRev getCurRev(Calendar asOf, int allowedStates)throws SQLException{
//		return getCurRev(asOf,allowedStates,null);
//	}
//
//	public SceProjRev getCurRev(Calendar asOf, int allowedStates, Simulation sim) throws SQLException {
//		if(getSceProjRevs().size()>0){
//			for(SceProjRev rev:getSceProjRevs()){
//				if(asOf == null || rev.getRevTs().compareTo(asOf) <= 0){
//					if((sim == null || sim.getSimId() == rev.getSimId()) && (rev.getIWPState() & allowedStates) > 0)
//						return rev;
//					else if(rev.getIWPState() < allowedStates)
//						return null;
//				}
//			}
//		}
//		if(sim == null || sim.getBaseSimId() < 0)
//			return null;
//		return getCurRev(asOf,allowedStates,Simulation.getInstance(sim.getPlanyear(), sim.getBaseSimId()));
//	}
//
//	public static TreeSet<SceProj> getAll(Calendar asOf, int allowedStates) throws SQLException{
//		TreeSet<SceProj> projs = new TreeSet<SceProj>();
//		for(SceProj proj:getAll())
//			if(proj.getCurRev(asOf, allowedStates) != null)
//				projs.add(proj);
//				return projs;
//	}
//
//	public static TreeSet<SceProj> getAllActive(Calendar asOf, int allowedStates, Simulation simulation) throws SQLException {
//		EspLogger.debug(SceProj.class, "getAllActive");
//		TreeSet<SceProj> projs = new TreeSet<SceProj>();
//		for(SceProj proj:getAllActive()){
//			SceProjRev curRev = proj.getCurRev(asOf, allowedStates, simulation);
//			if(curRev != null && !curRev.isDeleted())
//				projs.add(proj);
//		}
//		return projs;
//	}
//
//	public boolean isDeleted(){
//		try {
//			return super.isDeleted() || getSceProjRevs().size()==0 && getAllSceProjRevs().size()>0;
//		} catch (SQLException e) {
//			e.printStackTrace();
//		}
//		return false;
//	}
//
//	public synchronized TreeSet<SceProjRev> getAllSceProjRevs() throws SQLException{
//		return getSceProjRevs();
//	}
//
//	public synchronized TreeSet<SceProjRev> getSceProjRevs()throws SQLException{
//		if(!SceProjRev.USE_INDEXES || isNewInstance() || sceProjRevs != null)
//			return super.getSceProjRevs();
//		return SceProjRev.getSceProjRevsBySceProjId(getSceProjId());
//	}
//
//
//	/**
//	 * Returns a collections of SceProj objects based on sim id.
//	 * @param simId the simulation id
//	 * @return sceproj matches
//	 * @throws SQLException
//	 */
//	public static TreeSet<SceProj> getSceProjQry(int simId) throws SQLException{
//		TreeSet<SceProj> sceProjs = new TreeSet<SceProj>();
//		String query = "SELECT DISTINCT SCE_PROJ_ID FROM MDIS35_SCE_PROJ " +
//				"WHERE (SCE_PROJ_ID) IN (SELECT SCE_PROJ_ID FROM MDI.MDIS40_SCE_PROJ_REV WHERE  SIM_ID=?)";
//		PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement(query);
//		ps.setInt(1,simId);
//
//		ResultSet rs = ps.executeQuery();
//		while(rs.next()){
//			sceProjs.add(SceProj.getInstance(rs.getInt("SCE_PROJ_ID")));
//		}
//		rs.close();
//		ps.close();
//		return sceProjs;
//	}
//
//	public boolean isEditable(String field) throws SQLException {
//		if(field.equals("DELETED_TS"))
//			return User.getActiveUser().getUserRole().isAdmin();
//		return false;
//	}
//	
//	public String toString(){
//		try {
//			SceProjRev rev = getCurRev(SceProjRev.APPROVED);
//			if(rev == null)
//				rev = getCurRev();
//			if(rev!=null)
//				return rev+"";
//		} catch (SQLException e) {
//			e.printStackTrace();
//		}
//		return "";
//	}
//
//	public int compareTo(Object o){
//		if(o instanceof SceProj){
//			SceProj sp = (SceProj)o;
//			if(getSceProjId() < sp.getSceProjId())
//				return -1;
//			if(getSceProjId() > sp.getSceProjId())
//				return 1;
//		}
//		return super.compareTo(o);
//	}
//
//}>>>>>>> .merge-right.r16390
