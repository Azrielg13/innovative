/**
 *           | Master Data Interface Version 2.0 |                       
 * 
 * Copyright (c) 2006, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team. 					  
 * 	                   All rights reserved.
 * 
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
package com.sce.esp.object.model;

import java.io.Serializable;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Hashtable;
import java.util.Vector;

import com.sce.esp.object.dao.DataAccessObject;
import com.sce.esp.util.AgObserver;


/**
 * The AgTemperature Object
 * implements AbstractTemperature.
 * 
 * @author Distribution Staff Engineering
 * @version 2.0
 */
public class AgTemperature extends AgObserver implements AbstractTemperature, Serializable{

	/**
	 * 
	 */
	private static final long serialVersionUID = 9219772926282754596L;

	private static Hashtable<String,AgTemperature> hash = new Hashtable<String,AgTemperature>();

	private Collection<Temperature> temps = Collections.synchronizedCollection(new Vector<Temperature>());

	/** The co. */
	private CoreObject co;

	/** The date. */
	private Calendar date;


	public static AgTemperature getInstance(CoreObject co, Calendar date){
		if(co == null)
			return new AgTemperature(null,date);
		String key = MDIObject.getHashKey(new Object[]{co.getPlanyear(), co, date});
		AgTemperature o = hash.get(key);
		if(o == null){
			o = new AgTemperature(co, date);
			hash.put(key,o);
		}
		return o;
	}

	/**
	 * The Constructor.
	 * 
	 * @param co the co
	 * @param date the date
	 */
	private AgTemperature(CoreObject co, Calendar date){
		this.co = co;
		this.date = (Calendar)date.clone();
	}

	/**
	 * Gets the rcd date.
	 * 
	 * @return the rcd date
	 */
	public Calendar getRcdDate(){
		return date;
	}

	/**
	 * Gets the temperatures.
	 * 
	 * @return temsps
	 * 
	 * @throws SQLException the SQL exception
	 */
	public void update(DataAccessObject dao) {
		super.update(dao);
	}

	public Collection<Temperature> getTemperatures()throws SQLException{
		temps.clear();
		if(co != null){
			Temperature t = null;
			for(Weatherstation ws:co.getWeatherStationsByInstance()){
				t = ws.getTemperature(date);
				if(t!=null)
					temps.add(t);
			}
		}
		return temps;
	}

	/**
	 * Gets the max temp.
	 * 
	 * @return the max temp value/temps.size()
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getMaxTemp()throws SQLException{
		double maxT=0;
		double value=0;
		
		Collection<Temperature> temps = Collections.synchronizedCollection(getTemperatures());
		for(Temperature temp:temps){
			if(temp!=null )
				value+=temp.getMaxTemp();
		}
		maxT =  value/temps.size();
		return maxT;
	}


	/**
	 * Gets the min temp.
	 * 
	 * @return the min temp - returns value/temps.size()
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getMinTemp()throws SQLException{
		double value=0, minT=0;
		Collection<Temperature> temps = Collections.synchronizedCollection(getTemperatures());
		for(Temperature temp:temps){//java.util.ConcurrentModificationException
			if(temp!=null)
				value+=temp.getMinTemp();
		}
		minT =  value/temps.size();
		return minT;
	}

	/**
	 * Gets the effective temp.
	 * 
	 * @return returns value/temps.size() if temps.size()>0 else retruns 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getEffTemp()throws SQLException{
		double value=0, effT=0;
		Collection<Temperature> temps = Collections.synchronizedCollection(getTemperatures());
		for(Temperature temp:temps)
			if(temp!=null)
				value+=temp.getEffTemp();
		if(temps.size()>0)
			effT =  value/temps.size();
		else
			effT =  0;
		return effT;
	}

	/**
	 * Gets the equivalent temperature
	 * @return
	 * @throws SQLException
	 */
	public double getEquTemp()throws SQLException{
		double value=0, equT=0;
		Collection<Temperature> temps = Collections.synchronizedCollection(getTemperatures());
		for(Temperature temp:temps)
			if(temp!=null)
				value+=temp.getEquTemp();
		if(temps.size()>0)
			equT =  value/temps.size();
		else
			equT =  0;
		return equT;
	}

	/**
	 * Gets the ten year avg.
	 * 
	 * @return the ten year avg
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getTenYearAvg() throws SQLException {		
		double value=0, tenAvg=0;
		Collection<Temperature> temps = Collections.synchronizedCollection(getTemperatures());
		for(Temperature temp:temps)
			if(temp!=null && temp.getWeatherstation()!=null)
				value+=temp.getWeatherstation().getTenYearAvg();
		if(temps.size()>0)
			tenAvg =  value/temps.size();
		else
			tenAvg =  0;
		return tenAvg;
	}

	/**
	 * @return
	 */
	public CoreObject getCo(){
		return co;
	}

	/**
	 * Gets all the children notes appended to one string
	 * @return the note
	 * @throws SQLException
	 */
	public String getNote() throws SQLException {
		StringBuffer sb = new StringBuffer();
		if(co != null){
			for(Weatherstation ws:co.getYear(0, co.getPlanyear()-1).getWeatherStations()) {
				String note = ws.getTemperature(getRcdDate()).getNote();
				if(note!=null && note.length()>0) {
					sb.append(ws + ": " + note+"; ");
				}
			}
		}
		return sb.toString();
	}

	public boolean containsMaxZero()throws SQLException{
		for(Temperature temp:getTemperatures())
			if(temp.getMaxTemp()==0)
				return true;
		return false;
	}

	public boolean containsMinZero()throws SQLException{
		for(Temperature temp:getTemperatures())
			if(temp.getMinTemp()==0)
				return true;
		return false;
	}

	public int compareTo(Object o) {
		synchronized(this){
			if(o instanceof AbstractTemperature){
				AbstractTemperature abt = (AbstractTemperature)o;
				try{
					if(getEffTemp() > abt.getEffTemp())
						return -1;
					if(getEffTemp() < abt.getEffTemp())
						return 1;
					if(getMaxTemp() > abt.getMaxTemp())
						return -1;
					if(getMaxTemp() < abt.getMaxTemp())
						return 1;
				}catch(SQLException sqle){
					sqle.printStackTrace();
				}
				return getRcdDate().compareTo(abt.getRcdDate());
			}
		}
		return 0;
	}

	@Override
	public AbstractTemperature getYesterdayTemp() throws SQLException {
		double maxT=0,minT=0,avgT=0,prcp,wind;
		double value=0,value2=0,value3=0,value4=0,value5=0;
		Collection<Temperature> temps = Collections.synchronizedCollection(getTemperatures());
		for(Temperature temp:temps){
			if(temp!=null ){
				value+=temp.getYesterdayTemp().getMaxTemp();
				value2+=temp.getYesterdayTemp().getMinTemp();
				value3+=temp.getYesterdayTemp().getAvgTemp();
				
				value4+=temp.getYesterdayTemp().getPrecip();
				value5+=temp.getYesterdayTemp().getAvgWind();
			}
		}
		TempTemperature temp = new TempTemperature();
		maxT =  value/temps.size();
		minT =  value2/temps.size();
		avgT = value3/temps.size();
		prcp =  value4/temps.size();
		wind = value5/temps.size();
		
		temp.setMaxTemp(maxT);
		temp.setMinTemp(minT);
		temp.setAvgTemp(avgT);
		temp.setPrecip(prcp);
		temp.setAvgWind(wind);
		temp.setPlanyear(getCo().getPlanyear());
		temp.setRcdDate(getRcdDate());

		return temp;
	}

	@Override
	public AbstractTemperature getTwoDaysAgoTemp() throws SQLException {
		double maxT=0,minT=0,avgT=0,prcp=0,wind=0;
		double value=0,value2=0,value3=0,value4=0,value5=0;
		Collection<Temperature> temps = Collections.synchronizedCollection(getTemperatures());
		for(Temperature temp:temps){
			if(temp!=null ){
				value+=temp.getTwoDaysAgoTemp().getMaxTemp();
				value2+=temp.getTwoDaysAgoTemp().getMinTemp();
				value3+=temp.getTwoDaysAgoTemp().getAvgTemp();
				value4+=temp.getTwoDaysAgoTemp().getPrecip();
				value5+=temp.getTwoDaysAgoTemp().getAvgWind();
			}
		}
		TempTemperature temp = new TempTemperature();
		maxT =  value/temps.size();
		minT =  value2/temps.size();
		avgT = value3/temps.size();
		prcp =  value4/temps.size();
		wind = value5/temps.size();
		
		temp.setMaxTemp(maxT);
		temp.setMinTemp(minT);
		temp.setAvgTemp(avgT);
		temp.setPrecip(prcp);
		temp.setAvgWind(wind);
		temp.setPlanyear(getCo().getPlanyear());
		temp.setRcdDate(getRcdDate());
		
		return temp;
	}

	@Override
	public double getAvgTemp() throws SQLException {
		double value=0, avgT=0;
		Collection<Temperature> temps = Collections.synchronizedCollection(getTemperatures());
		for(Temperature temp:temps){
			if(temp!=null)
				value+=temp.getAvgTemp();
		}
		avgT =  value/temps.size();
		return avgT;
	}

	@Override
	public double getAvgWind() throws SQLException {
		double value=0, minT=0;
		Collection<Temperature> temps = Collections.synchronizedCollection(getTemperatures());
		for(Temperature temp:temps){//java.util.ConcurrentModificationException
			if(temp!=null)
				value+=temp.getAvgWind();
		}
		minT =  value/temps.size();
		return minT;
	}

	@Override
	public double getPrecip() throws SQLException {
		double value=0, minT=0;
		Collection<Temperature> temps = Collections.synchronizedCollection(getTemperatures());
		for(Temperature temp:temps){//java.util.ConcurrentModificationException
			if(temp!=null)
				value+=temp.getPrecip();
		}
		minT =  value/temps.size();
		return minT;
	}

	@Override
	public double getRelHumid() throws SQLException {
		double value=0, minT=0;
		Collection<Temperature> temps = Collections.synchronizedCollection(getTemperatures());
		for(Temperature temp:temps){//java.util.ConcurrentModificationException
			if(temp!=null)
				value+=temp.getRelHumid();
		}
		minT =  value/temps.size();
		return minT;
	}

	@Override
	public double getTenYearAvgAvg() throws SQLException {		
		double value=0, tenAvg=0;
		Collection<Temperature> temps = Collections.synchronizedCollection(getTemperatures());
		for(Temperature temp:temps)
			if(temp!=null && temp.getWeatherstation()!=null)
				value+=temp.getWeatherstation().getTenYearAvgAvg();
		if(temps.size()>0)
			tenAvg =  value/temps.size();
		else
			tenAvg =  0;
		return tenAvg;
	}
	
	
}