/**
 *           | Master Data Interface Version 2.0 |
 *
 * Copyright (c) 2006, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team.
 * 	                   All rights reserved.
 *
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package com.dd4.iis.object.dao;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Reader;
import java.sql.Clob;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Observable;
import java.util.Vector;
import static com.dd4.common.util.Calculate.isNull;

import com.dd4.common.jpa.AICache;
import com.dd4.common.jpa.AutoInsertable;
import com.dd4.common.jpa.Change;
import com.dd4.common.jpa.ChangeLog;
import com.dd4.common.jpa.Entity;
import com.dd4.common.jpa.EntityManagerHelper;
import com.dd4.common.jpa.PrimaryKey;
import com.dd4.common.util.Calculate;
import com.dd4.common.util.FormatText;
import com.dd4.common.jdbc.PDBConnection;


/**
 * The MDIObject Object.
 *
 * @author Distribution Staff Engineering
 * @version 2.0
 */
public abstract class DataAccessObject extends Observable implements Comparable<Object>, ChangeLog, Entity{
	private static Vector<Class<DataAccessObject>> allClasses;
	public static boolean AG_CACHE_ENABLED=true;
	private Map<String,Object> valueCache;
	private HashMap<String,Change> changes;
	
    /**
     * Creates a new instance of DBObject.
     */
    public DataAccessObject() {
    }

    public DataAccessObject(DataAccessObject orig){
	}

	/**
     * Checks if is new instance.
     *
     * @return true, if is new instance
     */
    public boolean isNewInstance(){
    	return EntityManagerHelper.getEntityManager()==null || !EntityManagerHelper.getEntityManager().contains(this);
    }
    
    /**
     * Compare to.
     *
     * @param o the o
     *
     * @return the int
     */
    public int compareTo(Object o){
    	//If this is the same exact object in memory then just say so
    	if(this == o)
    		return 0;
    	if(o instanceof DataAccessObject)
    		return (toString()+getHashKey()).compareTo(o.toString()+((DataAccessObject)o).getHashKey());
        return 0;
    }

    /**
     * Gets the hash key.
     *
     * @return the hash key
     */
    public abstract String getHashKey();

    /**
     * Refresh.
     *
     * @return true, if refresh
     *
     * @throws SQLException the SQL exception
     */
    public void refresh()throws SQLException{
    	EntityManagerHelper.getEntityManager().refresh(this);
    }
	
	public Collection<Change> getChanges(){
		return changes.values();
	}
	
	public void addChange(String prop, Object newValue, Object oldValue){
		if(changes == null)
			changes = new HashMap<String,Change>();
		changes.put(prop, new Change(prop,newValue,oldValue));
	}

	protected void setProperty(String prop, Object newValue, Object oldValue) throws SQLException{
		if(prop==null)return;
		if(getClass().getAnnotation(AutoInsertable.class)!=null && isNewInstance()){
			insert();
			return;
		}
		if(isNewInstance()) return;
		addChange(prop, newValue,oldValue);
		save();
	}
	
	/**
	 * This does not insert into the database.  This call EntityManager merge.
	 */
	public void save(){
		if(changes!=null){
			EntityManagerHelper.getEntityManager().merge(this);
			changes.clear();
		}
	}

	public void delete() throws SQLException{
		EntityManagerHelper.getEntityManager().remove(this);
	}

    /**
     * Gets the real record.
     *
     * @return the real record
     */
    public DataAccessObject getRealRecord(){
    	return this;
    }

    /**
     * Checks if is real record.
     *
     * @return true, if is real record
     */
    public boolean isRealRecord(){
    	return getRealRecord() == this;
    }


    /**
     * Pre Insert.
     *
     * @return true, if insert
     *
     * @throws SQLException the SQL exception
     */
    public boolean preSimCopy()throws Exception{
        return true;
    }
    
    public void insertParents()throws SQLException{
    }

    /**
     * Insert.
     *
     * @throws SQLException the SQL exception
     */
    public void insert()throws SQLException{
    	insertParents();
    	if(isNewInstance()){
    		EntityManagerHelper.getEntityManager().persist(this);
    	}
    	insertChildren();
    }
    
    public void insertChildren()throws SQLException{ 	
    }
    
    public static boolean isSame(Object o, Object o2){
    	return Calculate.isSame(o, o2);
    }

    /**
     * Returns a string hash code of an object of this type with the
     * specified parameters. The hash code would be used to find the
     * object in a hash table.
     *
     * @param id - id for the object
     * @param planyear - planYear for the object
     * @param k1 the k1
     *
     * @return a string hash code of an object of this type with the specified parameters.
     */
    
    public static String getHashKey(Object[] keys){
    	return PrimaryKey.getHashKey(keys);
    }
    
    public static String getHashKey(Object key){
    	return PrimaryKey.getHashKey(key);
    }

    public static boolean isNull(Object... keys){
    	for(Object k:keys)
    		if(Calculate.isNull(k))
    			return true;
    	return false;
    }
    
    public static boolean isNull(Object o){
    	return Calculate.isNull(o);
    }

    /**
     * To string.
     *
     * @return the string
     */
    public String toString(){
    	return getHashKey();
    }
    
    public Vector<String> getDifference(DataAccessObject dao){
    	return new Vector<String>();
    }
    public void copyChildrenTo(DataAccessObject cp){
    }
}
