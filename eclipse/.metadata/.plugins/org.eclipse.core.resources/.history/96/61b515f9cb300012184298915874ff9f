/**
 *           | Master Data Interface Version 2.0 |                       
 * 
 * Copyright (c) 2006, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team. 					  
 * 	                   All rights reserved.
 * 
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
package com.sce.esp.object.model;

import java.io.Serializable;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Collection;
import java.util.Hashtable;
import java.util.TreeSet;
import java.util.Vector;

import javax.persistence.Entity;
import javax.persistence.NamedNativeQueries;
import javax.persistence.NamedNativeQuery;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;
import javax.swing.Icon;

import com.sce.esp.log.EspLogger;
import com.sce.esp.object.dao.BbankDAO;
import com.sce.esp.object.jpa.EntityManagerHelper;
import com.sce.esp.util.Calculate;
import com.sce.esp.util.IconsFactory;
import com.sce.esp.util.db.PDBConnection;
@Entity
@Table(schema="MDI",name="MDI108_BBANK_V")
@NamedQueries({
	@NamedQuery(name = "findByID", query="SELECT o FROM Bbank o WHERE o.PLANYEAR=?1 AND o.BBANK_SUB_ID=?2"),//AUTO-GENERATED
	@NamedQuery(name = "findAll", query="SELECT o FROM Bbank o"),//AUTO-GENERATED
	@NamedQuery(name = "findAllActive", query="SELECT o FROM Bbank o WHERE o.DELETED_TS IS NULL"),//AUTO-GENERATED
})
@NamedNativeQueries({
	@NamedNativeQuery(name = "refresh", query="SELECT o.* FROM MDI108_BBANK_V o WHERE o.PLANYEAR=? AND o.BBANK_SUB_ID=?"),//AUTO-GENERATED
	//@NamedNativeQuery(name = "findByID_FETCH", query="SELECT * FROM MDI108_BBANK_V WHERE (PLANYEAR,DISTRICT_ID) IN (SELECT PLANYEAR,DISTRICT_ID FROM MDI108_BBANK_V WHERE PLANYEAR=? AND BBANK_SUB_ID=?)"),
})
public class Bbank extends BbankDAO implements Serializable{

	private static final long serialVersionUID = 7947503254077105151L;
	/**
	 * The Constructor.
	 * 
	 * @param planyear the planyear
	 */
	public Bbank(){
		this(0,0);
	}
	public Bbank(int planyear){
		this(planyear,0);
	}

	/**
	 * The Constructor.
	 * 
	 * @param id the id
	 * @param planYear the plan year
	 * @param simId      *
	 * 
	 * @throws SQLException the SQL exception
	 */
	public Bbank(int planYear, int subId){
		super(planYear,subId);
		try {
			setBbank(true);
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public Bbank(Bbank bbank) {
		super(bbank);
	}

	/**
	 * Gets the level.
	 * 
	 * @return the level
	 */
	public int getLevel(){
		return BBANK_SUB;
	}

	public int getCoTypeId(){
		return CoType.BBANK;
	}

	/**
	 * Gets the year.
	 * 
	 * @param year the year
	 * @param simId the sim id
	 * 
	 * @return the year
	 * 
	 * @throws SQLException the SQL exception
	 */
	public BbankYear getYear(int simId, int year)throws SQLException{
		return getYear(simId,year,true);
	}
	public BbankYear getYear(int simId, int year, boolean fetch)throws SQLException{
		return BbankYear.getInstance(getPlanyear(),simId,getSubId(),year,fetch);
	}

	/**
	 * This method returns a treeset of ties.  There
	 * is a single  tie object for any time that a child
	 * of this bbank ties to a child of another bbank.  A collection
	 * of bbank to and from ties is also created for the bbank tie.
	 * 
	 * @param simId the sim id
	 * 
	 * @return the out ties
	 * 
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<ParentTie> getOutTies(int simId)throws SQLException{
		Hashtable<Integer,ParentTie> pTies = new Hashtable<Integer,ParentTie>();
		for(int i=getPlanyear()-1; i<getPlanyear()+User.getActiveUser().getPlanFor(getPlanyear(),simId); i++) {
			for(BbankTie tie : ((BbankYear)getYear(simId,i)).getToTies()) {
				Sub tieSub = tie.getFromSub();
				if(!pTies.containsKey(tieSub.getId()))
					pTies.put(tieSub.getId(),new ParentTie(this,(Bbank)tieSub));
				pTies.get(tieSub.getId()).addToTie(tie);
			}
			for(BbankTie tie : ((BbankYear)getYear(simId,i)).getFromTies()) {
				Sub tieSub = tie.getToSub();
				if(!pTies.containsKey(tieSub.getId()))
					pTies.put(tieSub.getId(),new ParentTie(this,(Bbank)tieSub));
				pTies.get(tieSub.getId()).addFromTie(tie);
			}
		}
		return new TreeSet<ParentTie>(pTies.values()); 
	}

	public double getN1(int simId)throws SQLException{
		return getNameplate(simId)*getN1Factor();
	}

	/**
	 * Gets the A banks.
	 * 
	 * @param simId the sim id
	 * 
	 * @return the A banks
	 * 
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<Abank> getAbanks(int simId)throws SQLException {
		return getSimSub(simId).getAbanks();
	}

	/**
	 * Gets the ckt vars for this bbank and
	 * all the bbanks down stream of this bbank.
	 * 
	 * @return the ckt vars
	 * 
	 * @throws SQLException the SQL exception
	 */
	public Vector<CktVar> getCktVars(int simId) throws SQLException{
		Vector<CktVar> cktVars = new Vector<CktVar>();
		for(Ckt ckt : getCkts(simId))
			cktVars.addAll(ckt.getCktVars());
		for(Bbank bBank : getBbanks(simId,SubFilter.CORE_SUB))
			cktVars.addAll(bBank.getCktVars(simId));
		return cktVars;
	}

	public Collection<LgProj> getLgProjs(int simId) throws SQLException {
		return getLgProjs();
	}

	/**
	 * Gets the weatherstations.
	 * 
	 * @return the weatherstations
	 * 
	 * @throws SQLException the SQL exception
	 */
	public synchronized Vector<Weatherstation> getWeatherStations()throws SQLException{
		Vector<Weatherstation> wss = new Vector<Weatherstation>();
		for(SubWeather sw:getSubWeathers())
			wss.add(sw.getWeatherstation());
		return wss;
	}


	/**
	 * Removes the weatherstation.
	 * 
	 * @param ws the ws
	 * 
	 * @throws SQLException the SQL exception
	 */
	public void removeWeatherstation(Weatherstation ws)throws SQLException{
		SubWeather sw = SubWeather.getInstance(getPlanyear(), getBbankSubId(), ws.getStationId());
		if(sw != null)
			sw.deleteDB();//
	}

	/**
	 * Adds a new weatherstation.
	 * 
	 * @param ws the ws
	 * 
	 * @throws SQLException the SQL exception
	 */
	public void addWeatherstation(Weatherstation ws)throws SQLException{
		SubWeather sw = new SubWeather(getPlanyear(),getBbankSubId(),ws.getStationId());
		sw.insert();
	}

	/**
	 * Gets the weatherstations by instance.
	 * 
	 * @return the weatherstations by instance
	 * 
	 * @throws SQLException the SQL exception
	 */
	public Vector<Weatherstation> getWeatherStationsByInstance()throws SQLException{
		return getWeatherStations();
	}

	/**
	 * This function returns the flag id if the
	 * Total PIF Estimate is less than or equal to &value.
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getPIFEstChangedFlag() throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.PIF_COST_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()) {    
			for(Pif p:this.getPifs())
				if(p.getPIFEstChangedFlag()>0)
					return flag.getFlagId();
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * Total PIF estimate changed from the previous plan by greater than |&value%|.
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getPIFEstChangedPYFlag() throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.PIF_COST_PY_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()) {
			for(Pif p:this.getPifs())
				if(p.getPIFEstChangedPYFlag()>0)
					return flag.getFlagId();
		}
		return 0;
	} 

	/**
	 * Gets the coin child flag.
	 * 
	 * @param simId the sim id
	 * 
	 * @return the coin child flag
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getCoinChildFlag(int simId) throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.COIN_FLAG);
		if(getPeakDate(simId)!=null && flag!=null && !flag.isDisabled() && flag.isShowFlag()) {

			if(getCkts(simId).size()==0)
				return 0;

			double childsum = 0;		

			for(Ckt ckt:getCkts(simId))
				childsum += ckt.getDailyPeak(getPeakDate(simId)).getActualPeak()*ckt.getDailyPeak(getPeakDate(simId)).getCoinFactor();

			double parent = getPeakDailyPeak(simId).getActualPeak();

			if(parent==0 && childsum==0)
				return 0;			

			if(parent==0 || Math.abs((childsum/parent)-1) > flag.getValue())
				return flag.getFlagId();
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * Total Non-Coincident Child Load is < the Parent Load for a given year.
	 * 
	 * @param simId the sim id
	 * 
	 * @return - flag id or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getNonCoinChildFlag(int simId) throws SQLException{		
		Flag flag = Flag.getInstance(getPlanyear(), Flag.NON_COIN_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()) {
			if(getCkts(simId).size()==0)
				return 0;
			double childsum = 0;		
			for(Ckt ckt:getCkts(simId))					
				childsum += ckt.getStartingPoint(simId);
			if(getNormStartingPoint(simId) > childsum * flag.getValue())
				return flag.getFlagId();			
		}
		return 0;
	}

	/**
	 * Gets the ACL flag.
	 * 
	 * @param simId the sim id
	 * 
	 * @return the ACL flag
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getACLFlag(int simId) throws SQLException{		 
		Flag flag = Flag.getInstance(getPlanyear(), Flag.ACL_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag())
			for(int y=getPlanyear()-1; y<getPlanyear()+User.getActiveUser().getPlanFor(getPlanyear(),simId); y++)
				if(getYear(simId, y).getACLFlag()>0)
					return flag.getFlagId();
		return 0;
	}

	public int getACLEVFlag(int simId) throws SQLException{		 
		Flag flag = Flag.getInstance(getPlanyear(), Flag.ACL_EV_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag())
			for(int y=getPlanyear()-1; y<getPlanyear()+User.getActiveUser().getPlanFor(getPlanyear(),simId); y++)
				if(getYear(simId, y).getACLEVFlag()>0)
					return flag.getFlagId();
		return 0;
	}

	public int getN1ReserveFlag(int simId) throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.N1_NEG_RES_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag())
			for(int y=getPlanyear(); y<getPlanyear()+User.getActiveUser().getPlanFor(getPlanyear(), simId); y++)
				if(getYear(simId, y).getN1ReserveFlag()>0)
					return flag.getFlagId();
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * substation has a Transfer > |&value| without a new project.
	 * 
	 * @param simId the sim id
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getLargeXferFlag(int simId) throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.LARGE_XFR_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag())
			for(int y=getPlanyear(); y<getPlanyear()+User.getActiveUser().getPlanFor(getPlanyear(),simId); y++)
				if(getYear(simId,y).getLargeXferFlag()>0)
					return flag.getFlagId();
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * A transfer exists where the offloading substation has > |&value%| reserve without it.
	 * 
	 * @param simId the sim id
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getBadXferFlag(int simId) throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.BAD_XFR_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()) {
			for(int y=getPlanyear(); y<getPlanyear()+User.getActiveUser().getPlanFor(getPlanyear(),simId); y++){
				if(getYear(simId, y).getBadXferFlag()>0)
					return flag.getFlagId();
			}
		}
		return 0;
	}

	//	/**
	//	 * This function returns the flag id if a
	//	 * transfer exists between 2 systems.
	//	 * 
	//	 * @param simId the sim id
	//	 * 
	//	 * @return the inter sys trans flag
	//	 * 
	//	 * @throws SQLException the SQL exception
	//	 */
	//	public int getInterSysTransFlag(int simId) throws SQLException{
	//		Flag flag = Flag.getInstance(getPlanyear(), Flag.INTER_SYS_XFR_FLAG);
	//		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()) {
	//			for(BbankTie tie : getActiveFromTies(simId)) {
	//				for(int x=0; x<User.getActiveUser().getPlanFor(getPlanyear(),simId); x++){
	//					BbankTrans transfer = tie.getTransfer(tie.getPlanyear()+x);
	//					if(transfer.getTransfer()>0) {
	//						if(getYear(simId,transfer.getYear()).getSys()!=tie.getToSub().getYear(simId,transfer.getYear()).getSys())
	//							return flag.getFlagId();
	//					}
	//				}
	//			}
	//			for(BbankTie tie : getActiveToTies(simId)) {
	//				for(int x=0; x<User.getActiveUser().getPlanFor(getPlanyear(),simId); x++){
	//					BbankTrans transfer = tie.getTransfer(tie.getPlanyear()+x);
	//					if(transfer.getTransfer()>0) {
	//						if(getYear(simId,transfer.getYear()).getSys()!=tie.getFromSub().getYear(simId,transfer.getYear()).getSys())
	//							return flag.getFlagId();
	//					}
	//				}
	//			}
	//		}
	//		return 0;
	//	}

	/**
	 * This function returns the flag id if a
	 * transfer is not needed to meet reserve.
	 * 
	 * @param simId the sim id
	 * 
	 * @return the bad trans flag
	 * 
	 * @throws SQLException the SQL exception
	 */


	/**
	 * This function returns the flag id if the
	 * A transfer exists where Circuit Transfer > |&value%| different than Substation Transfer.
	 * 
	 * @param simId the sim id
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getCktXferFlag(int simId) throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.CKT_XFR_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()) {
			for(int y=getPlanyear(); y<getPlanyear()+Flag.CKT_YEARS; y++){
				if(getYear(simId, y).getCktXferFlag()>0)
					return flag.getFlagId();
			}
		}
		return 0;
	}

	/**
	 * This function returns the flag id if there
	 * is a transfer that is not confirmed.
	 * 
	 * @param simId the sim id
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getXferConfirmFlag(int simId) throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.XFR_CONFIRM_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()) {
			for(int y=getPlanyear(); y<getPlanyear()+User.getActiveUser().getPlanFor(getPlanyear(),simId); y++){
				if(getYear(simId, y).getXferConfirmFlag()>0)
					return flag.getFlagId();
			}
		}
		return 0;
	}

	/**
	 * Gets the var reserve flag.
	 * 
	 * @param simId the sim id
	 * 
	 * @return the var reserve flag
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getVarReserveFlag(int simId)throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.VAR_RESERVE_DIST_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()){
			for(int y=getPlanyear(); y<getPlanyear()+User.getActiveUser().getPlanFor(getPlanyear(),simId); y++){
				if(getYear(simId, y).getVarReserveFlag()>0)
					return flag.getFlagId();
			}
		}
		return 0;
	}

	/**
	 * This function returns the flag id for a 
	 * proposed project (emergent or conceptual) if
	 * the B-bank Nameplate Capacity exceeds 112MVA
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	//Actual Logic for this flag exists in SceProjRev
	//getFlags logic cannot exist in SceProjRev
	public int getBbankNameplateExceedsFlag(int simId) throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.BBANK_NAMEPLATE_EXCEEDS_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()){
			for(SceProjElemCost spec: getSceProjElemCosts())
				if((spec.getSceProjRev().isDEProject()
						&& spec.getSceProjRev().getProjectStatus()== SceProjRev.ACTIVE_STATUS) 
						&& spec.getNameplatePost(getPlanyear(), getSimId(), null) > flag.getValue())
					return flag.getFlagId();
		}
		return 0;
	}

	/**
	 * Gets the flags.
	 * 
	 * @param simId the sim id
	 * 
	 * @return the flags
	 * 
	 * @throws SQLException the SQL exception
	 * 
	 * @see com.sce.esp.object.model.Sub#getFlags()
	 */
	public TreeSet<Referee> getFlags(int simId) throws Exception{
		TreeSet<Referee> flags = super.getFlags(simId);

		//		int flagId = getInterSysTransFlag(simId);		
		//		if(flagId > 0)
		//			flags.add(new Referee(this,Flag.getInstance(getPlanyear(), flagId)));

		int flagId = getACLFlag(simId);
		if(flagId > 0)
			flags.add(new Referee(this,Flag.getInstance(getPlanyear(), flagId)));

		flagId = getCktXferFlag(simId);
		if(flagId > 0)
			flags.add(new Referee(this,Flag.getInstance(getPlanyear(), flagId)));

		flagId = getLargeXferFlag(simId);
		if(flagId > 0)
			flags.add(new Referee(this,Flag.getInstance(getPlanyear(), flagId)));

		flagId = getBadXferFlag(simId);
		if(flagId > 0)
			flags.add(new Referee(this,Flag.getInstance(getPlanyear(), flagId)));

		flagId = getPIFEstChangedFlag();
		if(flagId > 0)
			flags.add(new Referee(this,Flag.getInstance(getPlanyear(), flagId)));

		flagId = getPIFEstChangedPYFlag();
		if(flagId > 0)
			flags.add(new Referee(this,Flag.getInstance(getPlanyear(), flagId)));

		flagId = getXferConfirmFlag(simId);
		if(flagId > 0)
			flags.add(new Referee(this,Flag.getInstance(getPlanyear(), flagId)));

		flagId = getN1ReserveFlag(simId);
		if(flagId > 0)
			flags.add(new Referee(this,Flag.getInstance(getPlanyear(), flagId)));

		flagId = getBbankNameplateExceedsFlag(simId);
		if(flagId > 0)
			flags.add(new Referee(this,Flag.getInstance(getPlanyear(), flagId)));

		for(Ckt c: getCkts(simId))
			flags.addAll(c.getFlags(simId));

		return flags;		
	}

	/**
	 * Gimme percent instance.
	 * 
	 * @param ws the ws
	 * 
	 * @return the double
	 * 
	 * @throws SQLException the SQL exception
	 * 
	 * @see com.sce.esp.object.model.CoreObject#getPercentInstance(com.sce.esp.object.model.Weatherstation)
	 */
	public double getPercentInstance(Weatherstation ws) throws SQLException {			
		double pi = 0;
		for(Weatherstation ws2: getWeatherStationsByInstance())
			if(ws == ws2)
				pi++;   		
		return Calculate.round(pi/getWeatherStationsByInstance().size()*100,1);
	}

	/**
	 * Gets the icon.
	 * 
	 * @return the icon
	 */
	public Icon getIcon(){
		try {
			if(getStatus(0).equalsIgnoreCase(Sub.OUT_OF_SERVICE))
				return IconsFactory.getOverlayIcon(null,
						IconsFactory.getImageIcon(IconsFactory.Tree.BBANK),
						IconsFactory.getImageIcon("icons/overlay_error.png"),
						IconsFactory.ICON_BBANK.getIconWidth()-12,
						IconsFactory.ICON_BBANK.getIconHeight()-12);
		} catch (SQLException e) {			
			e.printStackTrace();
		}
		return IconsFactory.ICON_BBANK;
	}

	public Vector<String> getInsertStatus(){
		Vector<String> errors = new Vector<String>();
		return errors;
	}

	/*
	 * (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObject#getChildren(int)
	 */
	public Collection<CoreObject> getChildren(int simId)throws SQLException{
		return getChildren(simId,SubFilter.CORE_SUB);
	}


	public Collection<CoreObject> getChildren(int simId, SubFilter sf)throws SQLException {
		Vector<CoreObject> collection = new Vector<CoreObject>();
		collection.addAll(getCkts(simId));
		collection.addAll(getBbanks(simId,sf));		
		return collection;
	}

	/*
	 * (non-Javadoc)
	 * @see com.sce.mdi.object.Sub#getAllEverSubVars()
	 */
	public TreeSet<SubVar> getAllEverSubVars(int simId) throws SQLException {
		return getSubVars(simId);
	}

	public TreeSet<Ckt> getCkts() throws SQLException{
		return getCkts(getSimId());
	}
	public TreeSet<Ckt> getCkts(int simId) throws SQLException{
		@SuppressWarnings("unchecked")
		TreeSet<Ckt> ckts = (TreeSet<Ckt>)getCachedValue("getCkts",simId);
		if(ckts==null){
			ckts = new TreeSet<Ckt>();
			for(SceProjElemCost costs:getSceProjElemCosts())
				if(costs.getSceProjRev() != null && costs.getSceProjRev().isCurRev(getPlanyear(),simId))
					ckts.addAll(costs.getCktsAdd(getPlanyear()));
			
			setCachedValue(ckts,"getCkts",simId);
		}
		return ckts;
	}
	public int getCktCount(int simId) throws SQLException{
		return getCkts(simId).size();
	}
	public Bbank getPlanYearInstance(int planyear)throws SQLException{
		return getInstance(planyear,getSubId());
	}
	public int getPaFin(int simId) throws SQLException {
		int count = isPaFinalized(simId)?1:0;
		//		for(Ckt ckt:getCkts(simId))
		//			if(ckt.isPaFinalized(simId))
		//				count++;
		return count;
	}
	public int getPaApp(int simId) throws SQLException {
		int count = isPaApproved(simId)?1:0;
		//		for(Ckt ckt:getCkts(simId))
		//			if(ckt.isPaApproved(simId))
		//				count++;
		return count;
	}
	public int getPaTotal(int simId) throws SQLException {
		return 1;//+getCktCount(simId);
	}
	public int getLgFin(int simId) throws SQLException {
		int count = isLgFinalized(simId)?1:0;
		//		for(Ckt ckt:getCkts(simId))
		//			if(ckt.isLgFinalized(simId))
		//				count++;
		return count;
	}
	public int getLgApp(int simId) throws SQLException {
		int count = isLgApproved(simId)?1:0;
		//		for(Ckt ckt:getCkts(simId))
		//			if(ckt.isLgApproved(simId))
		//				count++;
		return count;
	}
	public int getLgTotal(int simId) throws SQLException {
		return 1;//+getCktCount(simId);
	}
	public int getCsFin(int simId) throws SQLException {
		int count = 0;
		for(Ckt ckt:getCkts(simId))
			if(ckt.isCaFinalized())
				count++;
		return count;
	}
	public int getCsApp(int simId) throws SQLException {
		int count = 0;
		for(Ckt ckt:getCkts(simId))
			if(ckt.isCaApproved())
				count++;
		return count;
	}
	public int getCsTotal(int simId) throws SQLException {
		return getCktCount(simId);
	}
	public int getN1Fin(int simId) throws SQLException {
		return isN1Finalized()?1:0;
	}
	public int getN1App(int simId) throws SQLException {
		return isN1Approved()?1:0;
	}
	public int getN1Total(int simId) throws SQLException {
		return 1;
	}
	public int getVarFin(int simId) throws SQLException {
		return isVarFinalized()?1:0;
	}
	public int getVarApp(int simId) throws SQLException {
		return isVarApproved()?1:0;
	}
	public int getVarTotal(int simId) throws SQLException {
		return 1;
	}

	/*
	 *  (non-Javadoc)
	 * @see com.sce.mdi.object.SubYear#getCoinChildTotalProjLoad()
	 */
	public double getCoinChildTotalProjLoad(int simId) throws SQLException {
		double childsum = 0;
		for(Ckt c:getCkts(simId))
			childsum += c.getDailyPeak(getPeakDate(simId),true).getActualPeak()*c.getDailyPeak(getPeakDate(simId),true).getCoinFactor();
		return childsum;
	}

	public double getVarARequired(int simId, int year) throws SQLException {
		return getYear(simId, year).getAbank().getVarARequired(simId, year);
	}

	public double getVarASupply(int simId, int year) throws SQLException {
		return getYear(simId, year).getAbank().getVarASupply(simId, year);
	}

	public double getVarBRequired(int simId, int year) throws SQLException {
		return getYear(simId, year).getFieldVarReq()/1000 + getYear(simId, year).getStationMvarReq();
	}

	public double getVarBSupply(int simId, int year) throws SQLException {
		return getYear(simId, year).getChildBBanksFieldKvar()/1000 + getYear(simId, year).getChildBBanksStationKvar()/1000;
	}

	public double getVarAReserved(int simId, int year) throws SQLException {
		return getVarASupply(simId, year) - getVarARequired(simId, year);
	}

	public double getVarBReserved(int simId, int year) throws SQLException {
		return getVarBSupply(simId, year) - getVarBRequired(simId, year);
	}

	public AutomatedEquipment getCoinParent() throws SQLException {
		return getYear(0,getPlanyear()-1).getParent();
	}

	public TreeSet<SwtProc> getAllSwtProcs(int simId) throws SQLException{
		TreeSet<SwtProc> swtProcs = new TreeSet<SwtProc>();
		for(BbankTie tie:getFromTies(simId)){
			swtProcs.addAll(tie.getSwtProcs());
//						System.out.println(" b from tie");
		}for(BbankTie tie:getToTies(simId)){
			swtProcs.addAll(tie.getSwtProcs());
//						System.out.println(" b to tie");
		}

		swtProcs.addAll(getSwtProcs());
		//			System.out.println(" bbank ");

		for(Ckt ckt:getCkts(simId)){
			for(CktTrans ct:ckt.getFromCktTrans()){
				swtProcs.add(ct.getSwtProc());
				//				System.out.println(" ckt from tie");
			}for(CktTrans ct:ckt.getToCktTrans()){
				swtProcs.add(ct.getSwtProc());
				//				System.out.println(" ckt to tie");
			}
		}
		return swtProcs;
	}

	public CoType getCoType() throws SQLException{
		return CoType.getInstance(CoType.BBANK);
	}
	public double getN1Factor(Calendar asOf, int simId) throws SQLException{
		SceProjElemCost last = getMostRecentSceProjElemCost(asOf,simId);
		if(last != null)
			return last.getN1FactorPost(getPlanyear(),simId);
		return 0;
	}
	public double getN1FactorInService(Calendar asOf,int simId) throws SQLException{
		SceProjElemCost last = getMostRecentSceProjElemCostInService(asOf);
		if(last != null)
			return last.getN1FactorPost(getPlanyear(),simId);
		return 0;
	}
	public TreeSet<Ckt> getCkts(Calendar asOf, int simId, Collection<SceProjElemCost> without)throws SQLException{
		TreeSet<Ckt> ckts = (TreeSet<Ckt>)getCachedValue("getCkts",asOf,simId,without);
		if(ckts==null){
			SceProjElemCost last = getMostRecentSceProjElemCost(asOf,simId);
			if(last != null)
				ckts = last.getCktsPost(getPlanyear(),simId,without);
			else
				ckts = new TreeSet<Ckt>();
			setCachedValue(ckts,"getCkts",asOf,simId,without);
		}
		return ckts;
	}
	public TreeSet<Ckt> getCktsInService(Calendar asOf,int simId)throws SQLException{
		SceProjElemCost last = getMostRecentSceProjElemCostInService(asOf);
		if(last != null)
			return last.getCktsPost(getPlanyear(),simId,null);
		return new TreeSet<Ckt>();
	}
	/**
	 * 
	 * @return
	 * @throws SQLException
	 * @deprecated
	 */
	public double getDepartedLoad() throws SQLException{
		double departed=0;
		if(getPlanYearInstance(2008) != null && getPlanYearInstance(2010) != null)
			departed = getPlanYearInstance(2008).getAdjustedPeak(getSimId()) - getPlanYearInstance(2010).getAdjustedPeak(getSimId());
		if(departed < 0)
			return 0;
		return departed;
	}
	/**
	 * 
	 * @return
	 * @throws SQLException
	 * @deprecated
	 */
	public int getRecoverYear() throws SQLException{
		int ry=0;
		for(int year=getPlanyear(); year<getPlanyear()+10; year++){
			if(getYear(getSimId(),year).getDsmFactor() <= 1)//Stop when you get to the first year that is back to 1.0 DSM
				break;
			ry = year;
		}
		return ry;
	}	

	/**
	 * 
	 * @return
	 * @throws SQLException
	 * @deprecated
	 */
	public double getDepartedUserAdj() throws SQLException {

		int ry = getRecoverYear();
		//EspLogger.debug(this, "ry: " + ry);

		if(ry > 0){

			double total = 0;

			for(int y=getRecoverYear(); y>=2010; y--){

				total += getYear(getSimId(), y).getGrowth();
				//				EspLogger.debug(this, y+" "+total);
			}


			//EspLogger.debug(this, "total: "+total + " userAdj: "+(total - getDepartedLoad()));

			return total - getDepartedLoad();

		}
		return 0;
	}

	@Override//XXX
	public double getPRN(int simId) throws SQLException {
		return this.getSimSub(simId).getPRN();
	}

	@Override
	public double getNormPRN(int simId) throws SQLException {
		return getSimSub(simId).getNormPRN();
	}

	@Override
	public boolean isPRNEditable(int simId) throws SQLException {
		return getSimSub(simId).isPRNEditable();
	}

	@Override
	public double getAltPRN(int simId) throws SQLException {
		return getSimSub(simId).getAltPRN();
	}

	public boolean useUserPRN() {
		String state=getState();
		if(state!=null)
			return state.equals("1");//update MDI.MDI105_SUB set state='1' where planyear=2011
		return false;
	}

	public void setUserPRN(boolean state) throws SQLException{
		if(state)
			setState("1");
		else
			setState("0");
	}

	/**
	 * Sets the lgFinalized as well as all of the bbank's circuits lgFinalized.
	 *
	 * @param The new lgFinalized
	 * @param simId the sim id
	 * @param lgFinalized the lg finalized
	 *
	 * @throws SQLException the SQL exception
	 */
	public void setLgFinalized(int simId, boolean lgFinalized) throws SQLException {
		super.setLgFinalized(simId, lgFinalized);
		for(Ckt c : getCkts(simId))
			c.setLgFinalized(simId, lgFinalized);
	}

	/**
	 * Sets the lgApproved as well as all of the bbank's circuits lgApproved.
	 *
	 * @param The new lgApproved
	 * @param simId the sim id
	 * @param lgApproved the lgApproved
	 *
	 * @throws SQLException the SQL exception
	 */
	public void setLgApproved(int simId, boolean lgApproved) throws SQLException {
		super.setLgApproved(simId, lgApproved);
		for(Ckt c : getCkts(simId))
			c.setLgApproved(simId, lgApproved);
	}
	@Override
	public Bbank getPrevInstance() throws SQLException {
		return getInstance(getPlanyear()-1,getBbankSubId());
	}
	
	public void insert() throws SQLException{
		if(isNewInstance()){
			super.insert();
			String table = Bbank.class.getAnnotation(Table.class).name();
			table = table.substring(0, table.length()-2);
			PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement("INSERT INTO MDI108_BBANK(PLANYEAR,BBANK_SUB_ID,N1_FACTOR,N1_FINALIZED,N1_APPROVED,VAR_FINALIZED,VAR_APPROVED) VALUES(?,?,?,?,?,?,?)");
			int x=1;
			ps.setInt(x++, getPlanyear());
			ps.setInt(x++, getSubId());
			ps.setDouble(x++, getN1Factor());
			ps.setBoolean(x++, isN1Finalized());
			ps.setBoolean(x++, isN1Approved());
			ps.setBoolean(x++, isVarFinalized());
			ps.setBoolean(x++, isVarApproved());
			try{
				ps.executeUpdate();
			}finally{
				ps.close();
			}
		}
		insertChildren();
	}
	
	public TreeSet<SceProjRev> getSceProjRevsCostYr(int simId, Collection<Program> progs,int projStatuses,int costYear) throws SQLException {
		TreeSet<SceProjRev> sceProjRevs = new TreeSet<SceProjRev>();
		for(Sub sub : getDownStreamSubs(simId)) {
			for(SceProjElemCost spec : sub.getSceProjElemCosts()) {
				if(spec.getCost(costYear) > 0){
					SceProjRev rev = spec.getSceProjRev().getSceProj().getCurRev(getPlanyear(), simId);
					if(rev != null && (progs == null || progs.contains(rev.getProgram())) && (rev.getProjectStatus() & projStatuses) > 0)
						sceProjRevs.add(rev);
				}
			}
		}
		return sceProjRevs;
	}
	
	
	
	/**
	 * Gets Substations that have ties with this BBank
	 * via circuit ties
	 * @return adjacent Substations
	 *
	 * @throws SQLException the SQL exception
	 */
	//XXX finish testing
	public TreeSet<Sub> getAdjSubsViaCktTie()throws SQLException{
		TreeSet<Sub> tieSub = new TreeSet<Sub>();
		for(Ckt ckt : getCkts(getSimId()) )
			for(Ckt adjCkt: ckt.getTieCktsToAdjSubs())
				tieSub.add(adjCkt.getBbank());
		return tieSub;
	}
	/**
	 * Gets tie circuit from adjacent subs that tie
	 * with this BBank
	 * @return Tie Circuits (from adjacent subs)
	 *
	 * @throws SQLException the SQL exception
	 */
	//XXX finish testing
	public TreeSet<Ckt> getTieCktsAtAdjSub(Bbank tieSub)throws SQLException{
		TreeSet<Ckt> tieCkts = new TreeSet<Ckt>();
		// Get circuit from adjacent (tie) sub
		for(Ckt adjCkt : tieSub.getCkts(getSimId()) ){
//			System.out.println(" adj ckt: "+adjCkt + " o/o "+adjCkt.getBbank());
			// get circuits that tie to adjacent subs
			for(Ckt tieCkt: adjCkt.getTieCktsToAdjSubs()){
//				System.out.println(" tie ckt: "+tieCkt + " o/o "+tieCkt.getBbank());
				// get circuits at other sub that tie to this bbank
				if(tieCkt.getBbank() == this){
//					System.out.println(" WINNER: "+tieCkt + " o/o "+tieCkt.getBbank());
					tieCkts.add(adjCkt);
				}
			}
		}
		return tieCkts;
	}
	
	/**
	 * Gets tie circuit from this BBank that tie
	 * with this adjacent subs
	 * @return Tie Circuits (from this BBank)
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<Ckt> getTieCktsAtThisSubThatTieToAdjSub(Bbank tieSub)throws SQLException{
		TreeSet<Ckt> tieCkts = new TreeSet<Ckt>();
		// Get ckts that circuits from adjacent sub (tie)
		for(Ckt adjCkt : tieSub.getCkts(getSimId()) ){
			// Get circuits that tie to adjacent subs
			for(Ckt tieCkt: adjCkt.getTieCktsToAdjSubs()){
				//Get Circuits at this bbank that tie to adjacent subs
				if(tieCkt.getBbank() == this){
					tieCkts.add(tieCkt);
				}
			}
		}
		return tieCkts;
	}
	
	
}
