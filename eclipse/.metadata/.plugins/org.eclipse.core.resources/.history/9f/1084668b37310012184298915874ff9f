/**
 *           | Master Data Interface Version 2.0 |
 *
 * Copyright (c) 2006, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team.
 * 	                   All rights reserved.
 *
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package com.dd4.iis.object.dao;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Reader;
import java.io.Writer;
import java.sql.Clob;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Observable;
import java.util.Vector;

import javax.persistence.Column;

import oracle.sql.CLOB;

import com.dd4.common.jpa.AICache;
import com.dd4.common.jpa.AutoInsertable;
import com.dd4.common.jpa.Change;
import com.dd4.common.jpa.ChangeLog;
import com.dd4.common.jpa.Entity;
import com.dd4.common.jpa.EntityManagerHelper;
import com.dd4.common.jpa.PrimaryKey;
import com.dd4.common.util.Calculate;
import com.dd4.common.util.FormatText;
import com.dd4.common.jdbc.PDBConnection;


/**
 * The MDIObject Object.
 *
 * @author Distribution Staff Engineering
 * @version 2.0
 */
public abstract class DataAccessObject extends Observable implements Comparable<Object>, ChangeLog, Entity{
	private static Vector<Class<DataAccessObject>> allClasses;
	private static Vector<Class<DataAccessObject>> allSpiClasses;

	private static AICache aiCache=new AICache();
	public static boolean AG_CACHE_ENABLED=true;
	private Map<String,Object> valueCache;
	private Vector<DataAccessObject> watchers;
	
	protected boolean prevInstanceRead=false;
	protected Calendar insertTs; //INSERT_DATE
	protected Integer insertUserId; //INSERT_USER_ID
	protected Calendar modifiedTs; //MODIFIED_DATE
	protected Integer modifiedUserId; //MODIFIED_USER_ID
	protected Calendar deletedTs; //DELETED_DATE
	protected Integer deletedUserId; //DELETED_USER_ID
	
	private HashMap<String,Change> changes;
	
    /**
     * Creates a new instance of DBObject.
     */
    public DataAccessObject() {
    }

    public DataAccessObject(DataAccessObject orig){
	}

	/**
     * Checks if is new instance.
     *
     * @return true, if is new instance
     */
    public boolean isNewInstance(){
    	return EntityManagerHelper.getEntityManager()==null || !EntityManagerHelper.getEntityManager().contains(this);
    }
    
//    protected void setNewInstance(boolean newInstance) {
//		this.newInstance = newInstance;
//	}
    
    public int isAutoInsertable(){
    	return 0;
    }

    /**
     * Compare to.
     *
     * @param o the o
     *
     * @return the int
     */
    public int compareTo(Object o){
    	//If this is the same exact object in memory then just say so
    	if(this == o)
    		return 0;
    	if(o instanceof DataAccessObject)
    		return (toString()+getHashKey()).compareTo(o.toString()+((DataAccessObject)o).getHashKey());
        return 0;
    }

    /**
     * Gets the hash key.
     *
     * @return the hash key
     */
    public abstract String getHashKey();

    /**
     * Refresh.
     *
     * @return true, if refresh
     *
     * @throws SQLException the SQL exception
     */
    public void refresh()throws SQLException{
    	EntityManagerHelper.getEntityManager().refresh(this);
    }
    
    @Column(name="INSERT_TS",nullable=true,length=7)
    /**
	 * Returns the insertDate
	 * @return The insertDate
	 */
	public Calendar getInsertTs(){
		if(isNewInstance() && insertTs==null)
			return Calendar.getInstance();
		return insertTs;
	}
	
	/**
	 * Sets the insertDate
	 * @param The new insertDate
	 */
	public void setInsertTs(Calendar insertDate)throws SQLException{
		if(isSame(insertDate,getInsertTs())) return;
		setProperty("INSERT_TS",insertDate,getInsertTs());
		this.insertTs = insertDate;
	}

	@Column(name="INSERT_USER_ID",nullable=true,length=9)
	/**
	 * Returns the insertUserId
	 * @return The insertUserId
	 */
	public Integer getInsertUserId(){
		if(isNewInstance() && insertUserId==null && User.getActiveUser()!=null)
			return User.getActiveUser().getUsernameId();
		return insertUserId;
	}

	/**
	 * Sets the insertUserId
	 * @param The new insertUserd
	 */
	public void setInsertUserId(Integer insertUserId)throws SQLException{
		if(isSame(insertUserId,getInsertUserId())) return;
		setProperty("INSERT_USER_ID",insertUserId,getInsertUserId());
		this.insertUserId = insertUserId;
	}

	@Column(name="MODIFIED_TS",nullable=true,length=7)
	/**
	 * Returns the modifiedDate
	 * @return The modifiedDate
	 */
	public Calendar getModifiedTs(){
		return modifiedTs;
	}

	/**
	 * Sets the modifiedDate
	 * @param The new modifiedDate
	 */
	public void setModifiedTs(Calendar modifiedDate)throws SQLException{
		if(isSame(modifiedDate,getModifiedTs())) return;
		setProperty("MODIFIED_TS",modifiedDate,getModifiedTs());
		this.modifiedTs = modifiedDate;
	}

	@Column(name="MODIFIED_USER_ID",nullable=true,length=9)
	/**
	 * Returns the modifiedUserId
	 * @return The modifiedUserId
	 */
	public Integer getModifiedUserId(){
		return modifiedUserId;
	}

	/**
	 * Sets the modifiedUsernameId
	 * @param The new modifiedUsernameId
	 */
	public void setModifiedUserId(Integer modifiedUserId)throws SQLException{
		if(isSame(modifiedUserId,getModifiedUserId())) return;
		setProperty("MODIFIED_USER_ID",modifiedUserId,getModifiedUserId());
		this.modifiedUserId = modifiedUserId;
	}

	@Column(name="DELETED_TS",nullable=true,length=7)
	/**
	 * Returns the deleteDate
	 * @return The deleteDate
	 */
	public Calendar getDeletedTs(){
		return deletedTs;
	}

	/**
	 * Sets the deleteDate
	 * @param The new deleteDate
	 */
	public void setDeletedTs(Calendar deleteDate)throws SQLException{
		if(isSame(deleteDate,getDeletedTs())) return;
		setProperty("DELETED_TS",deleteDate,getDeletedTs());
		this.deletedTs = deleteDate;
	}

	@Column(name="DELETED_USER_ID",nullable=true,length=9)
	/**
	 * Returns the deleteUserId
	 * @return The deleteUserId
	 */
	public Integer getDeletedUserId(){
		return deletedUserId;
	}

	/**
	 * Sets the deleteUsernameId
	 * @param The new deleteUsernameId
	 */
	public void setDeletedUserId(Integer deletedUserId)throws SQLException{
		if(isSame(deletedUserId,getDeletedUserId())) return;
		setProperty("DELETED_USER_ID",deletedUserId,getDeletedUserId());
		this.deletedUserId = deletedUserId;
	}

//	public abstract Map<String,Object> getPropertyValues();

//	public void setPropertyValues(Map<String,Object> pc) throws SQLException{
//		insertTs = (Calendar)pc.get("INSERT_TS");
//		insertUserId = (Integer)pc.get("INSERT_USER_ID");
//		modifiedTs = (Calendar)pc.get("MODIFIED_TS");
//		modifiedUserId = (Integer)pc.get("MODIFIED_USER_ID");
//		deletedTs = (Calendar)pc.get("DELETED_TS");
//		deletedUserId = (Integer)pc.get("DELETED_USER_ID");
//	}
	public User getInsertUser()throws SQLException{
		return User.getInstance(getInsertUserId());
	}
	public void setInsertUser(User user)throws Exception{
		if(user==null)
			setInsertUserId(0);
		else
			setInsertUserId(user.getUsernameId());
	}
	public User getModifiedUser() throws SQLException {
		return User.getInstance(getModifiedUserId());
	}
	public void setModifiedUser(User user2)throws Exception{
		if(user2==null)
			setModifiedUserId(0);
		else
			setModifiedUserId(user2.getUsernameId());
	}
	public User getDeletedUser()throws SQLException{
		return User.getInstance(getDeletedUserId());
	}
	public void setDeletedUser(User user3)throws SQLException{
		if(user3==null)
			setDeletedUserId(0);
		else
			setDeletedUserId(user3.getUsernameId());
	}
	
	public Collection<Change> getChanges(){
		return changes.values();
	}
	
	public void addChange(String prop, Object newValue, Object oldValue){
		if(changes == null)
			changes = new HashMap<String,Change>();
		changes.put(prop, new Change(prop,newValue,oldValue));
	}

	protected void setProperty(String prop, Object newValue, Object oldValue) throws SQLException{
		if(prop==null)return;
		if(getClass().getAnnotation(AutoInsertable.class)!=null && isNewInstance()){
			insert();
			return;
		}
		if(isNewInstance()) return;
		modifiedTs = Calendar.getInstance();
		modifiedUserId = User.getActiveUser().getUsernameId();
		addChange(prop, newValue,oldValue);
		addChange("MODIFIED_TS", modifiedTs, getModifiedTs());
		addChange("MODIFIED_USER_ID", modifiedUserId, getModifiedUserId());
		save();
	}

	public void delete() throws SQLException{
		deletedTs = Calendar.getInstance();
		deletedUserId = User.getActiveUser().getUsernameId();
		addChange("DELETED_TS", deletedTs, getDeletedTs());
		addChange("DELETED_USER_ID", deletedUserId, getDeletedUserId());
		save();
	}
	
	public void restore() throws SQLException{
		deletedTs = null;
		deletedUserId = null;
		addChange("DELETED_TS", deletedTs, getDeletedTs());
		addChange("DELETED_USER_ID", deletedUserId, getDeletedUserId());
		save();
	}
	
	/**
	 * This does not insert into the database.  This call EntityManager merge.
	 */
	public void save(){
		if(changes!=null){
			EntityManagerHelper.getEntityManager().merge(this);
			changes.clear();
		}
	}

	public void deleteDB() throws SQLException{
		EntityManagerHelper.getEntityManager().remove(this);
	}	
	
	public boolean isDeleted(){
		return getDeletedTs()!=null;
	}

    /**
     * Gets the real record.
     *
     * @return the real record
     */
    public DataAccessObject getRealRecord(){
    	return this;
    }

    /**
     * Checks if is real record.
     *
     * @return true, if is real record
     */
    public boolean isRealRecord(){
    	return getRealRecord() == this;
    }


    /**
     * Pre Insert.
     *
     * @return true, if insert
     *
     * @throws SQLException the SQL exception
     */
    public boolean preSimCopy()throws Exception{
        return true;
    }
    
    public void insertParents()throws SQLException{
    }

    /**
     * Insert.
     *
     * @throws SQLException the SQL exception
     */
    public void insert()throws SQLException{
    	insertParents();
    	if(isNewInstance()){
    		EntityManagerHelper.getEntityManager().persist(this);
    		this.insertTs=Calendar.getInstance();
    		if(User.getActiveUser() != null)
    			this.insertUserId=User.getActiveUser().getUsernameId();
    	}
    	insertChildren();
    }
    
    public void insertChildren()throws SQLException{ 	
    }
    
    public static boolean isSame(Object o, Object o2){
    	return Calculate.isSame(o, o2);
    }

    /**
     * Returns a string hash code of an object of this type with the
     * specified parameters. The hash code would be used to find the
     * object in a hash table.
     *
     * @param id - id for the object
     * @param planyear - planYear for the object
     * @param k1 the k1
     *
     * @return a string hash code of an object of this type with the specified parameters.
     */
    
    public static String getHashKey(Object[] keys){
    	return PrimaryKey.getHashKey(keys);
    }
    
    public static String getHashKey(Object key){
    	return PrimaryKey.getHashKey(key);
    }

    public static boolean isNull(Object... keys){
    	for(Object k:keys)
    		if(Calculate.isNull(k))
    			return true;
    	return false;
    }
    
    public static boolean isNull(Object o){
    	return Calculate.isNull(o);
    }

    /**
     * To string.
     *
     * @return the string
     */
    public String toString(){
    	return getHashKey();
    }

    @SuppressWarnings("unchecked")
	public static Class<DataAccessObject> getClassByDBTable(String table){
    	try{
    		return (Class<DataAccessObject>)Class.forName("com.sce.esp.object."+FormatText.toUpperCamel(table.substring(table.indexOf('_')+1)));
    	}catch(Exception e){
    		//e.printStackTrace();
    	}
		return null;
	}
    
    
    public static Vector<Class<DataAccessObject>> getAllObjects(String tableSearch) throws SQLException{
		if(allClasses == null){
    		allClasses = new Vector<Class<DataAccessObject>>();
    		DatabaseMetaData dbmd = PDBConnection.getInstance().getConnection().getMetaData();
    		ResultSet rs = dbmd.getTables(null,PDBConnection.SCHEMA,tableSearch,new String[]{"TABLE"});
    		while(rs.next()){
				String table = rs.getString("TABLE_NAME");
				if(table.charAt(6) == '_' && !table.startsWith("MDI005_") && !table.contains("REPORT")){
					Class<DataAccessObject> c = getClassByDBTable(table);
					if(c !=null)
						allClasses.add(c);
				}
    		}
    		rs.close();
    	}
    	return allClasses;
    }
    
    public static Vector<Class<DataAccessObject>> getAllSpiObjects() throws SQLException{
    	if(allSpiClasses == null){
    		allSpiClasses = new Vector<Class<DataAccessObject>>();
    		DatabaseMetaData dbmd = PDBConnection.getInstance().getConnection().getMetaData();
    		ResultSet rs = dbmd.getTables(null,PDBConnection.SCHEMA,"MDIS%_%",new String[]{"TABLE"});
    		while(rs.next()){
				String table = rs.getString("TABLE_NAME");
				if(table.charAt(6) == '_' && !table.startsWith("MDI005_") && !table.contains("REPORT")){
					Class<DataAccessObject> c = getClassByDBTable(table);
					if(c !=null)
						allSpiClasses.add(c);
				}
    		}
    		rs.close();
    	}
    	return allClasses;
    }
    
    public static Object getId(int id){
    	if(id == 0)
    		return null;
    	return id;
    }
    public static void sleep(int millis){
    	try {
			Thread.sleep(millis);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
    }
    public Vector<String> getDifference(DataAccessObject dao){
    	return new Vector<String>();
    }
    public void copyChildrenTo(DataAccessObject cp){
    }

//	public abstract void cache(String[] props) throws SQLException;
//	
//	public abstract String[] getProperties();
//	
//	public abstract String[] getKeyProperties();
//	
//	public abstract Object getPropertyValue(String property);
	
//	public abstract void setPropertyValue(String property, Object value)throws SQLException;

	//public abstract Object[] getKeyValues();
	
	/**
     * Always treat de-serialization as a full-blown constructor, by
     * validating the final state of the de-serialized object.
     */
     private void readObject(ObjectInputStream aInputStream) throws ClassNotFoundException, IOException {
       //always perform the default de-serialization first
       aInputStream.defaultReadObject();

//       //make defensive copy of the mutable Date field
//       fDateOpened = new Date( fDateOpened.getTime() );

       //ensure that object state has not been corrupted or tampered with maliciously
       validateState();
    }

      /**
      * This is the default implementation of writeObject.
      * Customise if necessary.
      */
      private void writeObject(ObjectOutputStream aOutputStream) throws IOException {
        //perform the default serialization for all non-transient, non-static fields
        aOutputStream.defaultWriteObject();
      }
      
      /**
       * Verify that all fields of this object take permissible values; that is,
       * this method defines the class invariant.
       *
       * In this style of implementation, both the entire state of the object
       * and its individual fields can be validated without repeating or
       * duplicating code.
       * Each condition is defined in one place. Checks on the entire
       * object are performed at the end of object construction, and at
       * the end of de-serialization. Checks on individual fields are
       * performed at the start of the corresponding setXXX method.
       * As well, this style replaces the if's and throwing
       * of exceptions at the start of a setXXX, with a simple call to validateXXX.
       * Validation is separated from the regular path of execution,
       * which leads to improved legibility.
       *
       * @throws IllegalArgumentException if any field takes an unpermitted value.
       */
       private void validateState() {
//          validateAccountNumber(fAccountNumber);
//          validateName(fFirstName);
//          validateName(fLastName);
//          validateDateOpened(fDateOpened);
       }

       /**
   	 * De-serialize the Object from the file
   	 */
   	public Object deserialize(String fileName) {

   		Object deserializedObject = null;
   		try {
   			ObjectInputStream in = new ObjectInputStream(new FileInputStream(
   					fileName));
   			deserializedObject = in.readObject();
   			in.close();
   		} catch (Exception ex) {
   			System.out.println("Error Reading Object to File :"
   					+ ex.getMessage());
   			ex.printStackTrace();

   		}
   		return deserializedObject;
   	}

   	/**
   	 * Serializes the object to a file
   	 * 
   	 * @param objToSerialize
   	 */
   	public void serialize(Object objToSerialize,String fileName) {
   		try {
   			ObjectOutputStream out = new ObjectOutputStream(
   					new FileOutputStream(fileName));
   			out.writeObject(objToSerialize);
   			out.close();
   		} catch (Exception ex) {
   			System.out.println("Error Saving Object to File :"+ ex.getMessage());
   			ex.printStackTrace();
   		}
   	}
   	
    
//    public void valueChanged() {
//    	notify(this);
//    	setDirtyBit(true);
//    }
    
   // protected boolean isDirtybit=true;
    public void setDirtyBit(boolean dirtyBit) {
		//isDirtybit=dirtyBit;
	}
    
    public static AICache getAICache(){
    	return aiCache;
    }
    protected Map<String,Object> getValueCache(){
    	if(valueCache==null)
    		valueCache = Collections.synchronizedMap(new HashMap<String,Object>());
    	return valueCache;
    }
	public Object getCachedValue(String method, Object... params){
		if(!AG_CACHE_ENABLED)return null;
		return getValueCache().get(getMethodKey(method,params));
	}
	public void setCachedValue(Object value, String method, Object... params){
		if(AG_CACHE_ENABLED)
			getValueCache().put(getMethodKey(method,params), value);
	}
	public void invalidateCache(String method, Object... params){
		getValueCache().remove(getMethodKey(method,params));
	}
	public Vector<DataAccessObject> getWatchers(){
		return watchers;
	}
	public void addWatcher(DataAccessObject w){
		if(watchers==null)
			watchers = new Vector<DataAccessObject>();
		watchers.add(w);
	}
	public void removeWatcher(DataAccessObject w){
		if(watchers==null)return;
		watchers.remove(w);
	}
	public void invalidateAllCache(){
		getValueCache().clear();
		Vector<DataAccessObject> watchers = getWatchers();
		if(watchers!=null)
			for(DataAccessObject w:watchers)
				w.invalidateAllCache();
	}
	public String getMethodKey(String method, Object... params){
		String key = method+"("+PrimaryKey.getHashKey(params)+")";
		//EspLogger.message(this, key);
		return key;
	}
	
	public static String clob2String(Clob clob) throws SQLException{
		String data=null;
		Reader is=null;
		if(clob!=null){
			int length = (int) clob.length();
			if(length>0){
				is = clob.getCharacterStream();
				char[] buffer = new char[length];
				@SuppressWarnings("unused")
				int count = 0;
				try {
					StringBuffer sb = new StringBuffer();
					while ((count = is.read(buffer)) != -1)
						sb.append(buffer);
					// Assign StringBuffer to String.
					data = new String(sb); 
				}
				catch (Exception e) {

				} 
				finally{
					if(is!=null)
						try {
							is.close();
						} catch (IOException e) {
							e.printStackTrace();
						}
//					if(clob!=null)
//						clob.free();
				}
			}
		}
		return data;
	}

	public static Clob string2Clob(String data) throws SQLException {
		CLOB tempClob = null;
		try
		{
			// If the temporary CLOB has not yet been created, create new
			tempClob = CLOB.createTemporary(PDBConnection.getInstance().getConnection(), true, CLOB.DURATION_SESSION);
			// Open the temporary CLOB in readwrite mode to enable writing
			tempClob.open(CLOB.MODE_READWRITE);
			// Get the output stream to write
			Writer tempClobWriter = tempClob.getCharacterOutputStream();
			// Write the data into the temporary CLOB
			tempClobWriter.write(data);
			// Flush and close the stream
			tempClobWriter.flush();
			tempClobWriter.close();
			// Close the temporary CLOB
			tempClob.close();
		}
		catch (SQLException sqlexp)
		{
			tempClob.freeTemporary();
			sqlexp.getMessage();
		}
		catch (Exception exp)
		{
			tempClob.freeTemporary();
			exp.getMessage();
		}
		return tempClob;
	}
}
