/**
 *           | Master Data Interface Version 2.0 |                       
 * 
 * Copyright (c) 2002-2007, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team. 					  
 * 	                   All rights reserved.
 * 
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
package com.sce.esp.object.model;

import java.sql.SQLException;
import java.util.Calendar;
import java.util.Collection;
import java.util.TreeSet;
import java.util.Vector;

import com.sce.esp.util.Calculate;


/**
 * The SubYear Object.
 * 
 * @author Distribution Staff Engineering
 * @version 2.0
 */
public abstract class SubYear extends MDIObject implements LoadServingEntityYear{

	/** The bbanks. */
	private TreeSet<Bbank> bbanks;

	public SubYear(){
	}

	public SubYear(SubYear orig) {
		super(orig);
	}
	public abstract int getPlanyear();
	public abstract void setPlanyear(int planyear)throws SQLException;
	public abstract int getSimId();
	public abstract int getSubId();
	public abstract int getYear();
	public abstract SubYear getInstance(int year) throws SQLException;
	public static SubYear getInstance(int planyear, int simId, int subId, int year) throws SQLException{
		return getInstance(planyear,simId,subId,year,true);
	}
	public static SubYear getInstance(int planyear, int simId, int subId, int year, boolean fetch) throws SQLException{
		Sub sub = Sub.getInstance(planyear, subId, fetch);
		if(sub == null)
			return null;
		return sub.getYear(simId, year, fetch);
	}

	/**
	 * This returns the normal projected load depending on
	 * whether the user is using a user specified starting point
	 * or the real calculated starting point.
	 * 
	 * @return the proj load
	 * 
	 * @throws SQLException the SQL exception
	 */
	public abstract double getProjLoad() throws SQLException;
	
	public abstract double getTeqNormProjLoad() throws SQLException;
	
	public abstract double getTeqCriteriaProjLoad() throws SQLException;

	/**
	 * This returns the normal projected load based on
	 * the real calculated starting point.
	 * 
	 * @return the norm proj load
	 * 
	 * @throws SQLException the SQL exception
	 */
	public abstract double getNormProjLoad() throws SQLException;

	/**
	 * This returns the normal projected load based on the
	 * user specified starting point.
	 * 
	 * @return the alt proj load
	 * 
	 * @throws SQLException the SQL exception
	 */
	public abstract double getAltProjLoad() throws SQLException;

	/**
	 * This returns the coincident Projected load depending on
	 * whether the user is using a user specified starting point
	 * or the real calculated starting point.
	 * 
	 * @return the coincident projected load
	 * 
	 * @throws SQLException the SQL exception
	 */
	public abstract double getCoinProjLoad() throws SQLException;

	public double getGrowth()throws SQLException{		
		Double growth = (Double)getCachedValue("getGrowth");
		if(growth==null){
			growth=getGrowthNoPRNBC();
			growth*=getPRN();
			setCachedValue(growth,"getGrowth");
		}
		return growth;
	}

	public double getGrowthHC() throws SQLException {
		Double growth = (Double)getCachedValue("getGrowthHC");
		if(growth==null){
			growth=getGrowthNoPRNHC();//get reg g no prn
			growth*=getPRN();
			setCachedValue(growth,"getGrowthHC");
		}
		return growth;
	}

	public double getGrowthLC() throws SQLException {
		Double growth = (Double)getCachedValue("getGrowthLC");
		if(growth==null){
			growth=getGrowthNoPRNLC();
			growth*=getPRN();
			setCachedValue(growth,"getGrowthLC");
		}
		return growth;
	}
	

	
	
	public abstract double getGrowthNoPRNBC()throws SQLException;
	public abstract double getGrowthNoPRNHC()throws SQLException;
	public abstract double getGrowthNoPRNLC()throws SQLException;
	public abstract double getTotalAnnualTransfers()throws SQLException;
	public abstract double getOperDrf();
	public abstract void setOperDrf(double operDrf)throws SQLException;
	public abstract int getCriteriaId();

	/**
	 * 
	 * @return the calculated temperature range based
	 * on the substation weatherstation selections.
	 * 
	 * @throws SQLException
	 */
	public abstract double getTempRange()throws SQLException;


	/**
	 * Returns the tempSens.
	 * 
	 * @return The tempSens
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getSens() throws SQLException{
		if(isUseOperDRF())
			return 0;
		return getTempSensitivity();
	}

	/**
	 * Gets the down stream transfers.
	 * 
	 * @return total
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getDownStreamTransfers()throws SQLException{
		Double total = null;//(Double)getCachedValue("getDownStreamTransfers");
		if(total==null){
			total=0.0;
			for(Bbank bbank:getDownStreamSubs())
				total += bbank.getYear(getSimId(),getYear()).getDirectTransfers();
			//setCachedValue(total,"getDownStreamTransfers");
		}
		return total;
	}

	/**
	 * Gets the down stream transfer total.
	 * 
	 * @return total
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getDownStreamTransferTotal()throws SQLException{
		Double total = null;//(Double)getCachedValue("getDownStreamTransfers");
		if(total==null){
			total=0.0;
			for(Bbank bbank:getDownStreamSubs()){
				total += bbank.getYear(getSimId(),getYear()).getDirectTransferTotal();
			}
			//setCachedValue(total,"getDownStreamTransfers");
		}
		return total;
	}

	/**
	 * Gets the new child proj load wo xfers.
	 * 
	 * @return total
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getNewChildProjLoadWoXfers()throws SQLException{
		double total=0;
		TreeSet<Bbank> ccc = getDownStreamSubs();
		TreeSet<Bbank> scc = getInstance(getPlanyear()-1).getDownStreamSubs();
		ccc.removeAll(scc);

		@SuppressWarnings("unchecked")
		TreeSet<Bbank> clone = (TreeSet<Bbank>) ccc.clone();
		TreeSet<Bbank> cccClone = clone;

		if(cccClone!=null && cccClone.size()>0){
			for(Sub sub:cccClone){
				/** You Entered w/o your Parent: If your Parent is not in the results set, Add your load **/
				if(sub!=null && 
						((BbankYear)sub.getYear(getSimId(),getPlanyear()-1))!=null
						&& ccc!=null && //FIX MDI-2
						((BbankYear)sub.getYear(getSimId(),getPlanyear()-1)).getParent()!=null &&
						!ccc.contains(((BbankYear)sub.getYear(getSimId(),getPlanyear()-1)).getParent())){
					int effY = getYear()-1;
					while(getInstance(effY).getDownStreamSubs().contains(sub))
						effY--;
					total += sub.getStartingPoint(getSimId())+sub.getYear(getSimId(),effY).getGrowthTotal();
				}
				/** You Entered but Your Children did not: Reduce your load by your childrens load **/
				for(Bbank b:sub.getYear(getSimId(),getPlanyear()-1).getBbanks()){
					if(!ccc.contains(b)){
						int effY = getYear();
						while(b.getYear(getSimId(), effY).getParentSubId() != sub.getSubId())
							effY--;
						total -= b.getStartingPoint(getSimId())+b.getYear(getSimId(),effY).getGrowthTotal();
					}
				}
			}
		}
		return total;
	}

	/**
	 *
	 * Gets the removed child proj load wo xfers.
	 * 
	 * @return total
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getRemovedChildProjLoadWoXfers()throws SQLException{
		double total=0;
		TreeSet<Bbank> dc = getInstance(getPlanyear()-1).getBbanks();
		TreeSet<Bbank> ccc = getDownStreamSubs();
		TreeSet<Bbank> scc = getInstance(getPlanyear()-1).getDownStreamSubs();
		scc.removeAll(ccc);
		for(Sub sub:scc){
			/**  You were a direct child in the starting point year OR You left and Your parent stayed THEN add your starting point **/
			if(dc.contains((Bbank)sub) || !scc.contains(((BbankYear)sub.getYear(getSimId(),getPlanyear()-1)).getParent())){
				int effY = getYear()-1;
				//Added null check
				while(getInstance(effY)!=null && !getInstance(effY).getDownStreamSubs().contains(sub))
					effY--;
				if(sub.getYear(getSimId(),effY)!=null)
					total += sub.getStartingPoint(getSimId())+sub.getYear(getSimId(),effY).getGrowthTotal();
			}
			/** You Left but Your Children stayed: Reduce your starting point by your childrens load **/
			for(Bbank b:sub.getYear(getSimId(),getPlanyear()-1).getBbanks()){
				if(!scc.contains(b)){
					int effY = getYear();
					while(b.getYear(getSimId(), effY).getParentSubId() != sub.getSubId())
						effY--;
					total -= b.getStartingPoint(getSimId())+b.getYear(getSimId(),effY).getGrowthTotal();
				}
			}
		}
		return total;
	}

	/**
	 * This method returns a treeset of the direct children
	 * that leave the current substation.
	 * 
	 * @return the move in subs
	 * 
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<Bbank> getMoveInSubs()throws SQLException{
		TreeSet<Bbank> inSubs = new TreeSet<Bbank>();
		if(getYear()>getPlanyear()-1){
			TreeSet<Bbank> thisYear = getBbanks();
			TreeSet<Bbank> lastYear = getInstance(getYear()-1).getBbanks();
			for(Sub sub : thisYear) {
				if(!lastYear.contains(sub))
					inSubs.add((Bbank)sub);
			}
		}
		return inSubs;
	}

	/**
	 * This method returns a treeset of the direct children children
	 * that come into the current substation.
	 * 
	 * @return the move out subs
	 * 
	 * @throws SQLException the SQL exception
	 */

	public TreeSet<Bbank> getMoveOutSubs()throws SQLException{
		TreeSet<Bbank> inSubs = new TreeSet<Bbank>();
		if(getYear()>getPlanyear()-1){
			TreeSet<Bbank> thisYear = getBbanks();
			TreeSet<Bbank> lastYear = getInstance(getYear()-1).getBbanks();
			for(Sub sub : lastYear) {
				if(!thisYear.contains(sub))
					inSubs.add((Bbank)sub);
			}
		}
		return inSubs;
	}

	public double getPLLBizLogic()throws SQLException{
		return getNameplate()*getPLLFactor();
	}


	
	public double getELL()throws SQLException{
		return getNameplate()*getELLFactor();
	}

	public double getPLLFactor()throws SQLException{
		return getSub().getPLLFactor(getNormalizationDate(),getSimId());
	}

	public double getELLFactor()throws SQLException{
		return getSub().getELLFactor(getNormalizationDate(),getSimId());
	}

	/**
	 * Gets the project count.
	 * 
	 * @return the project count
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getProjectCount()throws SQLException {
		Integer total = (Integer)getCachedValue("getProjectCount");
		if(total==null){
			TreeSet<SceProj> projs = new TreeSet<SceProj>();
			for(SceProjElemCost spec:getSceProjElemCosts())
				if((spec.getSceProjRev().getProjStatusFull() & SceProjRev.PUBLISH) > 0)
					projs.add(spec.getSceProjRev().getSceProj());
			total = projs.size();
			setCachedValue(total,"getProjectCount");
		}
		return total;
	}

	/**
	 * Returns all of the Projects Status (Full) with commas seperation
	 * @return String
	 * @throws SQLException
	 */

	public String getProjectStatuses()throws SQLException {
		String status = (String)getCachedValue("getProjectStatuses");
		if(status==null){
			String out = "";
			int n=0, nc=0, r=0, c=0, C=0;
			for(SceProjElemCost spec:getSceProjElemCosts()){
				int st = spec.getStatusFull();
				switch(st){
					case SceProjRev.NEW: n++; break;
					case SceProjRev.NO_CHANGE: nc++; break;
					case SceProjRev.CANCELLED: c++; break;
					case SceProjRev.COMPLETE: c++; break;
					default: if((st & SceProjRev.REVISED) > 0) r++;
				}
			}
			if(n > 0)
				out += n+" new";
			if(nc > 0)
				out += nc+" no change";
			if(r > 0)
				out += r+" no change";
			if(c > 0)
				out += c+" cancelled";
			if(c > 0)
				out += C+" complete";
			status= out;
			setCachedValue(status,"getProjectStatuses");
		}
		return status;

	}

	public TreeSet<SceProj> getSceProjs() throws SQLException{
		TreeSet<SceProj> projs = new TreeSet<SceProj>();
		for(SceProjElemCost spec:getSceProjElemCosts())
			projs.add(spec.getSceProjRev().getSceProj());
		return projs;
	}

	public TreeSet<SceProjRev> getProjectsWithPCosts(Collection<Program> progs, int statuses)throws SQLException{
		TreeSet<SceProjRev> projs = new TreeSet<SceProjRev>();
		for(SceProjRev proj:getSub().getSceProjRevs(getSimId(),progs,statuses))
			if(proj.getTotalCost(CostStage.Type.Proposed,getYear())!=0 || proj.getProjectStatus() == Proj.CANCELLED || proj.getProjectStatus() == Proj.ABORTED)
				projs.add(proj);
		return projs;
	}

	public abstract int getCircuitCountNoProj(Proj without) throws SQLException;
	public abstract int getCircuitCountNoProj(SceProjRev without) throws SQLException;
	public abstract int getCktDelta(Collection<Program> p)throws SQLException;

	public double getNetCostChange(Collection<Program> p, SceElem e) throws SQLException {		
		return getPropCostTotal(p,e)-getAppCostTotal(p,e);
	}


	/**
	 * Gets the kvar add.
	 * 
	 * @return kvarAdd
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getKvarAdd()throws SQLException{
		Calendar lastYear = (Calendar)getNormalizationDate().clone();
		return getSub().getKvarLowSide(getNormalizationDate(), getSimId())-getSub().getKvarLowSide(lastYear, getSimId());
	}

	/**
	 * Gets the PLL add.
	 * 
	 * @return pllAdd
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getPLLAdd()throws SQLException{
		if(getYear()<getPlanyear()) return 0;
		return getPLLBizLogic()-getInstance(getYear()-1).getPLLBizLogic();
	}

	/**
	 * Gets the DRF.
	 * 
	 * @return the DRF
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getDRF()throws SQLException{
		if(isUseOperDRF())
			return getOperDrf();
		return getTempDRF();
	}

	/**
	 * Gets the temp DRF.
	 * 
	 * @return the temp DRF
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getTempDRF()throws SQLException{
		return getTempRange()*getTempSensitivity();
	}

	/**
	 * Gets the nameplate.
	 * 
	 * @return np
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getNameplate()throws SQLException{
		return getSub().getNameplate(getNormalizationDate(),getSimId());
	}
	
	public Calendar getNormalizationDate()throws SQLException{
		Calendar normDate = (Calendar)getCachedValue("getNormalizationDate");
		if(normDate==null){
			normDate = (Calendar)getSub().getNormalizationDate().clone();
			normDate.set(Calendar.YEAR, getYear());
			setCachedValue(normDate,"getNormalizationDate");
		}
		return normDate;
	}

	/**
	 * Gets the station average per unit impedance, 100 MVA base, Sub Secondary kV base.
	 * Used for distribution VAR planning
	 * 
	 * @return average per unit impedance
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getAverageImpedance()throws SQLException{
		double iAvg=0.0;
		double imp = 0;
		int count = 0;
		for(Xfmr xfmr:getSub().getXfmrs(getNormalizationDate(), getSimId())){
			if(xfmr.getImpedance()!=0){
				double baseKv = xfmr.getBaseKv();
				if(baseKv==0)
					baseKv = getSub().getSecondaryKv();
				double baseMVA = xfmr.getBaseMva();
				if(baseMVA==0)
					baseMVA = xfmr.getNameplate();
				imp+=Calculate.getImpedanceNew100mvaBase(xfmr.getImpedance(),baseKv,getSub().getSecondaryKv(),baseMVA);
				count++;
			}
		}
		iAvg = count==0?0:(imp/count*getSub().getSecondaryKv()*getSub().getSecondaryKv())/count;
		return iAvg;
	}

	/**
	 * Gets the station per unit impedance, 100 MVA base
	 * Assumes all transformation is in parallel
	 *
	 * @return per unit impedance
	 *
	 * @throws SQLException the SQL exception
	 */

	public double getImpedance()throws SQLException{
		double iAvg=0.0;
		double imp = 0;
		for(Xfmr xfmr:getSub().getXfmrs(getNormalizationDate(), getSimId())){
			if(xfmr.getImpedance()!=0){
				double baseKv = xfmr.getBaseKv();
				if(baseKv==0)
					baseKv = getSub().getPrimaryKv();
				double baseMVA = xfmr.getBaseMva();
				if(baseMVA==0)
					baseMVA = xfmr.getNameplate();
				double impTemp=Calculate.getImpedanceNew100mvaBase(xfmr.getImpedance(),baseKv,getSub().getPrimaryKv(),baseMVA);
				if(impTemp!=0)
					imp+=1/impTemp;
			}
		}
		if(imp!=0)
			imp=1/imp;
		iAvg= imp;
		return iAvg;
	}


	/*
	 *  (non-Javadoc)
	 * @see com.sce.mdi.object.LoadServingEntityYear#getCProjLoad()
	 */
	public double getCriteriaProjLoad()throws SQLException{
		return getProjLoad()*(1+getDRF());
	}


	/*
	 *  (non-Javadoc)
	 * @see com.sce.mdi.object.LoadServingEntityYear#getCProjLoad()
	 */
	public double getCriteriaProjLoadHC()throws SQLException{
		return getProjLoadHC()*(1+getDRF());
	}

	/*
	 *  (non-Javadoc)
	 * @see com.sce.mdi.object.LoadServingEntityYear#getCProjLoad()
	 */
	public double getCriteriaProjLoadLC()throws SQLException{
		return getProjLoadLC()*(1+getDRF()); 
	}

	/*
	 *  (non-Javadoc)
	 * @see com.sce.mdi.object.LoadServingEntityYear#getReserve()
	 */
	public double getCriteriaReserve()throws SQLException{
		return getPLLBizLogic()-getCriteriaProjLoad();
	}
	
	/*
	 *  (non-Javadoc)
	 * @see com.sce.mdi.object.LoadServingEntityYear#getReserve()
	 */
	public double getCriteriaReserveHC()throws SQLException{
		return getPLLBizLogic()-getCriteriaProjLoadHC();
	}

	/*
	 *  (non-Javadoc)
	 * @see com.sce.mdi.object.LoadServingEntityYear#getReserve()
	 */
	public double getCriteriaReserveLC()throws SQLException{
		return getPLLBizLogic()-getCriteriaProjLoadLC();
	}
	
	
	
	/**
	 * Gets the C utilization.
	 * 
	 * @return the utilization
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getCUtilization() throws SQLException {
		return getPLLBizLogic()!=0?getCriteriaProjLoad()/getPLLBizLogic()*100:0;
	}

	/**
	 * Gets the C utilization HC.
	 * 
	 * @return the utilization
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getCUtilizationHC() throws SQLException {
		return getPLLBizLogic()!=0?getCriteriaProjLoadHC()/getPLLBizLogic()*100:0;
	}

	/**
	 * Gets the C utilization LC.
	 * 
	 * @return the utilization
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getCUtilizationLC() throws SQLException {
		return getPLLBizLogic()!=0?getCriteriaProjLoadLC()/getPLLBizLogic()*100:0;
	}

	/**
	 * <p>Title: getPeakEff</p>
	 * <p>Peak Effective Temperature for a given year</p>.
	 * 
	 * @return the peak eff
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getPeakEff()throws SQLException{
		double sum=0;
		double avg=0;
		Collection<Weatherstation> wss = getSub().getWeatherStationsByInstance();
		for(Weatherstation ws:wss)
			sum+=ws.getPeakEff(getYear());
		if(wss.size()>0)
			avg=sum/wss.size();
		return avg;
	}

	/**
	 * This function returns the flag id if the
	 * temperature sensitivity is greater than a
	 * specified value.
	 * 
	 * @return -
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getHighTempSensFlag() throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.HIGH_TEMP_SENS_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && !isUseOperDRF() && SubFilter.CORE_IN_SERVICE_SUB.meetsCriteria(getSub(), getSimId())) {
			if(getSens() > flag.getValue())
				return flag.getFlagId();
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * temperature sensitivity is less than a
	 * specified value.
	 * 
	 * @return -
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getLowTempSensFlag() throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.LOW_TEMP_SENS_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && !isUseOperDRF() && SubFilter.CORE_IN_SERVICE_SUB.meetsCriteria(getSub(), getSimId())) {
			if(getSens() < flag.getValue()){
				return flag.getFlagId();
			}
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * temp sensitivity changes throughout the ten
	 * year plan.
	 * 
	 * @return -
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getTempSensYearFlag() throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.TEMP_SENS_YEAR_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && !isUseOperDRF() && SubFilter.CORE_IN_SERVICE_SUB.meetsCriteria(getSub(), getSimId())) {
			if(getYear()>getPlanyear()-1 && Math.abs(getTempSensitivity()/getInstance(getYear()-1).getTempSensitivity()-1) > flag.getValue())
				return flag.getFlagId();
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * temp sensitivity has changed from the previous
	 * plan for this year.
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getTempSensPYFlag() throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.TEMP_SENS_PY_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && !isUseOperDRF() && SubFilter.CORE_IN_SERVICE_SUB.meetsCriteria(getSub(), getSimId())){
			Sub ps = getSub().getPrevInstance();
			if(ps!=null && ps.getYear(getSimId(), getYear())!=null){
				SubYear psy = ps.getYear(getSimId(), getYear());
				if(Math.abs(getTempSensitivity()-psy.getTempSensitivity()) > flag.getValue())
					return flag.getFlagId();
			}
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * DRF > value for a given year.
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getHighDRFFlag() throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.HIGH_DRF_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && SubFilter.ADS_IN_SERVICE_SUB.meetsCriteria(getSub(), getSimId())) {
			if(getDRF()>flag.getValue())
				return flag.getFlagId();
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * DRF < value for a given year.
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getLowDRFFlag() throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.LOW_DRF_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && SubFilter.ADS_IN_SERVICE_SUB.meetsCriteria(getSub(), getSimId())) {
			if(getDRF() < flag.getValue())
				return flag.getFlagId();
		}
		return 0;
	}

	/**
	 * This function returns the flag id if there
	 * is a high growth change from year to year.
	 *
	 * @return - flagId or 0
	 *
	 * @throws SQLException the SQL exception
	 */
	public int getGrowthYearFlag() throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.GROWTH_YR_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()) {
			double prevGrowth=0;
			if(getYear()>getPlanyear()-1){
				prevGrowth=getInstance(getYear()-1).getGrowth();
				//System.out.println("s-y:"+getSubstation()+"-"+year+" p:"+prevGrowth+" c:"+getGrowth()+" c/p:"+Math.abs((getGrowth()/prevGrowth)-1));
				if(prevGrowth==0 && getGrowth()!=0){
					return flag.getFlagId();
				}else if(prevGrowth!=0) {
					if(Math.abs((getGrowth()/prevGrowth)-1) > flag.getValue())
						return flag.getFlagId();
				}	
			}
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * Total Non-Coincident Growth < the Parent Growth for a given year.
	 * 
	 * @return -  flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public abstract int getChildGrowthYearFlag() throws SQLException;


	/**
	 * This function returns the flag id if the
	 * Planned Loading Limit < Nameplate for a given year.
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getPLLFlag() throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.PLL_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()) {
			if(getPLLBizLogic()  <  getNameplate()* flag.getValue())
				return flag.getFlagId();
		}
		return 0;
	}

	/**
	 * 
	 * This function returns the flag id if the
	 * substation has a negative reserve.
	 * 
	 * @return -
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getSubReserveFlag() throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.SUB_RESERVE_FLAG);
		if(getYear() > getPlanyear()-1 + Flag.SUB_ALT_CRITERIA_YEARS)
			flag = Flag.getInstance(getPlanyear(), Flag.SUB_RES_LAST_FIVE_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()){
			if(Calculate.round(getCriteriaReserve()*100,2)+1 < Calculate.round(getPLLBizLogic()* 100 * flag.getValue(),2)){//rounding was 1 sig fig
				//				System.out.println(" RES " +Calculate.round(getCriteriaReserve()*100,1)+" < "+(Calculate.round(getPLLBizLogic()* 100 * flag.getValue(),2)));
				return flag.getFlagId();
			}
		}
		return 0;
	}




	/**
	 * 
	 * This function returns the flag id if the
	 * substation has a negative reserve.
	 * 
	 * @return -
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getSubReserveHCFlag() throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.SUB_RESERVE_FLAG);
		if(getYear() > getPlanyear()-1 + Flag.SUB_ALT_CRITERIA_YEARS)
			flag = Flag.getInstance(getPlanyear(), Flag.SUB_RES_LAST_FIVE_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()){
			if(Calculate.round(getCriteriaReserveHC()*100,2)+1 < Calculate.round(getPLLBizLogic()* 100 * flag.getValue(),2)){//rounding was 1 sig fig
				//	System.out.println(" RES " +Calculate.round(getCriteriaReserve()*100,1)+" < "+(Calculate.round(getPLLBizLogic()* 100 * flag.getValue(),2)));
				return flag.getFlagId();
			}
		}
		return 0;
	}

	/**
	 * 
	 * This function returns the flag id if the
	 * substation has a negative reserve.
	 * 
	 * @return -
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getSubReserveLCFlag() throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.SUB_RESERVE_FLAG);
		if(getYear() > getPlanyear()-1 + Flag.SUB_ALT_CRITERIA_YEARS)
			flag = Flag.getInstance(getPlanyear(), Flag.SUB_RES_LAST_FIVE_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()){
			if(Calculate.round(getCriteriaReserveLC()*100,2)+1 < Calculate.round(getPLLBizLogic()* 100 * flag.getValue(),2)){//rounding was 1 sig fig
				//	System.out.println(" RES " +Calculate.round(getCriteriaReserve()*100,1)+" < "+(Calculate.round(getPLLBizLogic()* 100 * flag.getValue(),2))); 
				return flag.getFlagId();
			}
		}
		return 0;
	}


	/**
	 * This function returns the flag id if the
	 * substation has a Capacity Addition Project in an area with > |&value%| Criteria Reserve.
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getBadProjectFlag() throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.PROJ_BAD_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag() && getYear() > getPlanyear()-1) {
			for(SceProjElemCost spec:getSceProjElemCosts())
				if(spec.isActiveBl(getPlanyear(), getSimId()) && spec.getBadProjectFlag(getPlanyear(),getSimId()) > 0)
					return flag.getFlagId();
		}
		return 0;
	}

	/**
	 * This function returns the flag id if the
	 * Project contains a capacity addition with Impedance less than &value p.u.
	 * 
	 * @return - flagId or 0
	 * 
	 * @throws SQLException the SQL exception
	 */
	public int getZFlag() throws SQLException{
		Flag flag = Flag.getInstance(getPlanyear(), Flag.PROJ_Z_FLAG);
		if(flag!=null && !flag.isDisabled() && flag.isShowFlag()) {
			for(SceProjElemCost spec:getSceProjElemCosts())
				if(spec.isActiveBl(getPlanyear(), getSimId()) && spec.getZFlag(getPlanyear(),getSimId()) > 0)
					return flag.getFlagId();
		}
		return 0;
	}

	/**
	 * Gets the down stream subs.
	 * 
	 * @return ds
	 * 
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<Bbank> getDownStreamSubs()throws SQLException{
		TreeSet<Bbank> dc = getBbanks();
		TreeSet<Bbank> ds = new TreeSet<Bbank>(dc);
		for(Bbank bBank:dc)
			ds.addAll(bBank.getYear(getSimId(),getYear()).getDownStreamSubs());
		return ds;
	}

	/**
	 * Checks for bbanks been read.
	 * 
	 * @return true, if successful
	 */
	public boolean hasBbanksBeenRead(){
		return bbanks != null;
	}

	/**
	 * 
	 * BME Make sure this method is not used for ABank sums that should be core filtered
	 * 
	 * Gets the B banks.
	 * 
	 * @return the B banks
	 * 
	 * @throws SQLException the SQL exception
	 */
	public synchronized TreeSet<Bbank> getBbanks()throws SQLException{
		if(bbanks == null)
			refreshBbanks();
		return bbanks;
	}

	/**
	 * Refresh bbanks.
	 * 
	 * @throws SQLException the SQL exception
	 */
	public void refreshBbanks()throws SQLException{
		if(bbanks == null)
			bbanks = new TreeSet<Bbank>();
		else
			bbanks.clear();
		TreeSet<Bbank> all = getSub().getBbanks(getSimId());
		bbanks.addAll(all);
		for(Bbank b:all)
			if(b.getYear(getSimId(),getYear()).getParentSubId() != getSubId())
				bbanks.remove(b);
	}

	/**
	 * Gets a user filtered treeset containing substations.
	 * 
	 * @param sf the sf
	 * 
	 * @return a TreeSet of <code>Bbank</code> objects.
	 * 
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<Bbank> getBbanks(SubFilter sf)throws SQLException{
		TreeSet<Bbank> filterSet = new TreeSet<Bbank>();
		for(Bbank bb: getBbanks())
			if(sf==null || sf.meetsCriteria(bb, getSimId(), getYear()))
				filterSet.add(bb);
		return filterSet;
	}

	/**
	 * Returns the bypassGen per year in MVA.
	 * 
	 * @return The bypassGen
	 * 
	 * @throws SQLException the SQL exception
	 */
	public abstract double getBypassGen() throws SQLException;

	/**
	 * Returns the Dependable Gen per year in MVA.
	 * 
	 * @return The depGen
	 * 
	 * @throws SQLException the SQL exception
	 */
	public abstract double getDepGen() throws SQLException;



	public double getPLLNoProj(SceProjRev rev) throws SQLException {
		Collection<SceProjElemCost> without = null;
		if(rev != null)
			without = rev.getSceProjElemCosts();
		return getSub().getPLL(getNormalizationDate(),getSimId(),without);
	}
	
	public double getELLNoProj(SceProjRev rev) throws SQLException {
		Collection<SceProjElemCost> without = null;
		if(rev != null)
			without = rev.getSceProjElemCosts();
		return getSub().getELL(getNormalizationDate(),getSimId(),without);
	}
	
	public double getN1NoProj(SceProjRev rev) throws SQLException {
		Collection<SceProjElemCost> without = null;
		if(rev != null)
			without = rev.getSceProjElemCosts();
		return getSub().getN1(getNormalizationDate(),getSimId(),without);
	}



	
	public double getReserveNoProj(SceProjRev rev) throws SQLException{
		return getPLLNoProj(rev)-getCriteriaProjLoad();
	}

	public double getReserveHCNoProj(SceProjRev rev) throws SQLException{
		return getPLLNoProj(rev)-getCriteriaProjLoadHC();
	}

	public double getAvgCktLoadNoProj(Proj proj) throws SQLException{
		return getProjLoad()/getCircuitCountNoProj(proj);
	}

	/**
	 * Reviews all of the circuits that tie to this sub to see how many are over PLL
	 * @param rev
	 * @return
	 * @throws SQLException
	 */
	//XXX test
	public int getAreaCktAboveCriteriaNoProj(SceProjRev rev) throws SQLException{
		int olCkt = getCktAboveCriteriaNoProj(rev);
		
		for(Sub s: getSub().getAreaSubs()){
			if(getSub().isBbank() && s.isBbank()){
				for(Ckt ckt : ((Bbank)getSub()).getTieCktsAtAdjSub((Bbank)s)) {
					if(ckt.getYear(getSimId(),getYear()).getCriteriaProjLoad() > ckt.getYear(getSimId(),getYear()).getPLLBizLogic()){
						olCkt++;
					}
				}		
			}
		}
		return olCkt;
	}
	
	/**
	 * Reviews all of the circuits that tie to this sub to see how many are over PLL
	 * @param rev
	 * @return
	 * @throws SQLException
	 */
	//XXX test
	public int getAreaCktAboveCriteria() throws SQLException{
		int olCkt = getCktsOverPLL();
		
		for(Sub s: getSub().getAreaSubs()){
			if(getSub().isBbank() && s.isBbank()){
				for(Ckt ckt : ((Bbank)getSub()).getTieCktsAtAdjSub((Bbank)s)) {
					if(ckt.getYear(getSimId(),getYear()).getCriteriaProjLoad() > ckt.getYear(getSimId(),getYear()).getPLLBizLogic()){
						olCkt++;
					}
				}		
			}
		}
		return olCkt;
	}
	/**
	 * Reviews all of the circuits that tie to this sub to see how many are over PLL
	 * @param rev
	 * @return
	 * @throws SQLException
	 */
	//XXX test
	public int getAreaCktAboveCriteriaHC() throws SQLException{
		int olCkt = getCktsOverPLL();
		
		for(Sub s: getSub().getAreaSubs()){
			if(getSub().isBbank() && s.isBbank()){
				for(Ckt ckt : ((Bbank)getSub()).getTieCktsAtAdjSub((Bbank)s)) {
					if(ckt.getYear(getSimId(),getYear()).getCriteriaProjLoadHC() > ckt.getYear(getSimId(),getYear()).getPLLBizLogic()){
						olCkt++;
					}
				}		
			}
		}
		return olCkt;
	}
	
	/**
	 * Reviews all of the circuits that tie to this sub to see how many are over PLL in High Case
	 * @param rev
	 * @return
	 * @throws SQLException
	 */
	//XXX test
	public int getAreaCktAboveCriteriaHCNoProj(SceProjRev rev) throws SQLException{
		int olCkt = getCktAboveCriteriaNoProj(rev);
		
		for(Sub s: getSub().getAreaSubs()){
			if(getSub().isBbank() && s.isBbank()){
				for(Ckt ckt : ((Bbank)getSub()).getTieCktsAtAdjSub((Bbank)s)) {
					if(ckt.getYear(getSimId(),getYear()).getCriteriaProjLoadHC() > ckt.getYear(getSimId(),getYear()).getPLLBizLogic()){
						olCkt++;
					}
				}		
			}
		}
		return olCkt;
	}
	
	/**
	 * Reviews all of the circuits that tie to this sub to see how many are over PLL in High Case
	 * @param rev
	 * @return
	 * @throws SQLException
	 */
	//XXX test
	public int getAreaCktAboveTempNoProj(SceProjRev rev) throws SQLException{
		int olCkt = getCktAboveTempNoProj(rev);
		
		for(Sub s: getSub().getAreaSubs()){
			if(getSub().isBbank() && s.isBbank()){
				for(Ckt ckt : ((Bbank)getSub()).getTieCktsAtAdjSub((Bbank)s)) {
					if(ckt.getYear(getSimId(),getYear()).getHottestDuctTemp() >90.0){
						olCkt++;
					}
				}		
			}
		}
		return olCkt;
	}
	
	/**
	 * Reviews all of the circuits that tie to this sub to see how many are over PLL in High Case
	 * @param rev
	 * @return
	 * @throws SQLException
	 */
	//XXX test
	public int getAreaCktAboveTempHCNoProj(SceProjRev rev) throws SQLException{
		int olCkt = getCktAboveTempHCNoProj(rev);
		
		for(Sub s: getSub().getAreaSubs()){
			if(getSub().isBbank() && s.isBbank()){
				for(Ckt ckt : ((Bbank)getSub()).getTieCktsAtAdjSub((Bbank)s)) {
					if(ckt.getYear(getSimId(),getYear()).getHottestDuctTempHC() >90.0){
						olCkt++;
					}
				}		
			}
		}
		return olCkt;
	}
	
	// TODO Test this
	public int getCktAboveTempNoProj(SceProjRev rev) throws SQLException{
		int olCkt = 0;
		for(Ckt ckt : rev.getCktsPre(getPlanyear(), getSimId(), rev.getSceProjElemCosts())) {
			if(ckt.getYear(getSimId(),getYear()).getHottestDuctTemp() >90.0){
				olCkt++;
			}
		}		
		return olCkt;
	}
	
	// TODO Test this
	public int getCktAboveTempHCNoProj(SceProjRev rev) throws SQLException{
		int olCkt = 0;
		for(Ckt ckt : rev.getCktsPre(getPlanyear(), getSimId(), rev.getSceProjElemCosts())) {
			if(ckt.getYear(getSimId(),getYear()).getHottestDuctTempHC() >90.0){
				olCkt++;
			}
		}		
		return olCkt;
	}
	
	public int getCktAboveCriteriaNoProj(SceProjRev rev) throws SQLException{
		int olCkt = 0;
		for(Ckt ckt : rev.getCktsPre(getPlanyear(), getSimId(), rev.getSceProjElemCosts())) {
			if(ckt.getYear(getSimId(),getYear()).getCriteriaProjLoad() > ckt.getYear(getSimId(),getYear()).getPLLBizLogic()){
				olCkt++;
			}
		}		
		return olCkt;
	}
	
	
	
	
	public int getCktAboveCriteriaHCNoProj(SceProjRev rev) throws SQLException{
		int olCkt = 0;
		for(Ckt ckt : rev.getCktsPre(getPlanyear(), getSimId(), rev.getSceProjElemCosts())) {
			if(ckt.getYear(getSimId(),getYear()).getCriteriaProjLoadHC() > ckt.getYear(getSimId(),getYear()).getPLLBizLogic()){
				olCkt++;
			}
		}		
		return olCkt;
	}


	public double getAvgCktLoadNoProj(SceProjRev rev) throws SQLException{
		if(getCircuitCountNoProj(rev) != 0)
			return getProjLoad()/getCircuitCountNoProj(rev);
		return 0;
	}
	
	public double getAvgCktLoadHCNoProj(SceProjRev rev) throws SQLException{
		if(getCircuitCountNoProj(rev) != 0)
			return getProjLoadHC()/getCircuitCountNoProj(rev);
		return 0;
	}

	/**
	 * Gets the parent object of type CoreObject.
	 * 
	 * @return the parent
	 * 
	 * @throws SQLException the SQL exception
	 */
	public abstract CoreObject getParent() throws SQLException;


	public String getStatus()throws SQLException{
		String g = (String)getCachedValue("getStatus");
		if(g==null){
			g="";
			int inYear = getEffYear(getPlanyear(),getSub().getInServiceDate(getSimId()));
			int outYear = getEffYear(getPlanyear(),getSub().getOutServiceDate(getSimId()));
			if(outYear == 0)
				outYear = Integer.MAX_VALUE;
			if(inYear == 0 || outYear <= inYear){
				g= Sub.UNKNOWN_STATUS;
				setCachedValue(g,"getStatus");
				return g;
			}
			if(inYear > getYear()){
				g= Sub.FUTURE;
				setCachedValue(g,"getStatus");
				return g;
			}
			if(outYear < getYear()){
				g= Sub.OUT_OF_SERVICE;
				setCachedValue(g,"getStatus");
				return g;
			}
			g = Sub.IN_SERVICE;
			setCachedValue(g,"getStatus");
		}
		return g;
	}


	public LoadServingEntity getLse() throws SQLException {
		return getSub();
	}

	/*
	 * (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObjectYear#getChildren()
	 */
	public Collection<? extends CoreObject> getChildren() throws SQLException{
		return getChildren(SubFilter.CORE_SUB);
	}


	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObjectYear#getPercUtil()
	 */
	public double getCktUtil() throws SQLException {
		double pl = getProjLoad();
		if(pl == 0) return 0;
		return pl/getPLLBizLogic()*100;					
	}


	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObjectYear#getSubUtil()
	 */
	public double getSubUtil() throws SQLException {
		return getUtilization();
	}

	/*
	 * (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObjectYear#getUtilization()
	 */
	public double getUtilization()throws SQLException{
		double pll = getPLLBizLogic();
		if(pll == 0) return 0;
		return getCriteriaProjLoad()/getPLLBizLogic()*100;		
	}

	/**
	 * Criteria projected Load Average Ckt Loading.
	 * 
	 * @return the criteria avg ckt loading
	 * 
	 * @throws SQLException the SQL exception
	 */
	public double getCriteriaAvgCktLoading()throws SQLException{
		int cc = getCircuitCount();
		if(cc == 0) return 0;
		return getCriteriaProjLoad()/getCircuitCount();
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObjectYear#isDownStreamOf(com.sce.mdi.object.CoreObject)
	 */
	public boolean isDownStreamOf(CoreObject co) throws SQLException{
		if(co==null || getParent()==null || co instanceof District || getParent() == co || getSub() == co)
			return true;
		return getParent().getYear(getSimId(), getYear()).isDownStreamOf(co);
	}


	public abstract Abank getAbank() throws SQLException;

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObjectYear#getAbanks()
	 */
	public Collection<Abank> getAbanks() throws SQLException {
		Vector<Abank> a = new Vector<Abank>();
		a.add(getAbank());
		return a;
	}

	/**
	 * Gets the sub.
	 * 
	 * @return the sub
	 * 
	 * @throws SQLException the SQL exception
	 */
	public Sub getSub() throws SQLException{
		return Sub.getInstance(getPlanyear(), getSubId());
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObjectYear#getProjLoadDiffFromPrev()
	 */
	public double getProjLoadDiffFromPrev() throws SQLException {
		double denom = 0;
		if(getSub().getPrevInstance()!=null)
			denom =  getSub().getPrevInstance().getYear(getSimId(), getYear()).getProjLoad();
		if(denom == 0 )
			return 0;
		return (getProjLoad()-denom)/denom*100.0;
	}

	/* (non-Javadoc)
	 * @see com.sce.mdi.object.CoreObjectYear#getGrowthDiffFromPrev()
	 */
	public double getGrowthDiffFromPrev() throws SQLException {
		double denom = 0;
		if(getSub().getPrevInstance()!=null)
			denom = getSub().getPrevInstance().getYear(getSimId(), getYear()).getGrowth();
		if(denom == 0 )
			return 0;
		return (getGrowth()-denom)/denom*100.0;
	}

	public double getShedReq() throws SQLException{
		double shedReq= 0;
		for(Abank abank: getAbanks())
			shedReq += abank.getYear(getSimId(), getYear()).getShedReq();
		return shedReq;
	}

	public double getRollReq() throws SQLException{
		double rollReq= 0;
		for(Abank abank: getAbanks())
			rollReq += abank.getYear(getSimId(), getYear()).getRollReq();
		return rollReq;
	}

	public double getShedReserve() throws SQLException{
		double shedReserve= 0;
		for(Abank abank: getAbanks())
			shedReserve += abank.getYear(getSimId(), getYear()).getShedReserve();
		return shedReserve;
	}

	public double getRollReserve() throws SQLException{

		double rollReserve= 0;
		for(Abank abank: getAbanks())
			rollReserve += abank.getYear(getSimId(), getYear()).getRollReserve();
		return rollReserve;
	}

	public double getGrowthTotal()throws SQLException{
		Double total = null;//(Double)getCachedValue("getGrowthTotal");
		if(total==null){
			total = 0.0;
			for(int y=getYear(); y>getPlanyear()-1; y--)
				total += getInstance(y).getGrowth();
			//setCachedValue(total,"getGrowthTotal");
		}
		return total;
	}


	public double getGrowthTotalHC()throws SQLException{
		Double total = null;//(Double)getCachedValue("getGrowthTotalHC");
		if(total==null){
			total = 0.0;
			for(int y=getYear(); y>getPlanyear()-1; y--)
				total += getInstance(y).getGrowthHC();
			//setCachedValue(total,"getGrowthTotalHC");
		}
		return total;
	}


	public double getGrowthTotalLC()throws SQLException{
		Double total = null;//(Double)getCachedValue("getGrowthTotalLC");
		if(total==null){
			total = 0.0;
			for(int y=getYear(); y>getPlanyear()-1; y--)
				total += getInstance(y).getGrowthLC();
			//setCachedValue(total,"getGrowthTotalLC");
		}
		return total;
	}

	public abstract double getGrowthNoPRNHC(GrowthType growthType)throws SQLException;
	public abstract double getGrowthNoPRN(GrowthType growthType)throws SQLException;
	public abstract double getGrowthNoPRNLC(GrowthType growthType)throws SQLException;
	public abstract double getPRN()throws SQLException;

	public double getGrowthHC(GrowthType growthType) throws SQLException{
		return getGrowthNoPRNHC(growthType)*getPRN();
	}
	public double getGrowth(GrowthType growthType) throws SQLException{
		return getGrowthNoPRN(growthType)*getPRN();
	}
	public double getGrowthLC(GrowthType growthType) throws SQLException{
		return getGrowthNoPRNLC(growthType)*getPRN();
	}

	public double getGrowthTotalHC(GrowthType growthType) throws SQLException{
		Double total = null;//(Double)getCachedValue("getGrowthTotalHC",growthType);
		if(total==null){
			total = 0.0;
			for(int y=getYear(); y>getPlanyear()-1; y--)
				total += getInstance(y).getGrowthHC(growthType);
			//setCachedValue(total,"getGrowthTotalHC",growthType);
		}
		return total;
	}

	public double getGrowthTotal(GrowthType growthType) throws SQLException{
		Double total = null;//(Double)getCachedValue("getGrowthTotal",growthType);
		if(total==null){
			total = 0.0;
			for(int y=getYear(); y>getPlanyear()-1; y--)
				total += getInstance(y).getGrowth(growthType);
			//setCachedValue(total,"getGrowthTotal",growthType);
		}
		return total;
	}

	public double getGrowthTotalLC(GrowthType growthType) throws SQLException{
		Double total = null;//(Double)getCachedValue("getGrowthTotalLC",growthType);
		if(total==null){
			total = 0.0;
			for(int y=getYear(); y>getPlanyear()-1; y--)
				total += getInstance(y).getGrowthLC(growthType);
			//setCachedValue(total,"getGrowthTotalLC",growthType);
		}
		return total;
	}

	//	//FIXME
	//	public double getGrowthTotalHC(GrowthType growthType) throws SQLException{
	//		return AgSubGrowth.getInstance(getPlanyear(), getSimId(), getSubId(), getYear()).getGrowthTotalHC(growthType);
	//	}
	//	//FIXME
	//	public double getGrowthTotal(GrowthType growthType) throws SQLException{
	//		return AgSubGrowth.getInstance(getPlanyear(), getSimId(), getSubId(), getYear()).getGrowthTotal(growthType);
	//	}
	//	//FIXME
	//	public double getGrowthTotalLC(GrowthType growthType) throws SQLException{
	//		return AgSubGrowth.getInstance(getPlanyear(), getSimId(), getSubId(), getYear()).getGrowthTotalLC(growthType);
	//	}
	//	
	//	public double getGrowthHC(GrowthType growthType) throws SQLException{
	//		return AgSubGrowth.getInstance(getPlanyear(), getSimId(), getSubId(), getYear()).getGrowthHC(growthType);
	//	}
	//	
	//	public double getGrowth(GrowthType growthType) throws SQLException{
	//		return AgSubGrowth.getInstance(getPlanyear(), getSimId(), getSubId(), getYear()).getGrowth(growthType);
	//	}
	//	
	//	public double getGrowthLC(GrowthType growthType) throws SQLException{
	//		return AgSubGrowth.getInstance(getPlanyear(), getSimId(), getSubId(), getYear()).getGrowthLC(growthType);
	//	}

	public double getABankGrowthTotal()throws SQLException{
		Double cache = null;//(Double)getCachedValue("getABankGrowthTotal");
		if(cache==null){
			cache = 0.0;
			for(int y=getYear(); y>getPlanyear()-1; y--)
				cache += getInstance(y).getABankGrowth();
			//setCachedValue(cache,"getABankGrowthTotal");
		}
		return cache;
	}

	public int getTotalProjPriorCostByCostYear(Collection<Program> progs, int statuses)throws SQLException{
		int sum=0;
		for(SceProjRev p:getProjectsWithPCosts(progs, statuses))
			sum += p.getPriorCost(CostStage.Type.Proposed);
		return sum;
	}
	public int getTotalProjCostByCostYear(Collection<Program> progs, int statuses)throws SQLException{
		int sum=0;
		for(SceProjRev proj:getProjectsWithPCosts(progs,statuses))
			sum += proj.getTotalCost(CostStage.Type.Proposed);
		return sum;
	}
	public int getTotalProjCostByCostYear(int year, Collection<Program> progs, int statuses)throws SQLException{
		int sum=0;
		for(SceProjRev proj:getProjectsWithPCosts(progs,statuses))
			sum += proj.getTotalCost(CostStage.Type.Proposed,year);
		return sum;
	}

	/**
	 * Method returns all of the SPECs for this Calendar Year (Jan to Dec)
	 * @return TreeSet<SceProjElemCost>
	 * @throws SQLException
	 */
	
	//XXX 
/*	public TreeSet<SceProjElemCost> getSceProjElemCostsByCalYear() throws SQLException{
		TreeSet<SceProjElemCost> specs = new TreeSet<SceProjElemCost>();
		for(SceProjElemCost spec:getSub().getSceProjElemCosts())
			if(spec.getCostStage().getCostType()==CostStage.Type.Proposed.ordinal() && spec.getCalendarYear() == getYear() && spec.isCurRev(getPlanyear(),getSimId()))
				specs.add(spec);
		return specs;
	}*/
	
	public TreeSet<SceProjElemCost> getSceProjElemCosts() throws SQLException{
		return getSceProjElemCosts(SceProjRev.YearType.PLAN_YEAR);
	}

	public TreeSet<SceProjElemCost> getSceProjElemCosts(SceProjRev.YearType yearType) throws SQLException{
		TreeSet<SceProjElemCost> specs = new TreeSet<SceProjElemCost>();

		switch(yearType){
			case PLAN_YEAR:
				for(SceProjElemCost spec:getSub().getSceProjElemCosts())
					if(spec.getCostStage().getCostType()==CostStage.Type.Proposed.ordinal() && spec.isCurRev(getPlanyear(),getSimId()) &&spec.getPeakYear(getPlanyear()) == getYear())
						specs.add(spec);
				break;
			case CALENDAR_YEAR:
				for(SceProjElemCost spec:getSub().getSceProjElemCosts())
					if(spec.getCostStage().getCostType()==CostStage.Type.Proposed.ordinal() && spec.isCurRev(getPlanyear(),getSimId()) && spec.getCalendarYear() == getYear())
						specs.add(spec);
				break;
			case FISCAL_YEAR:
				for(SceProjElemCost spec:getSub().getSceProjElemCosts())
					if(spec.getCostStage().getCostType()==CostStage.Type.Proposed.ordinal() && spec.isCurRev(getPlanyear(),getSimId()) && spec.getFiscalYear() == getYear())
						specs.add(spec);
				break;
		}
		return specs;
	}

	public int getStationKvar() throws SQLException{
		int kVar=0;
		for(SubVar sv:getSub().getSubVarsLowSide(getNormalizationDate(), getSimId()))
			if(!sv.isDisabled())
				kVar += sv.getKvar();
		return kVar;
	}
	public int getKVarHighSide() throws SQLException{
		int kVar=0;
		for(SubVar sv:getSub().getSubVarsHighSide(getNormalizationDate(), getSimId()))
			if(!sv.isDisabled())
				kVar += sv.getKvar();
		return kVar;
	}

	public abstract SubYear copy()throws SQLException;

	/**
	 * All Programs
	 * @return double Capacity Addition in MVA
	 * @throws SQLException
	 */
	public double getCapAdd() throws SQLException {
		return getCapAdd((TreeSet<Program>)null);
	}
	/*
	 * (non-Javadoc)
	 * @see com.sce.esp.object.CoreObjectYear#getCapAdd(java.util.TreeSet)
	 */
	public double getCapAdd(Collection<Program> p) throws SQLException {
		return getCapAdd(p,SceProjRev.YearType.PLAN_YEAR);
	}
	/**
	 * 
	 * @param Program p
	 * @param isPeakYear PeakYear or CalendarYear
	 * @return double Capacity Additions
	 * @throws SQLException
	 */
	public double getCapAdd(Collection<Program> p, SceProjRev.YearType yearType) throws SQLException {
		double capAdd=0;
		for(SceProjElemCost spec:getSceProjElemCosts(yearType))
			if(spec.isActiveBl(getPlanyear(),getSimId()) && (p == null || p.contains(spec.getSceProjRev().getProgram())))
				capAdd+=spec.getNameplateDelta(getPlanyear(), getSimId());
		return capAdd;
	}

	public double getAppCostTotal(Collection<Program> p, SceElem e) throws SQLException {
		double tot=0;
		for(CostStage cs:CostStage.getCostStages(CostStage.Type.Approved))
			tot += getCostTotal(p,e,cs);
		return tot;
	}

	public double getPropCostTotal(Collection<Program> p, SceElem e) throws SQLException {
		return getPropCostTotal(p,e,-1);
	}
	public double getCostTotal(Collection<Program> p, SceElem e, CostStage stage)throws SQLException {
		double sum=0;
		for(SceProjElemCost spec:getSub().getSceProjElemCosts())
			if(spec.getCostStage() == stage && spec.isActiveBl(getPlanyear(), getSimId()) && (p == null || p.contains(spec.getSceProjRev().getProgram())) && (e == null || spec.getSceElem() == e))
				sum += spec.getCost(getYear());
		return sum;
	}


	/*
	 * (non-Javadoc)
	 * @see com.sce.esp.object.CoreObjectYear#getProjCount(java.util.TreeSet)
	 */
	public int getProjCount(Collection<Program> p) throws SQLException {
		return getProjCount(p, SceProjRev.YearType.PLAN_YEAR);
	}

	/**
	 * 
	 * @param Program p
	 * @param isPeakYear: PeakYear or Cal Year
	 * @return int Project Count
	 * @throws SQLException
	 */
	public int getProjCount(Collection<Program> p, SceProjRev.YearType yearType) throws SQLException {
		TreeSet<SceProj> projs = new TreeSet<SceProj>();
		for(SceProjElemCost spec: getSceProjElemCosts(yearType))
			if(p == null || p.contains(spec.getSceProjRev().getProgram()))
				projs.add(spec.getSceProjRev().getSceProj());
		return projs.size();
	}

	/*
	 * (non-Javadoc)
	 * @see com.sce.esp.object.CoreObjectYear#getVarAdd(java.util.TreeSet)
	 */
	public double getVarAdd(Collection<Program> p) throws SQLException {
		return getVarAdd(p, SceProjRev.YearType.PLAN_YEAR);
	}

	/**
	 * 
	 * @param Program p
	 * @param isPeakYear: PeakYear or Cal Year
	 * @return double VAR addition in MVAR
	 * @throws SQLException
	 */
	public double getVarAdd(Collection<Program> p, SceProjRev.YearType yearType) throws SQLException {
		double sum=0;
		for(SceProjElemCost spec: getSceProjElemCosts(yearType))
			if(spec.isActiveBl(getPlanyear(),getSimId()) && (p == null || p.contains(spec.getSceProjRev().getProgram())))
				sum+=spec.getKvarLowSideAdd(getPlanyear())/1000.0;
		return sum;
	}

	public double getAppCostTotal(Collection<Program> progs, SceElem e,int projStatuses) throws SQLException {
		double sum=0;
		for(SceProjElemCost spec:getSub().getSceProjElemCosts())
			if(spec.getCostStage().getCostType()==CostStage.Type.Approved.ordinal() && spec.isActiveBl(getPlanyear(), getSimId()) && spec.isActiveBl(getPlanyear(), getSimId()) && (spec.getSceProjRev().getProjectStatus() & projStatuses) > 0 && (progs == null || progs.contains(spec.getSceProjRev().getProgram())))
				if(e==null || spec.getSceElem()==e)
					sum+=spec.getCost(getYear());
		return sum;
	}
	public double getPropCostTotal(Collection<Program> p, SceElem e,int projStatuses) throws SQLException {
		double sum=0;
		for(SceProjElemCost spec:getSub().getSceProjElemCosts())
			if(spec.getCostStage().getCostType()==CostStage.Type.Proposed.ordinal() && spec.isActiveBl(getPlanyear(), getSimId()) && spec.isActiveBl(getPlanyear(), getSimId()) && (spec.getSceProjRev().getProjectStatus() & projStatuses) > 0 && (p == null || p.contains(spec.getSceProjRev().getProgram())))
				if(e==null || spec.getSceElem()==e)
					sum+=spec.getCost(getYear());
		return sum;
	}
	public Collection<SceProjElemCost> getSceProjElemCosts(Collection<Program> p, int projStatuses) throws SQLException {
		TreeSet<SceProjElemCost> costs = new TreeSet<SceProjElemCost>();
		for(SceProjElemCost spec:getSub().getSceProjElemCosts())
			if(spec.getCostStage().getCostType()==CostStage.Type.Proposed.ordinal()
				&& (spec.getPeakYear(getPlanyear()) == getYear())
				&& spec.isActiveBl(getPlanyear(), getSimId()) 
				&& (spec.getSceProjRev().getProjectStatus() & projStatuses) > 0 
				&& (p == null || p.contains(spec.getSceProjRev().getProgram())))
				costs.add(spec);
		return costs;
	}
	public Collection<SceProjRev> getSceProjRevs(Collection<Program> progs,int projStatuses) throws SQLException {
		TreeSet<SceProjRev> revs = new TreeSet<SceProjRev>();
		for(SceProjElemCost spec:getSceProjElemCosts(progs,projStatuses))
			revs.add(spec.getSceProjRev());
		return revs;
	}

	/**
	 * Method to return all of the cities served by the ABank of this sub
	 * @author stonerbj 
	 * @return TreeSet <String> of cities
	 * @throws SQLException
	 */
	public TreeSet<String> getAbankCities() throws SQLException {
		TreeSet<String> cities = new TreeSet<String>(); 
		if(getAbank()!=null){
			for(Bbank b : getAbank().getDownStreamSubs(getSimId())){
				if(b.getCity()!=null)
					cities.add(b.getCity());
			}
		}
		return cities;
	}

	public abstract SubYear getPrevInstance() throws SQLException;
	
	/**
	 * Returns an Area Reserve Risk Analysis object.
	 * @return <code>SubRisk</code> 
	 * @throws SQLException
	 */
	public abstract SubRisk getSubRisk() throws SQLException;
}