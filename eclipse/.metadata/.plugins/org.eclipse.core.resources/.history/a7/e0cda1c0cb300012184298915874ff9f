/*
 * Copyright (c) 2002-2010 ESP Suite. All Rights Reserved.
 *
 *     
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Authors: Technology Integration Group, SCE
 * Developers: Eddie Mayfield, Frank Gonzales, Augustin Muniz,
 * Kate Suwan, Hiro Kushida, Andrew McNaughton, Brian Stonerock,
 * Russell Ragsdale, Patrick Ridge, Everett Aragon.
 * 
 */
package com.sce.esp.component;

import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Toolkit;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.sql.SQLException;
import java.text.DateFormat;
import java.text.Format;
import java.text.NumberFormat;

import javax.swing.JFormattedTextField;
import javax.swing.JOptionPane;
import javax.swing.text.DateFormatter;
import javax.swing.text.DefaultFormatter;
import javax.swing.text.DefaultFormatterFactory;
import javax.swing.text.InternationalFormatter;
import javax.swing.text.NumberFormatter;

import com.sce.esp.dialog.ESPDialog;
import com.sce.esp.security.TopFlight;
import com.sce.esp.util.Calculate;
import com.sce.esp.util.FormatText;

public abstract class DynamicTextField extends JFormattedTextField
		implements
			FocusListener,
			KeyListener {
	/**
	 * 
	 */
	private static final long serialVersionUID = -4290687480596057119L;
	private Object obj;
	private Object setObject;
	private Object editingO;
	private int userRole;
	protected boolean isEditing;
	private Component c;
	private Format format;
	private int limit;

	public DynamicTextField(Component c, Object obj, Format format,
			int userRole, int limit) {
		super();

		DefaultFormatter formatter = new DefaultFormatter();
		if (format instanceof DateFormat)
			formatter = new DateFormatter((DateFormat) format);
		if (format instanceof NumberFormat)
			formatter = new NumberFormatter((NumberFormat) format);
		if (format instanceof Format)
			formatter = new InternationalFormatter((Format) format);
		formatter.setOverwriteMode(false);
		setFormatterFactory(new DefaultFormatterFactory(formatter));

		this.setDisabledTextColor(Color.BLACK);
		this.format = format;
		this.c = c;
		this.obj = obj;
		this.userRole = userRole;
		addFocusListener(this);
		this.limit = limit;
		addKeyListener(this);

	}
	public Object getObject() {
		return obj;
	}

	public Component getComponent() {
		return c;
	}

	public void paintComponent(Graphics g) {
		Object o = getObject();
		try {
			Object value = null;
			if (o != null)
				value = getObjectValue();
			if (setObject != o || !hasFocus() && !isEditing && o != null
					&& !Calculate.isSame(value, getValue())) {
				if (Calculate.isNull(value) && format != null
						&& format != FormatText.CURRENCY
						&& format != FormatText.NUMBER)
					setValue("");
				else {
					setValue(value);
				}
				setObject = o;
			}
			if (shouldBeEnabled() != isEnabled())
				setEnabled(shouldBeEnabled());
		} catch (Exception e) {
			e.printStackTrace();
		}
		super.paintComponent(g);
	}

	public abstract Object getObjectValue() throws SQLException;

	public boolean shouldBeEnabled() throws SQLException {
		return getObject() != null && hasPermission();
	}
	public boolean hasPermission() throws SQLException {
		return TopFlight.getInstance().hasAccessRight(userRole);
	}
	public void focusGained(FocusEvent fe) {
		if (fe.getOppositeComponent() != null)
			editingO = getObject();
	}
	public void focusLost(FocusEvent fe) {
		if (!isEditable() || setObject != editingO)
			return;
		try {
			Class<? extends Object> c = null;
			if (getObjectValue() != null)
				c = getObjectValue().getClass();
			String value = getText();
			if (c == int.class || c == double.class || c == Integer.class
					|| c == Double.class) {
				value = value.replaceAll("\\$|,", "");
				if (value.length() == 0)
					value = "0";
			}
			updateObject(value);
		} catch (Exception e) {
			e.printStackTrace();
			ESPDialog.showMessageDialog(this, e.getMessage(), "Error",
					JOptionPane.ERROR_MESSAGE);
		}
		if (c != null)
			c.repaint();
	}
	public abstract void updateObject(String text) throws SQLException;

	public Object getEditingObject() {
		return editingO;
	}
	public void keyReleased(KeyEvent e) {
		if (getText().length() > limit) {
			setText(getText().substring(0, limit));
			Toolkit.getDefaultToolkit().beep();
		}
	}
	public void keyTyped(KeyEvent e) {
	}
	public void keyPressed(KeyEvent e) {
	}
}
