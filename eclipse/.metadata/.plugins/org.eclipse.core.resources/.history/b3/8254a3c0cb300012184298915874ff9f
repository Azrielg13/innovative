/*
 * Copyright (c) 2002-2010 ESP Suite. All Rights Reserved.
 *
 *     
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Authors: Technology Integration Group, SCE
 * Developers: Eddie Mayfield, Frank Gonzales, Augustin Muniz,
 * Kate Suwan, Hiro Kushida, Andrew McNaughton, Brian Stonerock,
 * Russell Ragsdale, Patrick Ridge, Everett Aragon.
 * 
 */
package com.sce.esp.component;

import java.awt.Color;
import java.awt.Font;
import java.awt.Rectangle;

import javax.swing.Icon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.event.TableModelEvent;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableModel;

import com.jidesoft.grid.SortableTable;
import com.jidesoft.grid.TableModelWrapperUtils;
import com.jidesoft.grid.TreeTableModel;
import com.jidesoft.swing.StyleRange;
import com.sce.esp.form.ESPForm;
import com.sce.esp.security.TopFlight;
import com.sce.esp.util.ESPRow.ESPCurrency;
import com.sce.esp.util.ESPRow.ESPPercent;
import com.sce.esp.util.ESPDate;
import com.sce.esp.util.ESPMonth;
import com.sce.esp.util.StringNoEdit;


/**
 * TODO Define Abstract ROW class
 * The Class MDISortableTable.
 * 
 * @author Distribution Staff Engineering
 * @version 2.0
 */
public class ESPSortableTable extends SortableTable implements ESPTable{	
	

	/**
	 * 
	 */
	private static final long serialVersionUID = -7097350522162661639L;

	/** The tsp. */
	private ESPTableScrollPane tsp;
	
	private int userLevel;

	private int tableType;
	

	/**
	 * The Constructor.
	 * 
	 * @param model the model
	 * @param tsp the tsp
	 * @param tableType the table type
	 */
	public ESPSortableTable(TableModel model,ESPTableScrollPane tsp,int tableType,int userLevel){
		setModel(model);
		this.tsp=tsp;
		this.tableType = tableType;
		this.userLevel=userLevel;
		
		setCellEditorManagerEnabled(false);
		setCellRendererManagerEnabled(false);
		setDefaultCellRenderer(ESPForm.cr);
		
        setDefaultEditor(JButton.class,new ESPCellEditor(1));
    	setDefaultEditor(JComponent.class,new ESPCellEditor(1));
    	setDefaultEditor(String.class,new ESPCellEditor(2));
    	setDefaultEditor(StringNoEdit.class,new ESPCellEditor(1));
    	setDefaultEditor(ESPDate.class,new ESPCellEditor(2));
    	setDefaultEditor(ESPMonth.class,new ESPCellEditor(2));
    	setDefaultEditor(ESPCurrency.class,new ESPCellEditor(1));
    	setDefaultEditor(ESPPercent.class,new ESPCellEditor(1));
    	putClientProperty("terminateEditOnFocusLost" , Boolean.TRUE);
	}
	
	public int getTableType(){
		return tableType;
	}

	/**
	 * Sets the model.
	 * 
	 * @param model the model
	 */
	public void setModel(TableModel model){
		super.setModel(model);
	}
	
	public void setValueAt(Object value, int row, int col){
		if(getColumnClass(col)==Number.class || getColumnClass(col).getSuperclass()==Number.class){
			if(value==null) 
				value=0;			
			double pvalue = 0; 
			if(getValueAt(row,col)!=null)
				pvalue = Double.parseDouble(getValueAt(row,col).toString()); 			
			if(value.equals(pvalue))
				return;
		}		
		else if(value == getValueAt(row,col) || (value != null && getValueAt(row,col) != null && value.equals(getValueAt(row,col)))) return;
		
		super.setValueAt(value,row,col);
	}
	
	/**
	 * Gets the wrapped row at.
	 * 
	 * @param row the row
	 * 
	 * @return the wrapped row at
	 */
	public int getWrappedRowAt(int row) {
		return TableModelWrapperUtils.getActualRowAt(getModel(), row);
	}

	/**
	 * Gets the cell renderer.
	 * 
	 * @param col the col
	 * @param row the row
	 * 
	 * @return the cell renderer
	 */
	public TableCellRenderer getCellRenderer(int row, int col){
		return ESPForm.cr;
	}
	
	/**
	 * Gets the column at.
	 * 
	 * @param col the col
	 * 
	 * @return the column at
	 */
    public int getColumnAt(int col){
        String name = getColumnName(col);
        TreeTableModel model = getTreeTableModel();
        for(int x=0; x<model.getColumnCount(); x++)
            if(name.equals(model.getColumnName(x)))
                return x;
        return 0;
    }
    
    /**
     * Gets the tree table model.
     * 
     * @return the tree table model
     */
	protected TreeTableModel getTreeTableModel() {
		return (TreeTableModel)TableModelWrapperUtils.getActualTableModel(getModel(), TreeTableModel.class);
	}
	
	/**
	 * Gets the font.
	 * 
	 * @param col the col
	 * @param row the row
	 * 
	 * @return the font
	 */
	public Font getFont(int row, int col){
		try {

			Font font = ((ESPExpandableRow)getTreeTableModel().getRowAt(getWrappedRowAt(row))).getFont(getColumnAt(col));
			if(font != null)
				return font;
			
		}catch(ClassCastException e) {
			e.printStackTrace();
		}
		return getFont();
	}
	
	/**
	 * Gets the foreground.
	 * 
	 * @param col the col
	 * @param row the row
	 * 
	 * @return the foreground
	 */
	public Color getForeground(int row, int col){
		try {

			Color color = ((ESPExpandableRow)getTreeTableModel().getRowAt(getWrappedRowAt(row))).getForeground(getColumnAt(col));
			if(color != null)
				return color;
			
		}catch(ClassCastException e) {
			e.printStackTrace();
		}
		return getForeground();
	}
	
	/**
	 * Gets the background.
	 * 
	 * @param col the col
	 * @param row the row
	 * 
	 * @return the background
	 */
	public Color getBackground(int row, int col){
		try {

			Color color = ((ESPExpandableRow)getTreeTableModel().getRowAt(getWrappedRowAt(row))).getBackground(getColumnAt(col));
			if(color != null)
				return color;
			
		}catch(ClassCastException e) {
			e.printStackTrace();
		}
		return getBackground();
	}
	
	/*
	 * (non-Javadoc)
	 * @see com.sce.mdi.component.MDITable#getIcon(int, int)
	 */
	public Icon getIcon(int row, int col){
		int aRow = getWrappedRowAt(row);
		int aCol = getColumnAt(col);
			try {
				return ((ESPExpandableRow)getTreeTableModel().getRowAt(aRow)).getIcon(aCol);
			}catch(ClassCastException e) {
				e.printStackTrace();
			}
		return null;
	}
	
	/*
	 * (non-Javadoc)
	 * @see com.sce.mdi.component.MDITable#getToolTip(int, int)
	 */
	public String getToolTip(int row, int col){
		int aRow = getWrappedRowAt(row);
		int aCol = getColumnAt(col);
		try {
			return ((ESPExpandableRow)getTreeTableModel().getRowAt(aRow)).getToolTip(aCol);
		}catch(ClassCastException e) {
			e.printStackTrace();
		}
		return null;
	}
	
	/**
	 * Gets the style.
	 * 
	 * @param col the col
	 * @param row the row
	 * 
	 * @return the style
	 */
	public StyleRange getStyle(int row, int col){
		try {
			if(this.getTreeTableModel().getRowAt(getWrappedRowAt(row)) instanceof ESPExpandableRow){
				StyleRange sr = ((ESPExpandableRow)getTreeTableModel().getRowAt(getWrappedRowAt(row))).getStyle(getColumnAt(col));
				if(sr != null)
					return sr;
			}
		}catch(ClassCastException e) {
			e.printStackTrace();
		}
		return null;
	}

	/**
	 * Gets the title.
	 * 
	 * @return the title
	 */
	public String getTitle() {
		return null;
	}

	/**
	 * Sets the title.
	 */
	public void setTitle() {
	}

	public ESPTableScrollPane getSPITableScrollPane() {
		return tsp;
	}
	
	/**
	 * Gets the MDI table scroll pane.
	 * 
	 * @return the MDI table scroll pane
	 */
	public ESPTableScrollPane getTableScrollPane() {
		return tsp;
	}
	
	public boolean isCellEditable(int row, int col){
		if(getColumnClass(col)!=StringNoEdit.class && getColumnClass(col)!=JButton.class){
			try {
				if(!TopFlight.getInstance().hasAccessRight(userLevel))
					return false;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		return super.isCellEditable(row, col);		
	}
//	@Override
	public void invalidateCache() {
	}
	
	public void tableChanged(TableModelEvent e) {
        //if just an update, and not a data or structure changed event or an insert or delete, use the fixed row update handling
        //otherwise call super.tableChanged to let the standard JTable update handling manage it
        if ( e != null &&
            e.getType() == TableModelEvent.UPDATE &&
            e.getFirstRow() != TableModelEvent.HEADER_ROW &&
            e.getLastRow() != Integer.MAX_VALUE) {

            handleRowUpdate(e);
        } else {
            super.tableChanged(e);
        }
    }
	
	/**
     * This borrows most of the logic from the superclass handling of update events, but changes the calculation of the height
     * for the dirty region to provide proper handling for repainting custom height rows
     */
    private void handleRowUpdate(TableModelEvent e) {
        int modelColumn = e.getColumn();
        int start = e.getFirstRow();
        int end = e.getLastRow();

        Rectangle dirtyRegion;
        if (modelColumn == TableModelEvent.ALL_COLUMNS) {
            // 1 or more rows changed
            dirtyRegion = new Rectangle(0, start * getRowHeight(),
                                        getColumnModel().getTotalColumnWidth(), 0);
        }
        else {
            // A cell or column of cells has changed.
            // Unlike the rest of the methods in the JTable, the TableModelEvent
            // uses the coordinate system of the model instead of the view.
            // This is the only place in the JTable where this "reverse mapping"
            // is used.
            int column = convertColumnIndexToView(modelColumn);
            dirtyRegion = getCellRect(start, column, false);
        }

        // Now adjust the height of the dirty region
        dirtyRegion.height = 0;
        for ( int row=start; row <= end; row ++ ) {
            dirtyRegion.height += getRowHeight(row);  //THIS IS CHANGED TO CALCULATE THE DIRTY REGION HEIGHT CORRECTLY
        }
        repaint(dirtyRegion.x, dirtyRegion.y, dirtyRegion.width, dirtyRegion.height);
    }

}
