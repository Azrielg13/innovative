/**
 *           | Master Data Interface Version 2.0 |
 *
 * Copyright (c) 2006, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team.
 * 	                   All rights reserved.
 *
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package com.sce.esp.object.dao;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.DatabaseMetaData;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.Calendar;
import java.util.Hashtable;
import java.util.Vector;

import com.sce.esp.log.EspLogger;
import com.sce.esp.mvc.Observable;
import com.sce.esp.object.model.User;
import com.sce.esp.util.Calculate;
import com.sce.esp.util.FormatText;
import com.sce.esp.util.db.PDBConnection;


/**
 * The MDIObject Object.
 *
 * @author Distribution Staff Engineering
 * @version 2.0
 */
public abstract class DataAccessObject extends Observable implements Comparable<Object>{
	
	
	/** The Constant DEPARTMENT. */
	public final static int DEPARTMENT=0;

	/** The Constant ZONE. */
	public final static int ZONE=1;

	/** The Constant REGION. */
	public final static int REGION=2;

	/** The Constant DISTRICT. */
	public final static int DISTRICT=3;
	
	/** The Constant SYSTEM. */
	public final static int SYSTEM=4;

	/** The Constant ABANK. */
	public final static int ABANK_SUB=5;

	/** The Constant BBANK. */
	public final static int BBANK_SUB=6;

	/** The Constant CIRCUIT. */
	public final static int CIRCUIT=7;

	/** The Constant STL. */
	public final static int STL=8;
	
	/** The Constant WEATHERSTATION. */
	public final static int WEATHERSTATION=9;
	
	/** The new instance. */
	protected boolean newInstance=true;

	protected boolean prevInstanceRead=false;
	
	protected Calendar insertTs; //INSERT_DATE
	protected int insertUserId; //INSERT_USERNAME_ID
	protected Calendar modifiedTs; //MODIFIED_DATE
	protected int modifiedUserId; //MODIFIED_USERNAME_ID
	protected Calendar deletedTs; //DELETE_DATE
	protected int deleteUserId; //DELETE_USERNAME_ID
	
    private static Vector<Class<DataAccessObject>> allClasses;
    private static Vector<Class<DataAccessObject>> allSpiClasses;

    /**
     * Creates a new instance of DBObject.
     */
    public DataAccessObject() {
    }

    public DataAccessObject(DataAccessObject orig){
	}

	/**
     * Checks if is new instance.
     *
     * @return true, if is new instance
     */
    public boolean isNewInstance(){
    	return newInstance;
    }

    /**
     * Compare to.
     *
     * @param o the o
     *
     * @return the int
     */
    public int compareTo(Object o){
    	//If this is the same exact object in memory then just say so
    	if(this == o)
    		return 0;
    	if(o instanceof DataAccessObject)
    		return ((""+toString()).toUpperCase()+getHashKey()).compareTo((""+o.toString()).toUpperCase()+((DataAccessObject)o).getHashKey());
        return 0;
    }

    /**
     * Checks if is auto insertable.
     *
     * @return true, if is auto insertable
     */
    public boolean isAutoInsertable(){
    	return false;
    }

    /**
     * Gets the hashtable.
     *
     * @return the hashtable
     */
    public static Hashtable<String,? extends DataAccessObject> getHashtable(){
    	return null;
    }

    /**
     * Gets the PK set.
     *
     * @return the PK set
     */
    public abstract String[] getPKSet();

    /**
     * Gets the hash key.
     *
     * @return the hash key
     */
    public abstract String getHashKey();

    /**
     * Sets the PS keys.
     *
     * @param startIndex the start index
     * @param ps the ps
     *
     * @throws SQLException the SQL exception
     */
    public abstract void setPSKeys(PreparedStatement ps, int startIndex)throws SQLException;

    /**
     * Gets the DB table.
     *
     * @return the DB table
     */
    public abstract String getDBTable();

    /**
     * Gets the SEQ.
     *
     * @return the SEQ
     */
    public String getSEQ(){
    	return getDBTable().substring(0,getDBTable().indexOf('_'))+"_SEQ";
    }

    /**
     * Gets the insert P ks.
     *
     * @return whereClause
     */
    public String getInsertPKs(){
    	String whereClause = "";
		for(String col:getPKSet()){
			if(whereClause.length() > 0)
				whereClause+=",";
			whereClause += col;
		}
		return whereClause;
    }

    /**
     * Gets the where clause.
     *
     * @return whereClause
     */
    public String getWhereClause(){
    	String whereClause = "WHERE ";
		boolean first=true;
		for(String col:getPKSet()){
			if(!first)
				whereClause += " AND ";
			whereClause += col+"=?";
			first=false;
		}
		return whereClause;
    }

    /**
     * Refresh.
     *
     * @return true, if refresh
     *
     * @throws SQLException the SQL exception
     */
    public boolean refresh()throws SQLException{
    	boolean ret=true;
        PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement("SELECT * FROM "+getDBTable()+" "+getWhereClause());
        setPSKeys(ps,1);
        ResultSet rs = ps.executeQuery();
        if(rs.next())
            refresh(rs);
        else
        	ret=false;
        rs.close();
        ps.close();
        return ret;
    }
    
    /**
	 * Returns the insertDate
	 * @return The insertDate
	 */
	public Calendar getInsertTs(){
		if(isNewInstance() && insertTs==null)
			return Calendar.getInstance();
		return insertTs;
	}

	/**
	 * Sets the insertDate
	 * @param The new insertDate
	 */
	public void setInsertTs(Calendar insertDate)throws SQLException{
		if(isSame(insertDate,getInsertTs())) return;
		setProperty("INSERT_TS",insertDate);
		this.insertTs = insertDate;
	}

	/**
	 * Returns the insertUsernameId
	 * @return The insertUsernameId
	 */
	public int getInsertUserId(){
		if(isNewInstance() && insertUserId==0)
			return User.getActiveUser().getUsernameId();
		return insertUserId;
	}

	/**
	 * Sets the insertUsernameId
	 * @param The new insertUsernameId
	 */
	public void setInsertUserId(int insertUserId)throws SQLException{
		if(isSame(insertUserId,getInsertUserId())) return;
		if(insertUserId == 0)
			setProperty("INSERT_USER_ID",null);
		else
			setProperty("INSERT_USER_ID",insertUserId);
		this.insertUserId = insertUserId;
	}

	/**
	 * Returns the modifiedDate
	 * @return The modifiedDate
	 */
	public Calendar getModifiedTs(){
		return modifiedTs;
	}

	/**
	 * Sets the modifiedDate
	 * @param The new modifiedDate
	 */
	public void setModifiedTs(Calendar modifiedDate)throws SQLException{
		if(isSame(modifiedDate,getModifiedTs())) return;
		setProperty("MODIFIED_TS",modifiedDate);
		this.modifiedTs = modifiedDate;
	}

	/**
	 * Returns the modifiedUsernameId
	 * @return The modifiedUsernameId
	 */
	public int getModifiedUserId(){
		return modifiedUserId;
	}

	/**
	 * Sets the modifiedUsernameId
	 * @param The new modifiedUsernameId
	 */
	public void setModifiedUserId(int modifiedUserId)throws SQLException{
		if(isSame(modifiedUserId,getModifiedUserId())) return;
		if(modifiedUserId == 0)
			setProperty("MODIFIED_USER_ID",null);
		else
			setProperty("MODIFIED_USER_ID",modifiedUserId);
		this.modifiedUserId = modifiedUserId;
	}

	/**
	 * Returns the deleteDate
	 * @return The deleteDate
	 */
	public Calendar getDeletedTs(){
		return deletedTs;
	}

	/**
	 * Sets the deleteDate
	 * @param The new deleteDate
	 */
	public void setDeletedTs(Calendar deleteDate)throws SQLException{
		if(isSame(deleteDate,getDeletedTs())) return;
		setProperty("DELETED_TS",deleteDate);
		this.deletedTs = deleteDate;
	}

	/**
	 * Returns the deleteUsernameId
	 * @return The deleteUsernameId
	 */
	public int getDeletedUserId(){
		return deleteUserId;
	}

	/**
	 * Sets the deleteUsernameId
	 * @param The new deleteUsernameId
	 */
	public void setDeletedUserId(int deleteUserId)throws SQLException{
		if(isSame(deleteUserId,getDeletedUserId())) return;
		if(deleteUserId == 0)
			setProperty("DELETED_USER_ID",null);
		else
			setProperty("DELETED_USER_ID",deleteUserId);
		this.deleteUserId = deleteUserId;
	}


	public void refresh(ResultSet rs) throws SQLException{
		insertTs = getCalendar(rs.getTimestamp("INSERT_TS"));
		insertUserId = rs.getInt("INSERT_USER_ID");
		modifiedTs = getCalendar(rs.getTimestamp("MODIFIED_TS"));
		modifiedUserId = rs.getInt("MODIFIED_USER_ID");
		//If deletedTS is being changed from null to a time, then this item has been deleted
		if(!isNewInstance() && deletedTs == null && rs.getTimestamp("DELETED_TS") != null)
			postDelete();
		deletedTs = getCalendar(rs.getTimestamp("DELETED_TS"));
		deleteUserId = rs.getInt("DELETED_USER_ID");
	}
	public User getInsertUser()throws SQLException{
		return User.getInstance(getInsertUserId());
	}
	public void setInsertUser(User user)throws SQLException{
		if(user==null)
			setInsertUserId(0);
		else
			setInsertUserId(user.getUsernameId());
	}
	public User getModifiedUser() throws SQLException {
		return User.getInstance(getModifiedUserId());
	}
	public void setModifiedUser(User user2)throws SQLException{
		if(user2==null)
			setModifiedUserId(0);
		else
			setModifiedUserId(user2.getUsernameId());
	}
	public User getDeletedUser()throws SQLException{
		return User.getInstance(getDeletedUserId());
	}
	public void setDeletedUser(User user3)throws SQLException{
		if(user3==null)
			setDeletedUserId(0);
		else
			setDeletedUserId(user3.getUsernameId());
	}

	public int setProperty(String col, Object value) throws SQLException{
		if(value instanceof Double && (Double.isInfinite((Double)value) || Double.isNaN((Double)value)))
			throw new SQLException("Can not bind "+value);
		if(isNewInstance())
			return 0;
		String valStr = ""+value;
		if(value != null && value instanceof Calendar)
			valStr = FormatText.USER_DATETIME.format(((Calendar)value).getTime());
		EspLogger.notice(DataAccessObject.class,"DATABASE UPDATE: "+getDBTable()+" "+getHashKey()+" "+col+" "+valStr);
		Calendar mDate = Calendar.getInstance();
		PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement("UPDATE "+getDBTable()+" SET "+col+"=?, MODIFIED_TS=?, MODIFIED_USER_ID=? "+getWhereClause());
		setPSValue(ps,1,value);
		ps.setTimestamp(2,new Timestamp(mDate.getTimeInMillis()));
		ps.setInt(3,User.getActiveUser().getUsernameId());
		setPSKeys(ps,4);
		int c = ps.executeUpdate();
		ps.close();
		if(c==0){
			if(getRealRecord() != this)
				c = simCopy(col,value);
			if(c <= 0){
				if(isAutoInsertable())
					c = insert(col,value);
				else/* Update attempted but record does not exist and not auto insertable*/
					throw new SQLException("Database Entry Not Found");
			}
		}
		modifiedTs = mDate;
		modifiedUserId = User.getActiveUser().getUsernameId();
		
		valueChanged();
		
		return c;
	}

	/**
	 * Insert.
	 *
	 * @param col the col
	 * @param value the value
	 *
	 * @return c
	 *
	 * @throws SQLException the SQL exception
	 */
	public int insert(String col, Object value)throws SQLException{
		int pc = getPKSet().length;
		String insert = "INSERT INTO "+getDBTable()+" ("+col+",INSERT_TS,INSERT_USER_ID,"+getInsertPKs()+") VALUES(?,?,?";
		for(int p=0; p<pc; p++)
			insert += ",?";
		insert += ")";
		EspLogger.notice(DataAccessObject.class,"DATABASE INSERT: "+insert);
		PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement(insert);
		setPSValue(ps,1,value);
		ps.setTimestamp(2,new Timestamp(Calendar.getInstance().getTimeInMillis()));
		ps.setInt(3,User.getActiveUser().getUsernameId());
		setPSKeys(ps,4);
		int c = ps.executeUpdate();
		ps.close();
		if(!isRealRecord())
			refresh();
		refreshParents();		
		return c;
	}

	public boolean delete() throws SQLException{
		Calendar mDate = Calendar.getInstance();
		EspLogger.notice(DataAccessObject.class,"UPDATE "+getDBTable()+" SET DELETED_TS=?, DELETED_USER_ID=? "+getWhereClause());
		PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement("UPDATE "+getDBTable()+" SET DELETED_TS=?, DELETED_USER_ID=? "+getWhereClause());
		ps.setTimestamp(1,new Timestamp(mDate.getTimeInMillis()));
		ps.setInt(2,User.getActiveUser().getUsernameId());
		setPSKeys(ps,3);
		boolean ret = ps.executeUpdate() > 0;
		ps.close();
		postDelete();
		setDeletedTs(mDate);
		return ret;
	}

	public boolean deleteDB() throws SQLException{
		EspLogger.notice(DataAccessObject.class,"DATABASE DELETE: "+getDBTable()+" "+getWhereClause());
		PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement("DELETE FROM "+getDBTable()+" "+getWhereClause());
		setPSKeys(ps,1);
		boolean ret = ps.execute();
		ps.close();
		postDelete();
		return ret;
	}

	public void restore() throws SQLException{
		setDeletedTs(null);
		setDeletedUserId(0);
		refreshParents();
	}
	
	public boolean isDeleted(){
		return getDeletedTs()!=null;
	}

    /**
     * Gets the real record.
     *
     * @return the real record
     */
    public DataAccessObject getRealRecord(){
    	return this;
    }

    /**
     * Checks if is real record.
     *
     * @return true, if is real record
     */
    public boolean isRealRecord(){
    	return getRealRecord() == this;
    }


    /**
     * Pre Insert.
     *
     * @return true, if insert
     *
     * @throws SQLException the SQL exception
     */
    public boolean preSimCopy()throws SQLException{
        return true;
    }

    /**
     * Insert.
     *
     * @return true, if insert
     *
     * @throws SQLException the SQL exception
     */
    public boolean insert()throws SQLException{
        throw new SQLException(getClass()+" does not implement insert");
    }

    /**
     * Sim copy.
     *
     * @param col the col
     * @param value the value
     *
     * @return the int
     *
     * @throws SQLException the SQL exception
     */
    public int simCopy(String col, Object value)throws SQLException{
    	int count=0;
    	DataAccessObject real = getRealRecord();
    	if(real != this && preSimCopy()){
			PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement("SELECT * FROM "+getDBTable()+" "+getWhereClause());
			real.setPSKeys(ps,1);
			ResultSet rs = ps.executeQuery();
			if(rs.next()){
				String columns="";
				String values="";
				ResultSetMetaData rsmd = rs.getMetaData();
				for(int c=1; c<rsmd.getColumnCount()+1; c++){
					if(c > 1){
						columns+=",";
						values+=",";
					}
					columns+=rsmd.getColumnName(c);
					values+="?";
				}
				PreparedStatement ps2 = PDBConnection.getInstance().getConnection().prepareStatement("INSERT INTO "+getDBTable()+"("+columns+") VALUES("+values+")");
				Vector<String> keys = new Vector<String>();
				for(String key:getPKSet())
					keys.add(key);
				for(int c=1; c<rsmd.getColumnCount()+1; c++){
					String colName = rsmd.getColumnName(c); 
					if(keys.contains(colName)){
						try {
							ps2.setObject(c, getClass().getMethod("get"+FormatText.toUpperCamel(colName), (Class[])null).invoke(this, (Object[])null));
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					else if(col != null && col.equalsIgnoreCase(colName)){
						if(value instanceof Calendar)
							ps2.setTimestamp(c,new Timestamp(((Calendar)value).getTimeInMillis()));
						else
							ps2.setObject(c,value,rsmd.getColumnType(c));
					}else
						ps2.setObject(c,rs.getObject(c),rsmd.getColumnType(c));
				}
				count = ps2.executeUpdate();
				ps2.close();
				refresh();
				refreshParents();
			}
			rs.close();
			ps.close();
		}
    	return count;
    }
    
    /**
     * Post delete.
     *
     * @throws SQLException the SQL exception
     */
    public void postDelete()throws SQLException{
    	try {
    		((Hashtable<?,?>)getClass().getMethod("getHashtable", new Class[]{}).invoke(null, (Object[])null)).remove(getHashKey());
    	}catch(Exception e) {
    		e.printStackTrace();
    	}
    	refreshParents();
    }

    /**
     * Refresh parents.
     *
     * @throws SQLException the SQL exception
     */
    public void refreshParents()throws SQLException{
    	valueChanged();
    }
    
    /**
     * Sets the PS value.
     *
     * @param index the index
     * @param value the value
     * @param ps the ps
     *
     * @throws SQLException the SQL exception
     */
    @SuppressWarnings("unused")
	public static void setPSValue(PreparedStatement ps, int index, Object value)throws SQLException{
    	if(value instanceof Integer)
        	ps.setInt(index,(Integer)value);
        else if(value instanceof Double)
        	ps.setDouble(index,(Double)value);
        else if(value instanceof Boolean)
        	ps.setBoolean(index,(Boolean)value);
        else if(value instanceof Calendar){
        	if(value == null)
        		ps.setTimestamp(index,null);
        	else
        		ps.setTimestamp(index,new Timestamp(((Calendar)value).getTimeInMillis()));
        }
        else if(value instanceof Time)
        	ps.setTime(index,(Time)value);
        else if(value instanceof String)
        	ps.setString(index,(String)value);
        else
        	ps.setObject(index,value);
    }
    
    public static boolean isSame(Object o, Object o2){
    	return Calculate.isSame(o, o2);
    }

    /**
     * Returns a string hash code of an object of this type with the
     * specified parameters. The hash code would be used to find the
     * object in a hash table.
     *
     * @param id - id for the object
     * @param planyear - planYear for the object
     * @param k1 the k1
     *
     * @return a string hash code of an object of this type with the specified parameters.
     */
    public static String getHashKey(Object k){
    	if(k instanceof Calendar)
    		return FormatText.formatDate((Calendar)k, FormatText.MYSQL_DATE);
    	return ""+k;
    }

    public static String getHashKey(Object[] keys){
    	String code="";
    	boolean first=true;
    	for(Object k:keys){
    		if(!first)
    			code+="-";
    		else
    			first=false;
    		code += getHashKey(k);
    	}
    	return code;
    }

    public static boolean isNull(Object[] keys){
    	for(Object k:keys)
    		if(Calculate.isNull(k))
    			return true;
    	return false;
    }
    
    public static boolean isNull(Object o){
    	return Calculate.isNull(o);
    }

    /**
     * To string.
     *
     * @return the string
     */
    public String toString(){
    	return getHashKey();
    }

    @SuppressWarnings("unchecked")
	public static Class<DataAccessObject> getClassByDBTable(String table){
    	try{
    		return (Class<DataAccessObject>)Class.forName("com.sce.esp.object.model."+FormatText.toUpperCamel(table.substring(table.indexOf('_')+1)));
    	}catch(Exception e){
    		//e.printStackTrace();
    	}
		return null;
	}

    public static Vector<Class<DataAccessObject>> getAllObjects(String tableSearch) throws SQLException{
    	if(allClasses == null){
    		allClasses = new Vector<Class<DataAccessObject>>();
    		DatabaseMetaData dbmd = PDBConnection.getInstance().getConnection().getMetaData();
    		ResultSet rs = dbmd.getTables(null,PDBConnection.SCHEMA,tableSearch,new String[]{"TABLE"});
    		while(rs.next()){
				String table = rs.getString("TABLE_NAME");
				if(table.charAt(6) == '_' && !table.startsWith("MDI005_") && !table.contains("REPORT")){
					Class<DataAccessObject> c = getClassByDBTable(table);
					if(c !=null)
						allClasses.add(c);
				}
    		}
    		rs.close();
    	}
    	return allClasses;
    }
    
    public static Vector<Class<DataAccessObject>> getAllSpiObjects() throws SQLException{
    	if(allSpiClasses == null){
    		allSpiClasses = new Vector<Class<DataAccessObject>>();
    		DatabaseMetaData dbmd = PDBConnection.getInstance().getConnection().getMetaData();
    		ResultSet rs = dbmd.getTables(null,PDBConnection.SCHEMA,"MDIS%_%",new String[]{"TABLE"});
    		while(rs.next()){
				String table = rs.getString("TABLE_NAME");
				if(table.charAt(6) == '_' && !table.startsWith("MDI005_") && !table.contains("REPORT")){
					Class<DataAccessObject> c = getClassByDBTable(table);
					if(c !=null)
						allSpiClasses.add(c);
				}
    		}
    		rs.close();
    	}
    	return allClasses;
    }
    
    public static Date getDate(Calendar cal) {
		if(cal == null)
			return null;
		return new Date(cal.getTimeInMillis());
	}
    
    public static Calendar getCalendar(Date date){
    	if(date == null)
    		return null;
    	Calendar cal = Calendar.getInstance();
		cal.setTime(date);
    	return cal;
    }
    
    public static Calendar getCalendar(Timestamp ts){
    	if(ts == null)
    		return null;
    	Calendar cal = Calendar.getInstance();
		cal.setTime(ts);
    	return cal;
    }
    
    public static Timestamp getTimestamp(Calendar cal){
    	if(cal == null)
    		return null;
    	return new Timestamp(cal.getTimeInMillis());
    }
    
    public static Object getId(int id){
    	if(id == 0)
    		return null;
    	return id;
    }
    
    public static void sleep(int millis){
    	try {
			Thread.sleep(millis);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
    }
    
    public Vector<String> getDifference(DataAccessObject dao){
    	return new Vector<String>();
    }
    
    public void copyChildrenTo(DataAccessObject cp){
    }
    
    /**
     * Always treat de-serialization as a full-blown constructor, by
     * validating the final state of the de-serialized object.
     */
     private void readObject(ObjectInputStream aInputStream) throws ClassNotFoundException, IOException {
       //always perform the default de-serialization first
       aInputStream.defaultReadObject();

//       //make defensive copy of the mutable Date field
//       fDateOpened = new Date( fDateOpened.getTime() );

       //ensure that object state has not been corrupted or tampered with maliciously
       validateState();
    }

      /**
      * This is the default implementation of writeObject.
      * Customise if necessary.
      */
      private void writeObject(ObjectOutputStream aOutputStream) throws IOException {
        //perform the default serialization for all non-transient, non-static fields
        aOutputStream.defaultWriteObject();
      }
      
      /**
       * Verify that all fields of this object take permissible values; that is,
       * this method defines the class invariant.
       *
       * In this style of implementation, both the entire state of the object
       * and its individual fields can be validated without repeating or
       * duplicating code.
       * Each condition is defined in one place. Checks on the entire
       * object are performed at the end of object construction, and at
       * the end of de-serialization. Checks on individual fields are
       * performed at the start of the corresponding setXXX method.
       * As well, this style replaces the if's and throwing
       * of exceptions at the start of a setXXX, with a simple call to validateXXX.
       * Validation is separated from the regular path of execution,
       * which leads to improved legibility.
       *
       * @throws IllegalArgumentException if any field takes an unpermitted value.
       */
       private void validateState() {
//          validateAccountNumber(fAccountNumber);
//          validateName(fFirstName);
//          validateName(fLastName);
//          validateDateOpened(fDateOpened);
       }

       /**
   	 * De-serialize the Object from the file
   	 */
   	public Object deserialize(String fileName) {

   		Object deserializedObject = null;
   		try {
   			ObjectInputStream in = new ObjectInputStream(new FileInputStream(
   					fileName));
   			deserializedObject = in.readObject();
   			in.close();
   			System.out.println("Object : " + deserializedObject.getClass()
   					+ " de-serialized successfully");
   		} catch (Exception ex) {
   			System.out.println("Error Reading Object to File :"
   					+ ex.getMessage());
   			ex.printStackTrace();

   		}

   		return deserializedObject;

   	}

   	/**
   	 * Serializes the object to a file
   	 * 
   	 * @param objToSerialize
   	 */
   	public void serialize(Object objToSerialize,String fileName) {

   		try {
   			ObjectOutputStream out = new ObjectOutputStream(
   					new FileOutputStream(fileName));
   			out.writeObject(objToSerialize);
   			out.close();
   			System.out.println("Object : " + objToSerialize.getClass()
   					+ " serialized successfully");
   		} catch (Exception ex) {
   			System.out.println("Error Saving Object to File :"+ ex.getMessage());
   			ex.printStackTrace();
   		}
   	}
   	
    
    public void valueChanged() {
    	notify(this);
    	setDirtyBit(true);
    }
    
   // protected boolean isDirtybit=true;


    public void setDirtyBit(boolean dirtyBit) {
		//isDirtybit=dirtyBit;

		
	}

}
