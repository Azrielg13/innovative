/*
 * Copyright (c) 2002-2010 ESP Suite. All Rights Reserved.
 *
 *     
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Authors: Technology Integration Group, SCE
 * Developers: Eddie Mayfield, Frank Gonzales, Augustin Muniz,
 * Kate Suwan, Hiro Kushida, Andrew McNaughton, Brian Stonerock,
 * Russell Ragsdale, Patrick Ridge, Everett Aragon.
 * 
 */
package com.sce.esp.component;

import java.awt.Color;
import java.awt.Rectangle;
import java.io.Serializable;
import java.sql.SQLException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JTable;
import javax.swing.SwingConstants;
import javax.swing.UIManager;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import javax.swing.table.TableCellRenderer;

import com.jidesoft.combobox.TableComboBox;
import com.jidesoft.grid.FilterableTreeTableModel;
import com.jidesoft.swing.StyleRange;
import com.jidesoft.swing.StyledLabel;
import com.sce.esp.object.jpa.PrimaryKey;
import com.sce.esp.object.model.Ckt;
import com.sce.esp.object.model.CoreObject;
import com.sce.esp.object.model.Sub;
import com.sce.esp.util.Calculate;
import com.sce.esp.util.ESPFont;
import com.sce.esp.util.ESPRow.ESPCurrency;
import com.sce.esp.util.ESPRow.ESPPercent;
import com.sce.esp.util.FormatText;
import com.sce.esp.util.IconsFactory;
import com.sce.esp.util.StringNoEdit;

public class ESPTableCellRenderer extends JLabel implements TableCellRenderer, Serializable{

	private static final long serialVersionUID = 1L;

	/** The no focus border. */
	protected static Border noFocusBorder = new EmptyBorder(1, 1, 1, 1);

	/** The Constant NO_EDIT. */
	//UIManager.put("FormattedTextField.inactiveBackground", ColorUIResource(0,38,255));

	public final static Color NO_EDIT = new Color(239, 235, 231);//(Color)UIManager.getDefaults().getColor("FormattedTextField.inactiveBackground");
	
	/** The MOUSE. */
	public static ImageIcon MOUSE = (IconsFactory.getScaledImageIcon(IconsFactory.Frame.MOUSE,12));
        
	private Map<String,CellCache> hash = Collections.synchronizedMap(new HashMap<String,CellCache>());

	public java.awt.Component getTableCellRendererComponent(JTable table, Object value, boolean selected, boolean hasFocus, int row, int col) {
		String key = PrimaryKey.getHashKey(table.hashCode(),row,col);
		CellCache cc = hash.get(key);
		boolean editable = table.isCellEditable(row,col);
		if(cc==null || !cc.equals(value,selected,hasFocus,editable)){
			JComponent renderer;
//			System.out.println("Need Renderer for: "+row+","+col);
//			System.out.println("hash size: "+hash.size());
//			System.out.println("key: "+key);
			Object disVal = value;
			if(disVal == null)
				disVal="";

			if(disVal instanceof JComponent && !(disVal instanceof JComboBox) && !(disVal instanceof TableComboBox) && !(disVal instanceof ESPTreeComboBox)) {
				renderer = (JComponent)disVal;

			} else if(disVal instanceof JComboBox) {
				if(((JComboBox)disVal).getSelectedItem()==null)
					renderer = new StyledLabel("");
				else
					renderer = new StyledLabel(((JComboBox)disVal).getSelectedItem().toString());
			} else if(disVal instanceof TableComboBox) {
				if(((TableComboBox)disVal).getSelectedItem()==null)
					renderer = new StyledLabel("");
				else
					renderer = new StyledLabel(((TableComboBox)disVal).getSelectedItem().toString());

				//MDITreeComboBox
			} else if(disVal instanceof ESPTreeComboBox) {

				if(((ESPTreeComboBox)disVal).getSelectedItem()==null)
					renderer = new StyledLabel("");
				else
					renderer = new StyledLabel(((ESPTreeComboBox)disVal).getSelectedItem().toString());	
			} else if(disVal instanceof ImageIcon) {
				renderer = new StyledLabel((ImageIcon)disVal);
			} else if(table.getColumnClass(col) == Boolean.class){
				if(disVal instanceof Boolean){
					JCheckBox cb = new JCheckBox();
					cb.setHorizontalAlignment(JLabel.CENTER);
					cb.setSelected((disVal != null && ((Boolean)disVal).booleanValue()));
					renderer = cb;
				}
				else
					renderer = new StyledLabel("");
			} else if(table.getColumnClass(col) == StringNoEdit.class || table.getColumnClass(col) == String.class) {
				renderer = new StyledLabel(disVal.toString());
				if(disVal!=null && disVal.toString()!=null && disVal.toString().length()>0)
					renderer.setToolTipText("<html>"+disVal.toString().replaceAll("\n","<br>")+"</html>");
			}else if(disVal instanceof Color) {
				renderer = new JLabel();
			}else if(table.getColumnClass(col) == ESPCurrency.class) {
				if(disVal!=null && disVal.toString()!=null && disVal.toString().length()>0 && !disVal.toString().equals("0.0") && !disVal.toString().equals("0") && !disVal.equals("___")){
					StyledLabel j = new StyledLabel(FormatText.CURRENCY.format(Double.parseDouble(disVal.toString())));
					j.setHorizontalAlignment(JLabel.RIGHT);
					renderer = j;
				}else
					renderer = new StyledLabel("");

			}else if(table.getColumnClass(col) == ESPPercent.class) {
				if(disVal!=null && disVal.toString()!=null && disVal.toString().length()>0 && !disVal.toString().equals("0.0") && !disVal.toString().equals("0") && !disVal.equals("___")){
					StyledLabel j = new StyledLabel(FormatText.PERCENT.format(Double.parseDouble(disVal.toString())));
					j.setHorizontalAlignment(JLabel.RIGHT);
					renderer = j;
				}else
					renderer = new StyledLabel("");

			}else if(disVal instanceof Double){
				renderer = new StyledLabel(""+Calculate.round((Double)disVal,1));
			}
			else {
				renderer = new StyledLabel(disVal.toString());
			}
			renderer.setFont(table.getFont());
			//BME ESP Does not handle filterTablePanel, build table interface
			if(table instanceof ESPTable){
				if(!(table.getModel() instanceof FilterableTreeTableModel)) { //quick fix change later...
					renderer.setToolTipText(((ESPTable)table).getToolTip(row, col));
					renderer.setFont(((ESPTable)table).getFont(row, col));
					renderer.setForeground(((ESPTable)table).getForeground(row, col));
				}
			}


			if(renderer instanceof JLabel && disVal instanceof CoreObject && ((JLabel)renderer).getIcon()==null){
				//((JLabel)renderer).setIcon(MOUSE);//BME MDI re-implement mouse icon???
				try{
					if(disVal instanceof Sub){
						if(((Sub)disVal).getStatus(0).equalsIgnoreCase(Sub.OUT_OF_SERVICE)){
							((JLabel)renderer).setIcon(IconsFactory.getImageIcon("icons/cross-small-circle.png"));
						}
						if(((Sub)disVal).getStatus(0).equalsIgnoreCase(Sub.FUTURE)){
							((JLabel)renderer).setIcon(IconsFactory.getImageIcon("icons/future.png"));
							((JLabel)renderer).setHorizontalTextPosition(SwingConstants.LEFT);
						}
					}else if(disVal instanceof Ckt){	        		
						if(((Ckt)disVal).getStatus().equalsIgnoreCase(Sub.OUT_OF_SERVICE)){
							((JLabel)renderer).setIcon(IconsFactory.getImageIcon("icons/cross-small-circle.png"));
						}
						if(((Ckt)disVal).getStatus().equalsIgnoreCase(Sub.FUTURE)){
							((JLabel)renderer).setIcon(IconsFactory.getImageIcon("icons/future.png"));
							((JLabel)renderer).setHorizontalTextPosition(SwingConstants.LEFT);
						}
					}
				}catch(SQLException e){
					e.printStackTrace();
				}
			}
			
			if(renderer instanceof JButton && table instanceof ESPTable && (((JButton)renderer).getIcon()==null)){
				((JButton)renderer).setIcon(((ESPTable)table).getIcon(row, col));
				((JButton)renderer).setToolTipText(((ESPTable)table).getToolTip(row, col));
			}
			else if(renderer instanceof JLabel || renderer instanceof JCheckBox) {
				if(value instanceof Number || table.getColumnClass(col) == Number.class || table.getColumnClass(col) == Double.class || table.getColumnClass(col) == Integer.class)
					((StyledLabel)renderer).setHorizontalAlignment(JLabel.RIGHT);
				if(table instanceof ESPTable){
					if(!(table.getModel() instanceof FilterableTreeTableModel))
						renderer.setBackground(((ESPTable)table).getBackground(row, col));
					if(renderer instanceof StyledLabel){
						if(!(table.getModel() instanceof FilterableTreeTableModel)) {
							((JLabel)renderer).setIcon(((ESPTable)table).getIcon(row, col));
							if(((ESPTable)table).getStyle(row, col)!=null)
								((StyledLabel)renderer).setStyleRanges(new StyleRange[]{((ESPTable)table).getStyle(row, col)});
						}
					}else if(renderer instanceof JCheckBox){
						((JCheckBox)renderer).setIcon(((ESPTable)table).getIcon(row, col));
					}
				}
				if(selected){
					renderer.setForeground(table.getSelectionForeground());    
					renderer.setBackground(table.getColumnClass(col)!=StringNoEdit.class && !(value instanceof StringNoEdit) && editable?table.getSelectionBackground().brighter():table.getSelectionBackground());
				}
				//total rows
				else if(table.getName() != null && table.getName().equals("total")){
					renderer.setBackground(new Color(0.6f, 0.6f, 0.6f));
					renderer.setFont(ESPFont.BOLD);
				}
				else if(table.getColumnClass(col)!=StringNoEdit.class && !(value instanceof StringNoEdit) && editable){
					if(value instanceof Color)
						renderer.setBackground(((Color)value));
					else
						renderer.setBackground(java.awt.Color.WHITE);
				}
				if(hasFocus){
					renderer.setForeground(editable?table.getForeground():table.getSelectionForeground());
					renderer.setBackground(table.getColumnClass(col)!=StringNoEdit.class && !(value instanceof StringNoEdit) && editable?java.awt.Color.WHITE:table.getSelectionBackground());
					renderer.setBorder(UIManager.getBorder("InternalFrame.border"));
				}else
					renderer.setBorder(noFocusBorder);
			}
			renderer.setOpaque(true);
			
			
			//if(cc==null){
				cc = new CellCache(table,value,selected,hasFocus,row,col);
				hash.put(key, cc);
			//}
			cc.renderer = renderer;
			//System.out.println("Renderer set for: "+row+","+col);
		}
		return cc.renderer;
	}
	
	private class CellCache{
		public int row;
		public int col;
		public JTable table;
		public Object value; 
		public boolean selected;
		public boolean hasFocus;
		public boolean editable;
		public JComponent renderer;
		public CellCache(JTable table, Object value, boolean selected, boolean hasFocus, int row, int col) {
			this.table = table;
			this.value = value;
			this.selected = selected;
			this.hasFocus = hasFocus;
			this.row = row;
			this.col = col;
		}
		public boolean equals(Object value, boolean selected, boolean hasFocus, boolean editable) {
			return this.value==value && this.selected==selected && this.hasFocus==hasFocus && this.editable==editable;
		}
	}

	/**
	 * Overridden for performance reasons. See the <a href="#override">Implementation Note</a> for more
	 * information.
	 */
	@Override
	public void invalidate() {
	}

	/**
	 * Overridden for performance reasons. See the <a href="#override">Implementation Note</a> for more
	 * information.
	 */
	@Override
	public void validate() {
	}

	/**
	 * Overridden for performance reasons. See the <a href="#override">Implementation Note</a> for more
	 * information.
	 */
	@Override
	public void revalidate() {
	}

	/**
	 * Overridden for performance reasons. See the <a href="#override">Implementation Note</a> for more
	 * information.
	 */
	@Override
	public void repaint(long tm, int x, int y, int width, int height) {
	}

	/**
	 * Overridden for performance reasons. See the <a href="#override">Implementation Note</a> for more
	 * information.
	 */
	@Override
	public void repaint(Rectangle r) {
	}

	/**
	 * Overridden for performance reasons. See the <a href="#override">Implementation Note</a> for more
	 * information.
	 *
	 * @since 1.5
	 */
	@Override
	public void repaint() {
	}
}