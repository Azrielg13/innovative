/*
 * Copyright (c) 2002-2010 ESP Suite. All Rights Reserved.
 *
 *     
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Authors: Technology Integration Group, SCE
 * Developers: Eddie Mayfield, Frank Gonzales, Augustin Muniz,
 * Kate Suwan, Hiro Kushida, Andrew McNaughton, Brian Stonerock,
 * Russell Ragsdale, Patrick Ridge, Everett Aragon.
 * 
 */
package com.sce.esp.jortho;

import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class BookUtils {

    /**
     * Read the information of the template placeholder
     * 
     * @return null if nothing find
     */
    static Properties parseRule( String wikiText, String tempalateName, int fromIndex ) {
        int start = findTemplate( wikiText, tempalateName, fromIndex );
        if( start > 0 ) {
            final int length = wikiText.length();
            int braces = 2;
            for( int end = start; end < length; end++ ) {
    
                switch( wikiText.charAt( end ) ) {
                    case '{':
                        braces++;
                        break;
                    case '}':
                        if( --braces == 0 ) {
                            return BookUtils.parseRule( wikiText, start, end - 1 );
                        }
                        break;
                }
            }
        }
        return null;
    }

    /**
     * Read the information of the template placeholder
     */
    static Properties parseRule( String wikiText, int idxStart, int idxEnd ) {
        Properties props = new Properties();
    
        String[] tokens = wikiText.substring( idxStart, idxEnd ).split( "\\|" );
        for( int i = 0; i < tokens.length; i++ ) {
            String value = tokens[i].trim();
            int idx = value.indexOf( '=' );
            if( idx > 0 ) {
                String name = value.substring( 0, idx );
                value = value.substring( idx + 1 );
                props.setProperty( name, value.trim() );
            } else {
                props.setProperty( String.valueOf( i ), value.trim() );
            }
        }
        return props;
    }

    /**
     * Find a template name in the wiki text. the problem are possible whitespaces.
     * 
     * @param wikiText
     * @param tempalateName
     * @return the index after the first | or -1.
     */
    static int findTemplate( String wikiText, String tempalateName, int fromIndex ) {
        //find {{  tempalateName  |
        Pattern pattern = Pattern.compile( "\\{\\{\\s*\\Q" + tempalateName.replace( " ", "\\E\\s+\\Q" ) + "\\E\\s*\\|" );
        Matcher matcher = pattern.matcher( wikiText );
    
        if( matcher.find( fromIndex ) ) {
            return matcher.end();
        }
    
        return -1;
    }
    
    /**
     * Very simple algorithm to calc the diff betwenn 2 words.
     */
    public static int calcDiff(String word1, String word2){
        int diff = 0;
        int j=0;
        for(int i=0; i<word1.length(); i++){
            char ch1 = word1.charAt( i );
            if(word2.length()<=j){
                diff++;
                continue;
            }
            char ch2 = word2.charAt( j++ );
            if(ch1 == ch2){
                continue;
            }
            diff++;
            if(word2.length() > j && word2.charAt( j ) == ch1){
                j++;
                continue;
            }
            if(word1.length() > (i+1) && word1.charAt( i+1 ) == ch2){
                i++;
                continue;
            }
        }
        diff += word2.length()-j;
        return diff;
    }

}
