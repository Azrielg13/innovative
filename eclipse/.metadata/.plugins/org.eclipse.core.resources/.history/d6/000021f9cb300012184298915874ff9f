/**
 *           | Master Data Interface Version 2.0 |
 *
 * Copyright (c) 2006, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team.
 * 	                   All rights reserved.
 *
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package com.sce.esp.object.model;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Calendar;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.Id;
import javax.persistence.NamedNativeQueries;
import javax.persistence.NamedNativeQuery;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;

import com.sce.esp.object.jpa.AutoInsertable;
import com.sce.esp.object.jpa.EntityManagerHelper;
import com.sce.esp.object.jpa.PrimaryKey;
import com.sce.esp.util.Calculate;
import com.sce.esp.util.db.PDBConnection;


/**
 * The Class TempYear.
 *
 * @author Distribution Staff Engineering
 * @version 2.0
 */
@Entity
@AutoInsertable
@Table(schema="MDI",name="MDI_V_TEMP_AVG_YEAR")
@NamedQueries({
	@NamedQuery(name = "findByID", query="SELECT o FROM TempAvgYear o WHERE o.PLANYEAR=?1 AND o.STATION_ID=?2 AND o.RCD_YEAR=?3"),
	@NamedQuery(name = "findAll", query="SELECT o FROM TempAvgYear o"),
	@NamedQuery(name = "findAllActive", query="SELECT o FROM TempAvgYear o WHERE o.DELETED_TS IS NULL"),
})
@NamedNativeQueries({
	@NamedNativeQuery(name = "refresh", query="SELECT * FROM MDI_V_TEMP_AVG_YEAR WHERE PLANYEAR=? AND STATION_ID=? AND RCD_YEAR=?"),
})
public class TempAvgYear extends MDIObject{

    /** The planyear. */
    private int planyear; //PLANYEAR

    /** The station id. */
    private int stationId; //STATION_ID

    /** The rcd year. */
    private int rcdYear; //RCD_YEAR

    /** The eff temp. */
    private double avgTemp; //EFF_TEMP

    /**
     * Gets the instance.
     *
     * @param stationId the station id
     * @param planyear the planyear
     * @param rcdYear the rcd year
     *
     * @return the instance
     *
     * @throws SQLException the SQL exception
     */
    public static TempAvgYear getInstance(int planyear, int stationId, int rcdYear)throws SQLException{
        return getInstance(planyear, stationId, rcdYear, true);
    }

    /**
     * Gets the instance.
     *
     * @param fetch the fetch
     * @param stationId the station id
     * @param planyear the planyear
     * @param rcdYear the rcd year
     *
     * @return the instance
     *
     * @throws SQLException the SQL exception
     * grant SELECT on "MDI"."MDI_V_TEMP_AVG_YEAR" to "MDI_R_INQUIRY" ;
     */
    public static TempAvgYear getInstance(int planyear, int stationId, int rcdYear, boolean fetch)throws SQLException{
    	if(isNull(planyear, stationId, rcdYear))return null;
		EntityManager em = EntityManagerHelper.getEntityManager();
		PrimaryKey pk = new PrimaryKey(planyear, stationId, rcdYear);
		TempAvgYear o = null;
		if(fetch || em.getEntityManagerFactory().getCache() != null && em.getEntityManagerFactory().getCache().contains(Temperature.class, pk))
			o = em.find(TempAvgYear.class, pk);
		if(o==null && fetch)
			o = new TempAvgYear(planyear,stationId,rcdYear);
		return o;
    }
    
//    public static void queryTenYears(int planyear, int stationId, int rcdYear) throws SQLException{
//		PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement("SELECT * FROM "+TABLE+" WHERE PLANYEAR=? AND STATION_ID=? AND rcd_year > ?");
//		ps.setInt(1, planyear);
//		ps.setInt(2, stationId);
//		ps.setInt(3, rcdYear-10);
//		ResultSet rs = ps.executeQuery();
//		while(rs.next())
//			getInstance(rs);
//		for(int y=rcdYear; y>rcdYear-10; y--){
//			String key = getHashKey(new Object[]{planyear, stationId, y});
//			TempYear o = getInstance(key);
//			if(o == null){
//				o = new TempYear(planyear, stationId, y);
//				getHashtable().put(key,o);
//			}
//		}
//		rs.close();
//		ps.close();
//    }
    
//    public static TempYear getInstance(ResultSet rs)throws SQLException{
//		int planyear = rs.getInt("PLANYEAR");
//		int stationId = rs.getInt("STATION_ID");
//		int rcdYear = rs.getInt("RCD_YEAR");
//		String key = getHashKey(new Object[]{planyear, stationId, rcdYear});
//		TempYear o = getInstance(key);
//		if(o == null){
//			o = new TempYear(planyear, stationId, rcdYear);
//			o.refresh(rs);
//			getHashtable().put(key,o);
//		}
//		return o;
//	}
    
    public TempAvgYear(){
    }

    /**
     * The Constructor.
     *
     * @param stationId the station id
     * @param planyear the planyear
     * @param rcdYear the rcd year
     */
    private TempAvgYear(int planyear, int stationId, int rcdYear){
        this.planyear=planyear;
        this.stationId=stationId;
        this.rcdYear=rcdYear;
    }
    public String getHashKey(){
		return getHashKey(getKeyValues());
	}
	public Object[] getKeyValues(){
		return new Object[]{planyear, stationId, rcdYear};
	}
    @Override
	public int hashCode(){
		return PrimaryKey.hashCode(getKeyValues());
	}
	@Id
	@Column(name="PLANYEAR",nullable=false,length=4)
    public int getPlanyear(){
        return planyear;
    }
    public void setPlanyear(int planyear){
    	this.planyear = planyear;
    }
    @Id
	@Column(name="STATION_ID",nullable=false,length=9)
    public int getStationId(){
        return stationId;
    }
    public void setStationId(int stationId){
    	this.stationId = stationId;
    }
    @Id
	@Column(name="RCD_YEAR",nullable=false,length=4)
    public int getRcdYear(){
        return rcdYear;
    }
    public void setRcdYear(int rcdYear){
    	this.rcdYear = rcdYear;
    }
	@Column(name="AVG_TEMP",nullable=false,length=24)
    public double getAvgTemp(){
        return avgTemp;
    }
    public void setAvgTemp(double avgTemp){
    	this.avgTemp = avgTemp;
    }
    /**
     * Refreshes the object using the specified ResultSet.
     *
     * @param rs The ResultSet containing all the fields of the object, already pointed to the this instance
     *
     * @throws SQLException the SQL exception
     */
    public void refresh(ResultSet rs)throws SQLException{
    	avgTemp = rs.getDouble("AVG_TEMP");
        if(wsValidPeakCount>0)
        	refreshMissingPeaks();
    }

    public int wsValidPeakCount = -1;

    public int getWSMissingPeaksFlag() throws SQLException{

    	Flag flag = Flag.getInstance(getPlanyear(), Flag.WS_MISSING_PEAKS_FLAG);
    	if(flag!=null && !flag.isDisabled() && flag.isShowFlag()) {

//    		System.out.println(" in flag");
    		
    		if(wsValidPeakCount < 0)
        		refreshMissingPeaks();

	    	Calendar today = Calculate.getCal();

	    	Calendar startDate = Calculate.getCal(getRcdYear(),Calendar.JUNE,1);
			if(startDate.getTimeInMillis() > today.getTimeInMillis()){
//				System.out.println(getRcdYear()+" s: "+FormatText.USER_DATE.format(startDate.getTime())+ " t: "+FormatText.USER_DATE.format(today.getTime()));
				return 0;
			}

			Calendar endDate = Calculate.getCal(getRcdYear(),Calendar.OCTOBER,1);
			if(endDate.getTimeInMillis() > today.getTimeInMillis())
				endDate = (Calendar)today.clone();


			int daysDiff = Calculate.getDaysDiff(endDate, startDate);
			
//			System.out.println("y: "+this.getRcdYear()+ "st: "+getStationId()+" valid: "+(wsValidPeakCount*1.0)+" dd: "+daysDiff+" flagV: "+flag.getValue());

			if( 1.0-(wsValidPeakCount*1.0 / daysDiff) > flag.getValue() )
	    		return flag.getFlagId();

    	}

    	return 0;
    }

    public void refreshMissingPeaks() throws SQLException{

    	wsValidPeakCount = 0;

    	Calendar today = Calculate.getCal();

    	Calendar startDate = Calculate.getCal(rcdYear,Calendar.JUNE,1);
		if(startDate.getTimeInMillis() > today.getTimeInMillis()){
			return;
		}

		Calendar endDate = Calculate.getCal(rcdYear,Calendar.OCTOBER,1);
		if(endDate.getTimeInMillis() > today.getTimeInMillis())
			endDate = (Calendar)today.clone();


		PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement("SELECT COUNT(*) FROM "+Temperature.class.getAnnotation(Table.class).name()+" WHERE PLANYEAR = ? AND STATION_ID = ? AND RCD_DATE >= ? AND RCD_DATE <= ? AND MAX_TEMP > 0 AND MIN_TEMP > 0");
    	ps.setInt(1, planyear);
    	ps.setInt(2, stationId);
    	ps.setDate(3, new java.sql.Date(startDate.getTimeInMillis()));
    	ps.setDate(4,new java.sql.Date(endDate.getTimeInMillis()));

		ResultSet rs = ps.executeQuery();
		if(rs.next())
			wsValidPeakCount = rs.getInt(1);
		rs.close();
		ps.close();
    }
}