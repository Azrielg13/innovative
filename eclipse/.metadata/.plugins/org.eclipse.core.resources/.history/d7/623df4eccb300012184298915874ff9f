/*
 * Copyright (c) 2002-2010 ESP Suite. All Rights Reserved.
 *
 *     
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Authors: Technology Integration Group, SCE
 * Developers: Eddie Mayfield, Frank Gonzales, Augustin Muniz,
 * Kate Suwan, Hiro Kushida, Andrew McNaughton, Brian Stonerock,
 * Russell Ragsdale, Patrick Ridge, Everett Aragon.
 * 
 */
package com.sce.esp.jortho;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.zip.Deflater;
import java.util.zip.DeflaterOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;


/**
 * How to use
 * <li>Download the latest Wiktionary file "pages_articles.xml".
 * It is typical compressed. The position changed. I found it last at:
 * <ul>
 * <li>http://download.wikimedia.org/arwiktionary/latest/arwiktionary-latest-pages-articles.xml.bz2
 * <li>http://download.wikimedia.org/dewiktionary/latest/dewiktionary-latest-pages-articles.xml.bz2
 * <li>http://download.wikimedia.org/enwiktionary/latest/enwiktionary-latest-pages-articles.xml.bz2
 * <li>http://download.wikimedia.org/eswiktionary/latest/eswiktionary-latest-pages-articles.xml.bz2
 * <li>http://download.wikimedia.org/frwiktionary/latest/frwiktionary-latest-pages-articles.xml.bz2
 * <li>http://download.wikimedia.org/itwiktionary/latest/itwiktionary-latest-pages-articles.xml.bz2
 * <li>http://download.wikimedia.org/plwiktionary/latest/plwiktionary-latest-pages-articles.xml.bz2
 * <li>http://download.wikimedia.org/ruwiktionary/latest/ruwiktionary-latest-pages-articles.xml.bz2
 * </ul>
 * </li>
 * 
 * <li>start the Generator with follow command line:<br>
 * java -Xmx256m com.inet.spell.wiktionary.BookGenerator de <folder with file></li>
 * @author Volker
 */
public abstract class BookGenerator {

    private final Book book;

    
    public static void main(String[] args) throws Exception {
        String languagesList = (args.length>0) ? args[0] : "en";
        String dirName  = (args.length>1) ? args[1].replace( '\\', '/' ) : "";
        if(dirName.length() > 0 && !dirName.endsWith( "/" )){
            dirName += '/';
        }
        String[] languages = languagesList.split(",");
        for(int i = 0; i < languages.length; i++){
            String language = languages[i];
            
            String filename = dirName + language+"wiktionary-latest-pages-articles.xml";
            File file = new File(filename);
            BookGenerator generator = (BookGenerator)Class.forName( BookGenerator.class.getName()+"_" + language ).newInstance();
            generator.start(file);
            generator.save(language);
            
            generator.createPackage( language );
        }
    }
    
    BookGenerator(){
        this(new Book());
    }
    
    BookGenerator(Book book){
        this.book = book;
    }
    
    /**
     * Beginn des einlesend der Daten von dem XML stream
     * @param stream Daten im XML format
     */
    void start(File file) throws Exception{
        InputStream stream = new FileInputStream(file);
        System.out.println("=== Start Parsing XML stream ===");
        new Parser(this, stream);

        stream.close();
    }
    
    
    final void save(String language) throws Exception{
        File dictFile = new File("dictionary_"+language+".ortho");
        OutputStream dict = new FileOutputStream(dictFile);
        dict = new BufferedOutputStream(dict);
        Deflater deflater = new Deflater();
        deflater.setLevel(Deflater.BEST_COMPRESSION);
        dict = new DeflaterOutputStream(dict, deflater);
        dict = new BufferedOutputStream(dict);
        PrintStream dictPs = new PrintStream(dict, false, "UTF8");
        
        OutputStream txt = new FileOutputStream("IncludedWords.txt");
        txt = new BufferedOutputStream(txt);
        PrintStream ps = new PrintStream(txt, false, "UTF8");
        
        //Save as word list
        String[] words = book.getWords();
        Arrays.sort( words );
        for(int i=0; i<words.length; i++){
            ps.print( words[i] +'\n' );
            dictPs.print( words[i] +'\n' );
        }
        ps.close();
        dictPs.close();
        saveStatistics(dictFile);
    }
    
    /**
     * Create statistics data and save it in statistics.txt
     * @param dictFile the created ortho file.
     * @throws Exception if an error occur
     */
    private final void saveStatistics(File dictFile) throws Exception{
        String statistics = "";
        statistics += "Total Wiktionary Title count: "+book.getTitleCount()+"\r\n";
        statistics += "Language Title count: "+book.getLanguageTitleCount()+"\r\n";
        statistics += "Word count in dictionary: "+book.getWordCount()+"\r\n";
        statistics += "Char count in dictionary: "+book.getCharCount()+"\r\n";
        statistics += "Dictionary size on disk (bytes): " + dictFile.length()+"\r\n";
        
        // we use reflection, because the methods are not public and should not be public
        Class clazz = Class.forName("com.inet.jortho.DictionaryFactory");
        Constructor constructor = clazz.getConstructor();
        constructor.setAccessible(true);
        Object factory = constructor.newInstance();
        Method loadWordList = clazz.getDeclaredMethod( "loadWordList", URL.class );
        loadWordList.setAccessible(true);
        loadWordList.invoke(factory, dictFile.toURL());
        Method create = clazz.getDeclaredMethod( "create" );
        create.setAccessible(true);
        Object dictionary = create.invoke( factory );
        Method getDataSize = dictionary.getClass().getDeclaredMethod( "getDataSize" );
        getDataSize.setAccessible(true);
        Integer size = (Integer)getDataSize.invoke( dictionary );
        statistics += "Dictionary size in memory (bytes): " + size+"\r\n";
        
        System.out.println(statistics);
        FileOutputStream out = new FileOutputStream("statistics.txt");
        out.write( statistics.getBytes() );
        out.close();
    }
    
    /**
     * Generate the distribution package 
     * @throws Exception 
     */
    private final void createPackage(String language) throws Exception{
        ZipOutputStream out = new ZipOutputStream(new FileOutputStream("dictionary_"+language+"_" + new SimpleDateFormat("yyyy_MM").format( new Date() )+ ".zip"));
        
        out.setLevel( Deflater.BEST_COMPRESSION );
        addFileToZip( out, "license.txt", false );
        addFileToZip( out, "dictionary_"+language+".ortho", true );
        addFileToZip( out, "statistics.txt", true );
        addFileToZip( out, "IncludedWords.txt", true );
        
        out.close();
    }
    
    private final void addFileToZip(ZipOutputStream out, String filename, boolean delete) throws Exception{
        File file = new File(filename);
        FileInputStream fin = new FileInputStream( file );
        ZipEntry entry = new ZipEntry(filename);
        entry.setTime( file.lastModified() );
        out.putNextEntry( entry );
        byte[] buffer = new byte[16384];
        int count;
        while((count = fin.read(buffer)) > 0){
            out.write(  buffer, 0, count );
        }
        out.closeEntry();
        fin.close();
        if(delete){
            file.delete();
        }
    }
    
    /**
     * Help function for parsing the Wiktinary formats.
     * @param string zu durchsuchender String
     * @param chars the searching charchters, can not be empty
     * @param fromIndex Startposition der Suche. Index beginnt bei 0.
     * @return erstes vorkommen einer der Zeichen in chars oder -1, wenn nicht gefunden.
     */
    protected final int indexOf(String string, char[] chars, int fromIndex){
        for(; fromIndex < string.length(); fromIndex++){
            char c = string.charAt(fromIndex);
            for(int i=0; i<chars.length; i++){
                if(c == chars[i]) return fromIndex;
            }
        }
        return -1;
    }
    
    
    /**
     * Pr�ft ob es sich um ein g�ltiges Word handelt. Damit k�nnen bestimmte Hilfsthemen 
     * und Phrasen ausgeschlossen werden.
     * @param word zu pr�fendes Wort, darf nicht null sein
     * @return true wenn es ein g�ltiges Wort ist.
     */
    protected boolean isValidWord(String word){
        final int length = word.length();
        if(length <= 1) return false;
        for(int i=length-1; i>=0; i--){
            char ch = word.charAt(i);
            if(Character.isLetter( ch ) || ch == '\''){
                continue;
            }
            
            //Bei Abkürzungen einen Punkt am Ende
            if(ch == '.' && i == length-1){
                continue;
            }
            
            //Bindestriche nur in der Wortmitte
            if(ch == '-' && i != 0 && i != length-1){
                continue;
            }

            return false;
        }
        return true;
    }
    
    
    /**
     * F�gt ein Wort zum Tree hinzu.
     * @param word darf nicht null sein.
     */
    final protected void addWord(String word){
        book.addWord( word );
    }
    
    /**
     * Get the resulting book for the current generator.
     * @return the book
     */
    Book getBook(){
        return book;
    }
    
    /**
     * Check if a word is a valid word of the current language.
     * With function getBook().addWord() you can add additional Flexion of the word.
     * The current word self does not need added. 
     * @param word the test word
     * @param wikiText die decription from Wiktionary
     * @return true if valid
     */
    abstract boolean isValidLanguage(String word, String wikiText); 
}
