/*
 * Copyright (c) 2002-2010 ESP Suite. All Rights Reserved.
 *
 *     
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Authors: Technology Integration Group, SCE
 * Developers: Eddie Mayfield, Frank Gonzales, Augustin Muniz,
 * Kate Suwan, Hiro Kushida, Andrew McNaughton, Brian Stonerock,
 * Russell Ragsdale, Patrick Ridge, Everett Aragon.
 * 
 */
package com.sce.esp.component;

import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;

import javax.swing.AbstractAction;
import javax.swing.JTextField;
import javax.swing.KeyStroke;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.event.UndoableEditEvent;
import javax.swing.event.UndoableEditListener;
import javax.swing.text.Document;
import javax.swing.undo.CannotRedoException;
import javax.swing.undo.CannotUndoException;
import javax.swing.undo.UndoManager;

public class JTrackedTextField extends JTextField {
	/**
	 * 
	 */
	private static final long serialVersionUID = 535797771051857584L;
	private Color backgroundColor = new Color(0xFFFFFF);// ColorTableManager.Colors.FIELD_COLOR.color();
	private Color changeBackgroundColor = new Color(0xFFFFDD);// ColorTableManager.Colors.FIELD_CHANGED.color();
	private String originalText;
	private UndoManager undo = new UndoManager();

	public JTrackedTextField() {
		DocumentListener documentListener = new DocumentListener() {
			public void insertUpdate(DocumentEvent e) {
				updateStatus();
			}

			public void removeUpdate(DocumentEvent e) {
				updateStatus();
			}

			public void changedUpdate(DocumentEvent e) {
				updateStatus();
			}
		};

		FocusListener focusListener = new FocusListener() {
			public void focusGained(FocusEvent e) {
				JTrackedTextField.this.selectAll();
			}

			public void focusLost(FocusEvent e) {
			}
		};

		this.addFocusListener(focusListener);
		Document doc = this.getDocument();
		doc.addDocumentListener(documentListener);

		doc.addUndoableEditListener(new UndoableEditListener() {
			public void undoableEditHappened(UndoableEditEvent evt) {
				undo.addEdit(evt.getEdit());
			}
		});

		// Create an undo action and add it to the text component
		this.getActionMap().put("Undo", new AbstractAction("Undo") {
			/**
			 * 
			 */
			private static final long serialVersionUID = 7280388393849490817L;

			public void actionPerformed(ActionEvent evt) {
				try {
					if (undo.canUndo()) {
						undo.undo();
					}
				} catch (CannotUndoException e) {
				}
			}
		});

		// Bind the undo action to ctl-Z
		this.getInputMap().put(KeyStroke.getKeyStroke("control Z"), "Undo");

		// Create a redo action and add it to the text component
		this.getActionMap().put("Redo", new AbstractAction("Redo") {
			/**
			 * 
			 */
			private static final long serialVersionUID = 6043661610627212120L;

			public void actionPerformed(ActionEvent evt) {
				try {
					if (undo.canRedo()) {
						undo.redo();
					}
				} catch (CannotRedoException e) {
				}
			}
		});

		// Bind the redo action to ctl-Y
		this.getInputMap().put(KeyStroke.getKeyStroke("control Y"), "Redo");
	}

	public void setOriginalText(String text) {
		this.originalText = text;
		updateStatus();
		undo.discardAllEdits();
	}

	public boolean isTextChanged() {
		return originalText == null ? getText() != null
				&& !"".equals(getText()) : !originalText.equals(getText());
	}

	public void setText(String text) {
		super.setText(text);
		updateStatus();
		undo.discardAllEdits();
	}

	public void updateStatus() {
		if (isTextChanged()) {
			setBackground(changeBackgroundColor);
		} else {
			setBackground(backgroundColor);
		}
	}
}
