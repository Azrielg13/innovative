package com.sce.esp.component;

import java.awt.Point;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DragGestureEvent;
import java.awt.dnd.DragGestureListener;
import java.awt.dnd.DragSource;
import java.awt.dnd.DragSourceDragEvent;
import java.awt.dnd.DragSourceDropEvent;
import java.awt.dnd.DragSourceEvent;
import java.awt.dnd.DragSourceListener;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.Timer;
import javax.swing.UIManager;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;

import com.sce.esp.object.jpa.EntityManagerHelper;
import com.sce.esp.object.model.Bbank;
import com.sce.esp.object.model.DuctBank;
import com.sce.esp.util.ESPProperties;

/**
 * 
 * @author Distribution Staff Engineering
 *
 */
public class DbTreeDragSource implements DragGestureListener, DragSourceListener {
  
	public DbTreeDragSource(JTree tree) {
    this.tree = tree;

    // Use the default DragSource
    DragSource dragSource = DragSource.getDefaultDragSource();

    // Create a DragGestureRecognizer and
    // register as the listener
    dragSource.createDefaultDragGestureRecognizer(tree,
        DnDConstants.ACTION_COPY_OR_MOVE, this);
  }

  // Implementation of DragGestureListener interface.
  public void dragGestureRecognized(DragGestureEvent dge) {
    // Get the mouse location and convert it to
    // a location within the tree.
    Point location = dge.getDragOrigin();
    TreePath dragPath = tree.getPathForLocation(location.x, location.y);
    if (dragPath != null && tree.isPathSelected(dragPath)) {
      
    	Object o = ((DefaultMutableTreeNode)dragPath.getLastPathComponent()).getUserObject();
    	if(o instanceof DuctBank){	
    	//	Transferable transferable = new DuctBankTransferable(dragDB);
    	}
    	
    	/* Get the list of selected files and create a Transferable
      // The list of files and the is saved for use when
      // the drop completes.
      paths = tree.getSelectionPaths();
      if (paths != null && paths.length > 0) {
    	  Object o = ((DefaultMutableTreeNode)paths.getLastPathComponent()).getUserObject();	

        Transferable transferable = new FileListTransferable(dragDB);
        dge.startDrag(null, transferable, this);
      }
      */
    }
  }

  // Implementation of DragSourceListener interface
  public void dragEnter(DragSourceDragEvent dsde) {
    DnDUtils.debugPrintln("Drag Source: dragEnter, drop action = "
        + DnDUtils.showActions(dsde.getDropAction()));
  }

  public void dragOver(DragSourceDragEvent dsde) {
    DnDUtils.debugPrintln("Drag Source: dragOver, drop action = "
        + DnDUtils.showActions(dsde.getDropAction()));
  }

  public void dragExit(DragSourceEvent dse) {
    DnDUtils.debugPrintln("Drag Source: dragExit");
  }

  public void dropActionChanged(DragSourceDragEvent dsde) {
    DnDUtils.debugPrintln("Drag Source: dropActionChanged, drop action = "
        + DnDUtils.showActions(dsde.getDropAction()));
  }

  public void dragDropEnd(DragSourceDropEvent dsde) {
    DnDUtils.debugPrintln("Drag Source: drop completed, drop action = "
        + DnDUtils.showActions(dsde.getDropAction()) + ", success: "
        + dsde.getDropSuccess());
    // If the drop action was ACTION_MOVE,
    // the tree might need to be updated.
    if (dsde.getDropAction() == DnDConstants.ACTION_MOVE) {
/*   final Duct[] draggedFiles;
	try {
		draggedFiles = (Duct[])(dragDB.getDucts().toArray());
	} catch (SQLException e) {
		e.printStackTrace();
	}*/
   //   final TreePath paths;

      Timer tm = new Timer(200, new ActionListener() {
        public void actionPerformed(ActionEvent evt) {
          // Check whether each of the dragged files exists.
          // If it does not, we need to remove the node
          // that represents it from the tree.
            
              // Remove this node
             // DefaultMutableTreeNode node = (DefaultMutableTreeNode) draggedPaths.getLastPathComponent();
              //((DefaultTreeModel) tree.getModel()).removeNodeFromParent(node);
            
          
        }
      });
      tm.setRepeats(false);
      tm.start();
    }
  }

  public static void main(String[] args) {
    try {
        UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
    } catch (Exception evt) {}
  
    JFrame f = new JFrame("Draggable File Tree");
	try {
		EntityManagerHelper.init(ESPProperties.getInstance().getDevDbUrl(), System.getProperty("user.name").toLowerCase(), "edison");
		Bbank sub = Bbank.getInstance(2007, 466);	
   	
    	JTree tree = new JTree(MDITreeModel.createDBTreeModel(sub));    	
    	tree.setCellRenderer(ESPTreeCellRenderer.getInstance());
    	
    	
      f.getContentPane().add(new JScrollPane(tree));

      // Attach the drag source
     // DbTreeDragSource dragSource = new DbTreeDragSource(tree);
    } catch (Exception e) {
    }
    f.pack();
    f.setVisible(true);
  }

  protected JTree tree; // The associated tree

  protected DuctBank dragDB; // Dragged db

  //protected TreePath[] paths; // Dragged paths
}


class DuctBankTransferable implements Transferable {
	DuctBank dbObj;
	
	
  public DuctBankTransferable(DuctBank dbObj) {
	  this.dbObj=dbObj;
  }

  // Implementation of the Transferable interface
  public DataFlavor[] getTransferDataFlavors() {
    return new DataFlavor[] { DataFlavor.stringFlavor };
  }

  public boolean isDataFlavorSupported(DataFlavor fl) {
    return fl.equals(DataFlavor.stringFlavor);
  }

  public Object getTransferData(DataFlavor fl) {
    if (!isDataFlavorSupported(fl)) {
      return null;
    }

    return dbObj;
  }

  
}

class DnDUtils {
  public static String showActions(int action) {
    String actions = "";
    if ((action & (DnDConstants.ACTION_LINK|DnDConstants.ACTION_COPY_OR_MOVE)) == 0) {
      return "None";
    }

    if ((action & DnDConstants.ACTION_COPY) != 0) {
      actions += "Copy ";
    }

    if ((action & DnDConstants.ACTION_MOVE) != 0) {
      actions += "Move ";
    }

    if ((action & DnDConstants.ACTION_LINK) != 0) {
      actions += "Link";
    }

    return actions;
  }

  public static boolean isDebugEnabled() {
    return debugEnabled;
  }

  public static void debugPrintln(String s) {
    if (debugEnabled) {
      System.out.println(s);
    }
  }

  private static boolean debugEnabled = true;
}

