/**
 *           | Master Data Interface Version 2.0 |
 *
 * Copyright (c) 2006, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team.
 * 	                   All rights reserved.
 *
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package com.sce.esp.object;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.Calendar;
import java.util.Hashtable;
import java.util.Vector;

import com.sce.esp.util.Calculate;
import com.sce.esp.util.ESPProperties;
import com.sce.esp.util.FormatText;
import com.sce.esp.util.PDBConnection;


/**
 * The MDIObject Object.
 *
 * @author Distribution Staff Engineering
 * @version 2.0
 */
public abstract class DataAccessObject implements Comparable<Object>{
	
	
	/** The Constant DEPARTMENT. */
	public final static int DEPARTMENT=0;

	/** The Constant ZONE. */
	public final static int ZONE=1;

	/** The Constant REGION. */
	public final static int REGION=2;

	/** The Constant DISTRICT. */
	public final static int DISTRICT=3;
	
	/** The Constant SYSTEM. */
	public final static int SYSTEM=4;

	/** The Constant ABANK. */
	public final static int ABANK=5;

	/** The Constant BBANK. */
	public final static int BBANK=6;

	/** The Constant CIRCUIT. */
	public final static int CIRCUIT=7;

	/** The Constant STL. */
	public final static int STL=8;
	
	/** The Constant WEATHERSTATION. */
	public final static int WEATHERSTATION=9;
	
	/** The new instance. */
	protected boolean newInstance=true;

	protected boolean prevInstanceRead=false;
	
	protected Calendar insertTs; //INSERT_DATE
	protected int insertUserId; //INSERT_USERNAME_ID
	protected Calendar modifiedTs; //MODIFIED_DATE
	protected int modifiedUserId; //MODIFIED_USERNAME_ID
	protected Calendar deletedTs; //DELETE_DATE
	protected int deleteUserId; //DELETE_USERNAME_ID

    /**
     * Creates a new instance of DBObject.
     */
    public DataAccessObject() {
    }

    public DataAccessObject(DataAccessObject orig){
	}

	/**
     * Checks if is new instance.
     *
     * @return true, if is new instance
     */
    public boolean isNewInstance(){
    	return newInstance;
    }

    /**
     * Compare to.
     *
     * @param o the o
     *
     * @return the int
     */
    public int compareTo(Object o){
    	if(o instanceof DataAccessObject)
    		return (toString()+getHashKey()).compareTo(o.toString()+((DataAccessObject)o).getHashKey());
        return 0;
    }

    /**
     * Checks if is auto insertable.
     *
     * @return true, if is auto insertable
     */
    public boolean isAutoInsertable(){
    	return false;
    }

    /**
     * Gets the hashtable.
     *
     * @return the hashtable
     */
    public static Hashtable<String,? extends DataAccessObject> getHashtable(){
    	return null;
    }

    /**
     * Gets the PK set.
     *
     * @return the PK set
     */
    public abstract String[] getPKSet();

    /**
     * Gets the hash key.
     *
     * @return the hash key
     */
    public abstract String getHashKey();

    /**
     * Sets the PS keys.
     *
     * @param startIndex the start index
     * @param ps the ps
     *
     * @throws SQLException the SQL exception
     */
    public abstract void setPSKeys(PreparedStatement ps, int startIndex)throws SQLException;

    /**
     * Gets the DB table.
     *
     * @return the DB table
     */
    public abstract String getDBTable();

    /**
     * Gets the SEQ.
     *
     * @return the SEQ
     */
    public String getSEQ(){
    	return getDBTable().substring(0,getDBTable().indexOf('_'))+"_SEQ";
    }

    /**
     * Gets the insert P ks.
     *
     * @return whereClause
     */
    public String getInsertPKs(){
    	String whereClause = "";
		for(String col:getPKSet()){
			if(whereClause.length() > 0)
				whereClause+=",";
			whereClause += col;
		}
		return whereClause;
    }

    /**
     * Gets the where clause.
     *
     * @return whereClause
     */
    public String getWhereClause(){
    	String whereClause = "WHERE ";
		boolean first=true;
		for(String col:getPKSet()){
			if(!first)
				whereClause += " AND ";
			whereClause += col+"=?";
			first=false;
		}
		return whereClause;
    }

    /**
     * Refresh.
     *
     * @return true, if refresh
     *
     * @throws SQLException the SQL exception
     */
    public boolean refresh()throws SQLException{
    	boolean ret=true;
        Connection con = PDBConnection.getInstance().getConnection();
        PreparedStatement ps =  con.prepareStatement("SELECT * FROM "+getDBTable()+" "+getWhereClause());
        setPSKeys(ps,1);
        ResultSet rs = ps.executeQuery();
        if(rs.next())
            refresh(rs);
        else
        	ret=false;
        rs.close();
        ps.close();
        return ret;
    }
    
    /**
	 * Returns the insertDate
	 * @return The insertDate
	 */
	public Calendar getInsertTs(){
		if(isNewInstance() && insertTs==null)
			return Calendar.getInstance();
		return insertTs;
	}

	/**
	 * Sets the insertDate
	 * @param The new insertDate
	 */
	public void setInsertTs(Calendar insertDate)throws SQLException{
		if(isSame(insertDate,getInsertTs())) return;
		setProperty("INSERT_TS",insertDate);
		this.insertTs = insertDate;
	}

	/**
	 * Returns the insertUsernameId
	 * @return The insertUsernameId
	 */
	public int getInsertUserId(){
		if(isNewInstance() && insertUserId==0)
			return User.getActiveUser().getUsernameId();
		return insertUserId;
	}

	/**
	 * Sets the insertUsernameId
	 * @param The new insertUsernameId
	 */
	public void setInsertUserId(int insertUserId)throws SQLException{
		if(isSame(insertUserId,getInsertUserId())) return;
		if(insertUserId == 0)
			setProperty("INSERT_USER_ID",null);
		else
			setProperty("INSERT_USER_ID",insertUserId);
		this.insertUserId = insertUserId;
	}

	/**
	 * Returns the modifiedDate
	 * @return The modifiedDate
	 */
	public Calendar getModifiedTs(){
		return modifiedTs;
	}

	/**
	 * Sets the modifiedDate
	 * @param The new modifiedDate
	 */
	public void setModifiedTs(Calendar modifiedDate)throws SQLException{
		if(isSame(modifiedDate,getModifiedTs())) return;
		setProperty("MODIFIED_TS",modifiedDate);
		this.modifiedTs = modifiedDate;
	}

	/**
	 * Returns the modifiedUsernameId
	 * @return The modifiedUsernameId
	 */
	public int getModifiedUserId(){
		return modifiedUserId;
	}

	/**
	 * Sets the modifiedUsernameId
	 * @param The new modifiedUsernameId
	 */
	public void setModifiedUserId(int modifiedUserId)throws SQLException{
		if(isSame(modifiedUserId,getModifiedUserId())) return;
		if(modifiedUserId == 0)
			setProperty("MODIFIED_USER_ID",null);
		else
			setProperty("MODIFIED_USER_ID",modifiedUserId);
		this.modifiedUserId = modifiedUserId;
	}

	/**
	 * Returns the deleteDate
	 * @return The deleteDate
	 */
	public Calendar getDeletedTs(){
		return deletedTs;
	}

	/**
	 * Sets the deleteDate
	 * @param The new deleteDate
	 */
	public void setDeletedTs(Calendar deleteDate)throws SQLException{
		if(isSame(deleteDate,getDeletedTs())) return;
		setProperty("DELETED_TS",deleteDate);
		this.deletedTs = deleteDate;
	}

	/**
	 * Returns the deleteUsernameId
	 * @return The deleteUsernameId
	 */
	public int getDeletedUserId(){
		return deleteUserId;
	}

	/**
	 * Sets the deleteUsernameId
	 * @param The new deleteUsernameId
	 */
	public void setDeletedUserId(int deleteUserId)throws SQLException{
		if(isSame(deleteUserId,getDeletedUserId())) return;
		if(deleteUserId == 0)
			setProperty("DELETED_USER_ID",null);
		else
			setProperty("DELETED_USER_ID",deleteUserId);
		this.deleteUserId = deleteUserId;
	}


	public void refresh(ResultSet rs) throws SQLException{
		insertTs = getCalendar(rs.getTimestamp("INSERT_TS"));
		insertUserId = rs.getInt("INSERT_USER_ID");
		modifiedTs = getCalendar(rs.getTimestamp("MODIFIED_TS"));
		modifiedUserId = rs.getInt("MODIFIED_USER_ID");
		deletedTs = getCalendar(rs.getTimestamp("DELETED_TS"));
		deleteUserId = rs.getInt("DELETED_USER_ID");
	}
	public User getInsertUser()throws SQLException{
		return User.getInstance(getInsertUserId());
	}
	public void setInsertUser(User user)throws SQLException{
		if(user==null)
			setInsertUserId(0);
		else
			setInsertUserId(user.getUsernameId());
	}
	public User getModifiedUser() throws SQLException {
		return User.getInstance(getModifiedUserId());
	}
	public void setModifiedUser(User user2)throws SQLException{
		if(user2==null)
			setModifiedUserId(0);
		else
			setModifiedUserId(user2.getUsernameId());
	}
	public User getDeletedUser()throws SQLException{
		return User.getInstance(getDeletedUserId());
	}
	public void setDeletedUser(User user3)throws SQLException{
		if(user3==null)
			setDeletedUserId(0);
		else
			setDeletedUserId(user3.getUsernameId());
	}

	public int setProperty(String col, Object value) throws SQLException{
		if(isNewInstance())
			return 0;
		Connection con = PDBConnection.getInstance().getConnection();
		String valStr = ""+value;
		if(value != null && value instanceof Calendar)
			valStr = FormatText.USER_DATETIME.format(((Calendar)value).getTime());
		if(ESPProperties.getInstance().getRunningInstance() != ESPProperties.WEB_APP)
			System.out.println("DATABASE UPDATE: "+getDBTable()+" "+getHashKey()+" "+col+" "+valStr);
		Calendar mDate = Calendar.getInstance();
		PreparedStatement ps = con.prepareStatement("UPDATE "+getDBTable()+" SET "+col+"=?, MODIFIED_TS=?, MODIFIED_USER_ID=? "+getWhereClause());
		setPSValue(ps,1,value);
		ps.setTimestamp(2,new Timestamp(mDate.getTimeInMillis()));
		ps.setInt(3,User.getActiveUser().getUsernameId());
		setPSKeys(ps,4);
		int c = ps.executeUpdate();
		ps.close();
		if(c==0){
			if(getRealRecord() != this)
				c = simCopy(col,value);
			if(c <= 0){
				if(isAutoInsertable())
					c = insert(col,value);
				else/* Update attempted but record does not exist and not auto insertable*/
					throw new SQLException("Database Entry Not Found");
			}
		}
		modifiedTs = mDate;
		modifiedUserId = User.getActiveUser().getUsernameId();
		return c;
	}

	/**
	 * Insert.
	 *
	 * @param col the col
	 * @param value the value
	 *
	 * @return c
	 *
	 * @throws SQLException the SQL exception
	 */
	public int insert(String col, Object value)throws SQLException{
		int pc = getPKSet().length;
		String insert = "INSERT INTO "+getDBTable()+" ("+col+",INSERT_TS,INSERT_USER_ID,"+getInsertPKs()+") VALUES(?,?,?";
		for(int p=0; p<pc; p++)
			insert += ",?";
		insert += ")";
		Connection con = PDBConnection.getInstance().getConnection();
		if(ESPProperties.getInstance().getRunningInstance() != ESPProperties.WEB_APP)
			System.out.println("DATABASE INSERT: "+insert);
		PreparedStatement ps = con.prepareStatement(insert);
		setPSValue(ps,1,value);
		ps.setTimestamp(2,new Timestamp(Calendar.getInstance().getTimeInMillis()));
		ps.setInt(3,User.getActiveUser().getUsernameId());
		setPSKeys(ps,4);
		int c = ps.executeUpdate();
		ps.close();
		if(!isRealRecord())
			refresh();
		refreshParents();
		return c;
	}

	public boolean delete() throws SQLException{
		Connection con = PDBConnection.getInstance().getConnection();
		Calendar mDate = Calendar.getInstance();
		System.out.println("UPDATE "+getDBTable()+" SET DELETED_TS=?, DELETED_USER_ID=? "+getWhereClause());
		PreparedStatement ps = con.prepareStatement("UPDATE "+getDBTable()+" SET DELETED_TS=?, DELETED_USER_ID=? "+getWhereClause());
		ps.setTimestamp(1,new Timestamp(mDate.getTimeInMillis()));
		ps.setInt(2,User.getActiveUser().getUsernameId());
		setPSKeys(ps,3);
		boolean ret = ps.executeUpdate() > 0;
		ps.close();
		postDelete();
		setDeletedTs(mDate);
		return ret;
	}

	public boolean deleteDB() throws SQLException{
		Connection con = PDBConnection.getInstance().getConnection();
		System.out.println("DATABASE DELETE: "+getDBTable()+" "+getWhereClause());
		PreparedStatement ps = con.prepareStatement("DELETE FROM "+getDBTable()+" "+getWhereClause());
		setPSKeys(ps,1);
		boolean ret = ps.execute();
		ps.close();
		postDelete();
		return ret;
	}

	public void restore() throws SQLException{
		setDeletedTs(null);
		setDeletedUserId(0);
		refreshParents();
	}
	
	public boolean isDeleted(){
		return getDeletedTs()!=null;
	}

    /**
     * Gets the real record.
     *
     * @return the real record
     */
    public DataAccessObject getRealRecord(){
    	return this;
    }

    /**
     * Checks if is real record.
     *
     * @return true, if is real record
     */
    public boolean isRealRecord(){
    	return getRealRecord() == this;
    }


    /**
     * Pre Insert.
     *
     * @return true, if insert
     *
     * @throws SQLException the SQL exception
     */
    public boolean preSimCopy()throws SQLException{
        return true;
    }

    /**
     * Insert.
     *
     * @return true, if insert
     *
     * @throws SQLException the SQL exception
     */
    public boolean insert()throws SQLException{
        throw new SQLException(getClass()+" does not implement insert");
    }

    /**
     * Sim copy.
     *
     * @param col the col
     * @param value the value
     *
     * @return the int
     *
     * @throws SQLException the SQL exception
     */
    public int simCopy(String col, Object value)throws SQLException{
    	int count=0;
    	DataAccessObject real = getRealRecord();
    	if(real != this && preSimCopy()){
			PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement("SELECT * FROM "+getDBTable()+" "+getWhereClause());
			real.setPSKeys(ps,1);
			ResultSet rs = ps.executeQuery();
			if(rs.next()){
				String columns="";
				String values="";
				ResultSetMetaData rsmd = rs.getMetaData();
				for(int c=1; c<rsmd.getColumnCount()+1; c++){
					if(c > 1){
						columns+=",";
						values+=",";
					}
					columns+=rsmd.getColumnName(c);
					values+="?";
				}
				PreparedStatement ps2 = PDBConnection.getInstance().getConnection().prepareStatement("INSERT INTO "+getDBTable()+"("+columns+") VALUES("+values+")");
				Vector<String> keys = new Vector<String>();
				for(String key:getPKSet())
					keys.add(key);
				for(int c=1; c<rsmd.getColumnCount()+1; c++){
					String colName = rsmd.getColumnName(c); 
					if(keys.contains(colName)){
						try {
							ps2.setObject(c, getClass().getMethod("get"+FormatText.toUpperCamel(colName), (Class[])null).invoke(this, (Object[])null));
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					else if(col != null && col.equalsIgnoreCase(colName)){
						if(value instanceof Calendar)
							ps2.setTimestamp(c,new Timestamp(((Calendar)value).getTimeInMillis()));
						else
							ps2.setObject(c,value,rsmd.getColumnType(c));
					}else
						ps2.setObject(c,rs.getObject(c),rsmd.getColumnType(c));
				}
				count = ps2.executeUpdate();
				ps2.close();
				refresh();
				refreshParents();
			}
			rs.close();
			ps.close();
		}
    	return count;
    }
    
    /**
     * Post delete.
     *
     * @throws SQLException the SQL exception
     */
    public void postDelete()throws SQLException{
    	try {
    		((Hashtable<?,?>)getClass().getMethod("getHashtable", new Class[]{}).invoke(null, (Object[])null)).remove(getHashKey());
    	}catch(Exception e) {
    		e.printStackTrace();
    	}
    	refreshParents();
    }

    /**
     * Refresh parents.
     *
     * @throws SQLException the SQL exception
     */
    public void refreshParents()throws SQLException{
    }
    
    /**
     * Sets the PS value.
     *
     * @param index the index
     * @param value the value
     * @param ps the ps
     *
     * @throws SQLException the SQL exception
     */
    public static void setPSValue(PreparedStatement ps, int index, Object value)throws SQLException{
    	if(value instanceof Integer)
        	ps.setInt(index,(Integer)value);
        else if(value instanceof Double)
        	ps.setDouble(index,(Double)value);
        else if(value instanceof Boolean)
        	ps.setBoolean(index,(Boolean)value);
        else if(value instanceof Calendar){
        	if(value == null)
        		ps.setTimestamp(index,null);
        	else
        		ps.setTimestamp(index,new Timestamp(((Calendar)value).getTimeInMillis()));
//        		ps.setTimestamp(si++,new Timestamp(getPriorityTs().getTimeInMillis()));
        }
        else if(value instanceof Time)
        	ps.setTime(index,(Time)value);
        else if(value instanceof String)
        	ps.setString(index,(String)value);
        else
        	ps.setObject(index,value);
    }
    
    public static boolean isSame(Object o, Object o2){
    	return Calculate.isSame(o, o2);
    }

    /**
     * Returns a string hash code of an object of this type with the
     * specified parameters. The hash code would be used to find the
     * object in a hash table.
     *
     * @param id - id for the object
     * @param planyear - planYear for the object
     * @param k1 the k1
     *
     * @return a string hash code of an object of this type with the specified parameters.
     */
    public static String getHashKey(Object k){
    	if(k instanceof Calendar)
    		return FormatText.MYSQL_DATE.format(((Calendar)k).getTime());
    	return ""+k;
    }

    public static String getHashKey(Object[] keys){
    	String code="";
    	boolean first=true;
    	for(Object k:keys){
    		if(!first)
    			code+="-";
    		else
    			first=false;
    		code += getHashKey(k);
    	}
    	return code;
    }

    public static boolean isNull(Object[] keys){
    	for(Object k:keys)
    		if(Calculate.isNull(k))
    			return true;
    	return false;
    }
    
    public static boolean isNull(Object o){
    	return Calculate.isNull(o);
    }

    /**
     * To string.
     *
     * @return the string
     */
    public String toString(){
    	return getHashKey();
    }

    public static Class<DataAccessObject> getClassByDBTable(String table){
    	try{
    		return (Class<DataAccessObject>)Class.forName("com.sce.esp.object."+FormatText.toUpperCamel(table.substring(table.indexOf('_')+1)));
    	}catch(Exception e){
    		//e.printStackTrace();
    	}
		return null;
	}
    
    private static Vector<Class<DataAccessObject>> allClasses;

    public static Vector<Class<DataAccessObject>> getAllObjects(String tableSearch) throws SQLException{
    	if(allClasses == null){
    		allClasses = new Vector<Class<DataAccessObject>>();
    		DatabaseMetaData dbmd = PDBConnection.getInstance().getConnection().getMetaData();
    		ResultSet rs = dbmd.getTables(null,PDBConnection.SCHEMA,tableSearch,new String[]{"TABLE"});
    		while(rs.next()){
				String table = rs.getString("TABLE_NAME");
				if(table.charAt(6) == '_' && !table.startsWith("MDI005_") && !table.contains("REPORT")){
					Class<DataAccessObject> c = getClassByDBTable(table);
					if(c !=null)
						allClasses.add(c);
				}
    		}
    		rs.close();
    	}
    	return allClasses;
    }
    
    private static Vector<Class<DataAccessObject>> allSpiClasses;
    
    public static Vector<Class<DataAccessObject>> getAllSpiObjects() throws SQLException{
    	if(allSpiClasses == null){
    		allSpiClasses = new Vector<Class<DataAccessObject>>();
    		DatabaseMetaData dbmd = PDBConnection.getInstance().getConnection().getMetaData();
    		ResultSet rs = dbmd.getTables(null,PDBConnection.SCHEMA,"MDIS%_%",new String[]{"TABLE"});
    		while(rs.next()){
				String table = rs.getString("TABLE_NAME");
				if(table.charAt(6) == '_' && !table.startsWith("MDI005_") && !table.contains("REPORT")){
					Class<DataAccessObject> c = getClassByDBTable(table);
					if(c !=null)
						allSpiClasses.add(c);
				}
    		}
    		rs.close();
    	}
    	return allClasses;
    }
    
    public static Date getDate(Calendar cal) {
		if(cal == null)
			return null;
		return new Date(cal.getTimeInMillis());
	}
    
    public static Calendar getCalendar(Date date){
    	if(date == null)
    		return null;
    	Calendar cal = Calendar.getInstance();
		cal.setTime(date);
    	return cal;
    }
    
    public static Calendar getCalendar(Timestamp ts){
    	if(ts == null)
    		return null;
    	Calendar cal = Calendar.getInstance();
		cal.setTime(ts);
    	return cal;
    }
    
    public static Timestamp getTimestamp(Calendar cal){
    	if(cal == null)
    		return null;
    	return new Timestamp(cal.getTimeInMillis());
    }
    
    public static Object getId(int id){
    	if(id == 0)
    		return null;
    	return id;
    }
    public static void sleep(int millis){
    	try {
			Thread.sleep(millis);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
    }
    public Vector<String> getDifference(DataAccessObject dao){
    	return new Vector<String>();
    }
    public void copyChildrenTo(DataAccessObject cp){
    }
}
