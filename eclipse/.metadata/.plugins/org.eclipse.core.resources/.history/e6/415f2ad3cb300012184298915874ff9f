/*
 * Copyright (c) 2002-2010 ESP Suite. All Rights Reserved.
 *
 *     
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Authors: Technology Integration Group, SCE
 * Developers: Eddie Mayfield, Frank Gonzales, Augustin Muniz,
 * Kate Suwan, Hiro Kushida, Andrew McNaughton, Brian Stonerock,
 * Russell Ragsdale, Patrick Ridge, Everett Aragon.
 * 
 */
package com.sce.esp.hst;

import java.sql.SQLException;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Locale;
import java.util.TimeZone;
import java.util.Vector;

import com.sce.esp.object.model.Sub;

/**
 * @author FTT
 *
 */
public abstract class NeuralNetForecast {
	
	private NeuralNetwork nn;

	protected String[][] trainingSet;
	protected double[] trainingActual;
	protected double[] trainingResult;

	protected String[][] testSet;
	protected double[] testActual;
	protected double[] testResult;

	protected String[][] predictSet;
	protected double[] predictResult;

	protected double[] trainingTime;
	protected double[] testTime;
	protected double[] predictTime;

	protected String [] trainingTimeString;
	protected String [] testTimeString;
	protected String [] predictTimeString;

	private double tolerant = 0.0005;
	
	protected void trainANN(Effect effect, String[][] data){
		
		//System.out.println("+++TRAINING+++");
		
		int monthEffect=0;
		int weekdayEffect=0;
		int weekendEffect=0;
		int hourEffect=0;	
		int tempratureEffect=0;
		int windEffect=0;
		
		double       rate = effect.getRate();
		double      alpha = effect.getAlpha();
		int 	     epochs = effect.getEpochs();
		int 	      nodes = effect.getNodes();
		int 		type=effect.getType();

		if(effect.getMonthEffect()) monthEffect=1;
		if(effect.getWeekdayEffect()) weekdayEffect=1;
		if(effect.getWeekendEffect()) weekendEffect=1 ;
		if(effect.getHourEffect()) hourEffect=1;
		if(effect.getTempratureEffect()) tempratureEffect=1;
		if(effect.getWeekendEffect()) windEffect=1;		

		int columns = monthEffect+weekdayEffect+weekendEffect+hourEffect+tempratureEffect+windEffect;
		double[][] input=new double[data.length][columns];
		Calendar calendar = new GregorianCalendar();
		calendar.setTimeZone(TimeZone.getDefault());
		SimpleDateFormat formatter = new SimpleDateFormat ("MM-dd-yyyy",Locale.US);
		formatter.setTimeZone(TimeZone.getDefault());

		for(int i=0;i<data.length;i++){
			ParsePosition pos = new ParsePosition(0);
			Date startDate = formatter.parse(data[i][0], pos);
			calendar.setTime(startDate);
			if(monthEffect==1)
				input[i][0]=calendar.get(Calendar.MONTH);
			if(weekdayEffect==1)
				input[i][monthEffect]=calendar.get(Calendar.DAY_OF_WEEK);
			if(weekendEffect==1){
				if(calendar.get(Calendar.DAY_OF_WEEK)==1||calendar.get(Calendar.DAY_OF_WEEK)==7)
					input[i][monthEffect+weekdayEffect] = 1;
				else
					input[i][monthEffect+weekdayEffect] = 0;
			}
			if(hourEffect==1)
				input[i][monthEffect+weekdayEffect+weekendEffect] = Integer.valueOf(data[i][1]).intValue();

			if(tempratureEffect==1){
				input[i][monthEffect+weekdayEffect+weekendEffect+hourEffect] =Double.valueOf(data[i][2]).doubleValue();
			}
			if(windEffect==1){
				input[i][monthEffect+weekdayEffect+weekendEffect+hourEffect+tempratureEffect] = Double.valueOf(data[i][3]).doubleValue();
			}
		}
		
		double[][] output=new double[data.length][1];
		for(int i=0;i<data.length;i++){
			output[i][0] = Double.valueOf(data[i][3]).doubleValue();			
		} 
		
		double[] index=new double[data.length];
		for(int i=0;i<data.length-1;i++){
			index[i] = i;
		} 
		
		trainingTime  =DataSetFactory.createTimeSet(data);		 			

		trainingTimeString  =DataSetFactory.getTimeString(data);		 			

		DataSet ds=new DataSet(index,trainingTime,input,output);
		ds.normalize(0,1,0,1);

		nn=new NeuralNetwork(ds,type,nodes,epochs,rate,alpha,tolerant);

		nn.train();
		trainingResult=ds.getPredictCol(0);

		trainingActual =new double[output.length];
		for(int i=0;i<output.length;i++)
			trainingActual[i]=output[i][0];
		
	}	
	
	protected void testTraining(Effect effect, String[][] testSet) throws Exception{
		
		//System.out.println("====TEST===");
		
		double[][] inputValues =DataSetFactory.createInputSet(effect,testSet);
		double[][] outputValues=DataSetFactory.createOutputSet(testSet);
		double[] indexValues =DataSetFactory.createIndexSet(testSet);
		testTime  =DataSetFactory.createTimeSet(testSet);		
		testTimeString  =DataSetFactory.getTimeString(testSet);	
		
		//System.out.println("INPUT:"+inputValues[0][0]);
		//System.out.println("OUTPUT"+outputValues[0][0]);
		//System.out.println("TEST_t"+testTime[0]);
		//System.out.println("TEST_t_"+testTimeString[0]);

		DataSet ds=new DataSet(indexValues,testTime,inputValues,outputValues);

		ds.normalize(0,1,0,1);
		nn.setDataSet(ds);
		nn.predict();
		testResult=ds.getPredictCol(0);		

		testActual =new double[outputValues.length];
		for(int i=0;i<outputValues.length;i++)
			testActual[i]=outputValues[i][0];
	}
	
	public double[] getPredictionResults(){
		return predictResult;
	}
	
	
	protected void predict(Effect effect, String[][] predictSet) throws Exception{
		//System.out.println("===PREDICTION===");
		double[][] inputValues =DataSetFactory.createInputSet(effect,predictSet);
		double[] indexValues =DataSetFactory.createIndexSet(predictSet);
		predictTime  =DataSetFactory.createTimeSet(predictSet);		
		predictTimeString  =DataSetFactory.getTimeString(predictSet);		 			

		double[][] outputValues= new double[inputValues.length][1];

		DataSet ds=new DataSet(indexValues,predictTime,inputValues,outputValues);

		ds.normalize(0,1,0,1);
		nn.setDataSet(ds);
		nn.predict();
		predictResult=ds.getPredictCol(0);		
		
		for (int i=0;i<predictResult.length;i++ )
		{
			//System.out.println("i="+predictResult[i]);
			//forecastVector.add(predictResult[i]);
		}
		
		//displayPredicted();
	}	
	
	/**
	 * @return the forecast object's <code>Sub</code> object.
	 * @throws SQLException
	 */
	public abstract Sub getSub() throws SQLException;
	
	/**
	 * @return the incremental date as a Calendar object.
	 */
	public abstract Calendar getDate();
	
	/**
	 * @return the linear regression forecast calculation results
	 * @throws SQLException
	 */
	public abstract Vector<Double> getLRForecast() throws SQLException;
	
	/**
	 * 
	 * @return
	 * @throws SQLException
	 */
	public abstract double getPLL() throws SQLException;
	
	/**
	 * Run the Artificial Neural Network Forecast Calculation
	 * @throws SQLException
	 */
	public abstract void runANN()throws SQLException;
}
