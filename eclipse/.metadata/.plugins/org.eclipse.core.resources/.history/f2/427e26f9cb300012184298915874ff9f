/**
 *           | Master Data Interface Version 2.0 |
 *
 * Copyright (c) 2006, Southern California Edison, Inc.
 * 					   Distribution Staff Engineering Team.
 * 	                   All rights reserved.
 *
 * This software has been developed exclusively for internal usage.
 * Unauthorized use is prohibited.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package com.sce.esp.object.model;
import java.io.Serializable;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Collection;
import java.util.TreeSet;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.NamedNativeQueries;
import javax.persistence.NamedNativeQuery;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;

import com.sce.esp.object.dao.SimSubDAO;
import com.sce.esp.object.jpa.AutoInsertable;
import com.sce.esp.util.db.PDBConnection;
@Entity
@AutoInsertable
@Table(schema="MDI",name="MDI115_SIM_SUB")
@NamedQueries({
	@NamedQuery(name = "findByID", query="SELECT o FROM SimSub o WHERE o.PLANYEAR=?1 AND o.SIM_ID=?2 AND o.SUB_ID=?3"),//AUTO-GENERATED
	@NamedQuery(name = "findAll", query="SELECT o FROM SimSub o"),//AUTO-GENERATED
	@NamedQuery(name = "findAllActive", query="SELECT o FROM SimSub o WHERE o.DELETED_TS IS NULL"),//AUTO-GENERATED
	@NamedQuery(name = "findByProj", query="SELECT o FROM SimSub o WHERE o.PLANYEAR=?1 AND o.SIM_ID=?2 AND o.PROJ_ID=?3 AND o.DELETED_TS IS NULL"),//AUTO-GENERATED
})
@NamedNativeQueries({
	@NamedNativeQuery(name = "refresh", query="SELECT o.* FROM MDI115_SIM_SUB o WHERE o.PLANYEAR=? AND o.SIM_ID=? AND o.SUB_ID=?"),//AUTO-GENERATED
})
public class SimSub extends SimSubDAO implements Serializable{
	
	private static final long serialVersionUID = -3773398043881644263L;

	/** The norm SP. */
	private double normSP;

	/** The last SP set. */
	private long lastSPSet;

	private TreeSet<Bbank> bBanks;

	public SimSub(){
	}
	public SimSub(int planyear, int simId, int subId){
		super(planyear,simId,subId);
	}

	public SimSub(SimSub simSub) {
		super(simSub);
	}

	/**
	 * Gets the status.
	 *
	 * @return the status
	 *
	 * @throws SQLException the SQL exception
	 */
	public String getStatus()throws SQLException{
		return getSub().getYear(getSimId(), getPlanyear()-1).getStatus();
	}

	/**
	 * Gets the starting point.
	 *
	 * @return the starting point
	 *
	 * @throws SQLException the SQL exception
	 */
	public double getStartingPoint()throws SQLException{
		if(isUseAlt())
			return getAltAdjPeak();
		return getNormStartingPoint();
	}
	
	
	/*
	 * (non-Javadoc)
	 * @see com.sce.esp.object.dao.SimSubDAO#isUseAlt()
	 */
	@Column(name="USE_ALT",nullable=true,length=1)
	public boolean isUseAlt(){
		return (super.isUseAlt() || this.getPeakDate() == null);
	}

	/**
	 * Gets the norm starting point.
	 *
	 * @return the norm starting point
	 *
	 * @throws SQLException the SQL exception
	 */
	public double getNormStartingPoint()throws SQLException{
		if(System.currentTimeMillis() - lastSPSet > 30000)
			refreshNormStartingPoint();
		return normSP;
	}

	/**
	 * Refresh norm starting point.
	 *
	 * @throws SQLException the SQL exception
	 */
	public void refreshNormStartingPoint()throws SQLException{
		if(getPeakDate() != null)
			normSP = getSub().getDailyPeak(getPeakDate(),true).getAdjPeak();
		else
			normSP = 0;
		lastSPSet = System.currentTimeMillis();
	}

	/**
	 * BME Should this be on your parents peak day?
	 * 
	 * Gets the coin factor.
	 *
	 * @return the coin factor
	 *
	 * @throws SQLExcpetion 	 
	 * @throws SQLException the SQL exception
	 */
	public double getCoinFactor()throws SQLException{
		if(getPeakDate() != null)
			return getSub().getDailyPeak(getPeakDate()).getCoinFactor();
		return 1;
	}

	/**
	 * Gets the projects.
	 *
	 * @param simId      *
	 *
	 * @return the projects
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<Proj> getProjects()throws SQLException{
		TreeSet<Proj> projects = new TreeSet<Proj>(getRealProjects());
		projects.addAll(getGhostProjects());
		return projects;
	}

	/**
	 * Gets the real projects.
	 *
	 * @param simId      
	 *
	 * @return the real projects
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<Proj> getRealProjects()throws SQLException{
		TreeSet<Proj> projs = new TreeSet<Proj>();
		for(Proj proj:getSub().getProjs())
			if(proj.getSimId() == getSimId())
				projs.add(proj);
		return projs;
	}

	/**
	 * Gets the ghost projects.
	 *
	 * @param simId      *
	 *
	 * @return the ghost projects
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<Proj> getGhostProjects()throws SQLException{
		TreeSet<Proj> projects = new TreeSet<Proj>();
		if(getSimId() > 0){
			int bs = 0;
			if(Simulation.getInstance(getPlanyear(),getSimId())!=null)
				bs = Simulation.getInstance(getPlanyear(),getSimId()).getBaseSimId();
			for(Proj p:getInstance(getPlanyear(),bs,getSubId()).getProjects())
				projects.add(Proj.getInstance(getPlanyear(),getSimId(),p.getProjId()));
		}
		return projects;
	}

	public TreeSet<CritExcept> getCritExcepts(Collection<Program> progs)throws SQLException{
		if(progs == null)
			return getCritExcepts();
		TreeSet<CritExcept> crits = new TreeSet<CritExcept>();
		for(CritExcept crit:getCritExcepts()){
			
			if(crit.getProgExcept()!=null && crit.getProgExcept().getProgram()!=null)//XXX DSP/TSP null?
			if(progs == null || progs.contains(crit.getProgExcept().getProgram()))
				crits.add(crit);
		}
		return crits;
	}
	
	public TreeSet<CritExcept> getCritExceptsActive(Collection<Program> progs)throws SQLException{
		if(progs == null)
			return getCritExceptsActive();
		TreeSet<CritExcept> crits = new TreeSet<CritExcept>();
		for(CritExcept crit:getCritExceptsActive()){
			
			if(crit.getProgExcept()!=null && crit.getProgExcept().getProgram()!=null)//XXX DSP/TSP null?
			if(progs == null || progs.contains(crit.getProgExcept().getProgram()))
				crits.add(crit);
		}
		return crits;
	}
	/**
	 * Gets the crit excepts.
	 *
	 * @return progElems
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<CritExcept> getCritExcepts()throws SQLException{
		TreeSet<CritExcept> critExs = new TreeSet<CritExcept>(getRealCritExcepts());
		critExs.addAll(getGhostCritExcepts());
		return critExs;
	}
	/**
	 * Gets the crit excepts.
	 *
	 * @return progElems
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<CritExcept> getCritExceptsActive()throws SQLException{
		TreeSet<CritExcept> critExs = new TreeSet<CritExcept>();
		for(CritExcept ce:getRealCritExcepts()){
			if(!ce.isDisabled())
				critExs.add(ce);
		}
		for(CritExcept ce:getGhostCritExcepts()){
			if(!ce.isDisabled())
				critExs.add(ce);
		}
		return critExs;
	}
	
	/**
	 * Gets the real crit excepts.
	 *
	 * @param simId 	 *
	 *
	 * @return the real crit excepts
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<CritExcept> getRealCritExcepts()throws SQLException{
		TreeSet<CritExcept> critExcepts = new TreeSet<CritExcept>();
		for(CritExcept ce:getSub().getCritExcepts())
			if(ce.getSimId() == getSimId())
				critExcepts.add(ce);
		return critExcepts;
	}

	/**
	 * Gets the ghost crit excepts.
	 *
	 * @param simId      *
	 *
	 * @return the ghost crit excepts
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<CritExcept> getGhostCritExcepts()throws SQLException{
		TreeSet<CritExcept> critExs = new TreeSet<CritExcept>();
		if(getSimId() > 0) {
			for(CritExcept ce : getInstance(getPlanyear(),Simulation.getInstance(getPlanyear(),getSimId()).getBaseSimId(),getSubId()).getCritExcepts())
				critExs.add(CritExcept.getInstance(getPlanyear(),getSimId(),ce.getExceptId()));
		}
		return critExs;
	}

	/**
	 * Gets the active ties.
	 *
	 * @return the active ties
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<BbankTie> getActiveTies()throws SQLException{
		TreeSet<BbankTie> at = new TreeSet<BbankTie>(getActiveFromTies());
		at.addAll(getActiveToTies());
		return at;
	}

	public TreeSet<DirectedTie> getActiveDirectedTies()throws SQLException{
		TreeSet<DirectedTie> dts = new TreeSet<DirectedTie>();
		for(BbankTie tie:getActiveFromTies())
			dts.add(new DirectedTie(tie,true));
		for(BbankTie tie:getActiveToTies())
			dts.add(new DirectedTie(tie,false));
		return dts;
	}

	public TreeSet<DirectedTie> getDirectedTies()throws SQLException{
		TreeSet<DirectedTie> dts = new TreeSet<DirectedTie>();
		for(BbankTie tie:getFromTies())
			dts.add(new DirectedTie(tie,true));
		for(BbankTie tie:getToTies())
			dts.add(new DirectedTie(tie,false));
		return dts;
	}

	/**
	 * Gets the active from ties.
	 *
	 * @return toTies
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<BbankTie> getActiveFromTies()throws SQLException{
		TreeSet<BbankTie> at = new TreeSet<BbankTie>();
		for(BbankTie bt:getFromTies())
			if(!bt.isDisabled())
				at.add(bt);
		return at;
	}

	/**
	 * Gets the from ties.
	 *
	 * @return the from ties
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<BbankTie> getFromTies()throws SQLException{

		TreeSet<BbankTie> fTies = new TreeSet<BbankTie>();
		if(getSub() instanceof Bbank) {
			for(BbankTie b: ((Bbank)getSub()).getBbankTies()){
				if(b.getSimId()==getSimId())
					fTies.add(b);
			}
		}
		if(getSimId() > 0){
			int bs=0;
			Simulation sim = Simulation.getInstance(getPlanyear(),getSimId());
			if(sim != null)
				bs = sim.getBaseSimId();
			for(BbankTie tie:SimSub.getInstance(getPlanyear(),bs,getSubId()).getFromTies())
				fTies.add(BbankTie.getInstance(getPlanyear(),getSimId(),tie.getTieId()));
		}
		return fTies;
	}

	/**
	 * Gets the active to ties.
	 *
	 * @return formTies
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<BbankTie> getActiveToTies()throws SQLException{
		TreeSet<BbankTie> at = new TreeSet<BbankTie>();
		for(BbankTie bt:getToTies())
			if(!bt.isDisabled())
				at.add(bt);
		return at;
	}

	/**
	 * Gets the to ties.
	 *
	 * @return the to ties
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<BbankTie> getToTies()throws SQLException{
		TreeSet<BbankTie> tTies = new TreeSet<BbankTie>();
		if(getSub() instanceof Bbank) {
			for(BbankTie b2: ((Bbank)getSub()).getBbankTies2()){
				if(b2.getSimId()==getSimId())
					tTies.add(b2);
			}
		}
		if(getSimId() > 0){
			int bs=0;
			Simulation sim = Simulation.getInstance(getPlanyear(),getSimId());
			if(sim != null)
				bs = sim.getBaseSimId();
			for(BbankTie tie:SimSub.getInstance(getPlanyear(),bs,getSubId()).getToTies())
				tTies.add(BbankTie.getInstance(getPlanyear(),getSimId(),tie.getTieId()));
		}
		return tTies;
	}

	/**
	 * Gets the A banks.
	 *
	 * @return the A banks
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<Abank> getAbanks()throws SQLException{
		TreeSet<Abank> aBanks = new TreeSet<Abank>();
		if(getSub() instanceof Abank)
			aBanks.add((Abank)getSub());
		else {
			for(int x=0; x<User.getActiveUser().getPlanFor(getPlanyear(),getSimId()); x++)
				aBanks.add(((BbankYear)getSub().getYear(getSimId(),getPlanyear()+x-1)).getAbank());
		}
		return aBanks;
	}
	public TreeSet<Abank> getAbanks(SubFilter filter)throws SQLException{
		TreeSet<Abank> abs = new TreeSet<Abank>();
		for(Abank ab:getAbanks())
			if(filter==null || filter.meetsCriteria(ab, getSimId()))
				abs.add(ab);
		return abs;
	}

	/**
	 * Gets the down stream subs.
	 *
	 * @return the down stream subs
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<Bbank> getDownStreamSubs()throws SQLException {
		return getDownStreamSubs(null);
	}


	public TreeSet<Bbank> getDownStreamSubs(SubFilter subFilter)throws SQLException {
		TreeSet<Bbank> ds = new TreeSet<Bbank>();
		for(Bbank bBank:getBbanks()){
			if(subFilter == null || subFilter.meetsCriteria(bBank, getSimId()))
				ds.add(bBank);
			ds.addAll(SimSub.getInstance(getPlanyear(), getSimId(), bBank.getSubId()).getDownStreamSubs(subFilter));
		}
		return ds;
	}

	/**
	 * Checks for B banks been read.
	 *
	 * @return true, if has B banks been read
	 */
	public boolean hasBbanksBeenRead(){
		return bBanks!=null;
	}

	/**
	 * getBBanks.
	 *
	 * @return Returns a Vector of directly connected BBanks
	 *
	 * @throws SQLException the SQL exception
	 */
	public synchronized TreeSet<Bbank> getBbanks()throws SQLException{
		if(bBanks == null)
			refreshBbanks();
		TreeSet<Bbank> bbs = bBanks;
		if(getSimId() > 0){
			bbs = new TreeSet<Bbank>(bBanks);
			int bs=0;
			Simulation sim = Simulation.getInstance(getPlanyear(),getSimId());
			if(sim != null)
				bs = sim.getBaseSimId();
			bbs.addAll(getInstance(getPlanyear(),bs,getSubId()).getBbanks());
		}
		return bbs;
	}
	public TreeSet<Bbank> getBbanks(SubFilter filter)throws SQLException{
		TreeSet<Bbank> bbs = new TreeSet<Bbank>();
		for(Bbank bb:getBbanks())
			if(filter == null || filter.meetsCriteria(bb, getSimId()))
				bbs.add(bb);
		return bbs;
	}

	/**
	 * Refresh B banks.
	 *
	 * @throws SQLException the SQL exception
	 */
	public void refreshBbanks()throws SQLException{
		if(bBanks == null)
			bBanks = new TreeSet<Bbank>();
		else
			bBanks.clear();
		String table = BbankYear.class.getAnnotation(Table.class).name();
		PreparedStatement ps = PDBConnection.getInstance().getConnection().prepareStatement("SELECT DISTINCT BBANK_SUB_ID FROM "+table+" WHERE PLANYEAR=? AND SIM_ID=? AND PARENT_SUB_ID=?");
		ps.setInt(1, getPlanyear());
		ps.setInt(2, getSimId());
		ps.setInt(3, getSubId());
		ResultSet rs = ps.executeQuery();
		while(rs.next())
			bBanks.add(Bbank.getInstance(getPlanyear(),rs.getInt("BBANK_SUB_ID")));
		rs.close();
		ps.close();
	}

	/**
	 * Gets the PRN.
	 *
	 * @return the PRN
	 *
	 * @throws SQLException the SQL exception
	 */
	public double getPRN()throws SQLException{
		return getPRN(isUseAlt());
	}

	/**
	 * Gets the norm PRN.
	 *
	 * @return the norm PRN
	 *
	 * @throws SQLException the SQL exception
	 */
	public double getNormPRN()throws SQLException{
		return getPRN(false);
	}

	/**
	 * Gets the alt PRN.
	 *
	 * @return the alt PRN
	 *
	 * @throws SQLException the SQL exception
	 */
	public double getAltPRN()throws SQLException{
		return getPRN(true);
	}

	/**
	 * Gets the PRN.
	 *
	 * @param userSp the user sp
	 *
	 * @return the PRN
	 *
	 * @throws SQLException the SQL exception
	 */
	public double getPRN(boolean userSp)throws SQLException{
		Double aplLC = (Double)getCachedValue("getPRN", userSp);
		if(aplLC==null){
			double sp = userSp?getAltAdjPeak():getNormStartingPoint();
			double sum=0;
			double value = 1;
			if(getSub() instanceof Abank){
				for(Bbank bBank:getSub().getYear(getSimId(),getPlanyear()-1).getBbanks())
					if(bBank.getSubType().isLoadServer())
						sum += bBank.getStartingPoint(getSimId());
			}
			else{
				for(Ckt ckt:getSub().getYear(getSimId(), getPlanyear()-1).getCkts())
					sum += ckt.getStartingPoint(getSimId());
			}
			if(sum == 0 || sp == 0)
				value = getUserPRN();
			else
				value = sp/sum;
			aplLC= value;
			setCachedValue(aplLC,"getPRN", userSp);
		}
		return aplLC;
		
	}
	
	
	public boolean isPRNEditable()throws SQLException{
		
		double sum=0;
		double sp = isUseAlt()?getAltAdjPeak():getNormStartingPoint();
		if(getSub() instanceof Abank){
			for(Bbank bBank:getSub().getYear(getSimId(),getPlanyear()-1).getBbanks())
				if(bBank.getSubType().isLoadServer())
					sum += bBank.getStartingPoint(getSimId());
		}
		else{
			for(Ckt ckt:getSub().getYear(getSimId(), getPlanyear()-1).getCkts())
				sum += ckt.getStartingPoint(getSimId());
		}
		return (sum == 0 || sp == 0);
	}
	
	
	//BME Change to new double Specified PRN when db changes
	public double getUserPRN(){
		try{
			if(getSub().getQfId()!=null)
				return Double.parseDouble(getSub().getQfId());
		}catch(Exception e){			
			System.out.println(" PRN: sub.qfId does not contain a valid double value, call EMM ");
		}
		return 1.0;
	}
	
	//BME Change to new double Specified PRN when db changes
	public void setUserPRN(double prn) throws SQLException{
		getSub().setQfId(""+prn);
	}


	/**
	 * Gets the move subs.
	 *
	 * @return the move subs
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<Bbank> getMoveSubs()throws SQLException{
		TreeSet<Bbank> ms = new TreeSet<Bbank>();
		for(Bbank bb:getBbanks())
			if(bb.hasHChange(getSimId()))
				ms.add(bb);
		return ms;
	}

	/**
	 * Checks for H change.
	 *
	 * @return true, if has H change
	 *
	 * @throws SQLException the SQL exception
	 */
	public boolean hasHChange()throws SQLException{
		//Lets first find out if this sub ever changes parents
		for(int year=getPlanyear(); year<getPlanyear()+User.getActiveUser().getPlanFor(getPlanyear(),getSimId()); year++)
			if(getSub().getYear(getSimId(), year-1).getParent() != getSub().getYear(getSimId(),year).getParent())
				return true;
		//If it never does we have to find out if any of it's children ever have a H change
		for(Bbank bb:getBbanks())
			if(bb.hasHChange(getSimId()))
				return true;
		//If we get here no H change is ever found so return false
		return false;
	}
	/**
	 * Returns the growth rate based on the planFor unless
	 * the lse does not have load in the first year.
	 *
	 * @return - Growth Rate
	 *
	 * @throws SQLException the SQL exception
	 */
	public double getGrowthRate()throws SQLException{
		Double aplLC = (Double)getCachedValue("getGrowthRate");
		if(aplLC==null){
			aplLC=0.0;
			double sp = getSub().getYear(getSimId(), getGrowthRateStartYear()).getProjLoad();
			if(sp!=0){
				double tg = 0;
				for(int y=1; y<=getGrowthRateRange(); y++)
					tg += getSub().getYear(getSimId(),getGrowthRateStartYear()+y).getGrowth();
				aplLC= Math.pow((sp+tg)/sp,1.0/(getGrowthRateRange()))-1;
			}
			setCachedValue(aplLC,"getGrowthRate");
		}
		return aplLC;
	}
	
	/**
	 * Returns the growth rate based on the planFor unless
	 * the lse does not have load in the first year.
	 *
	 * @return - Growth Rate
	 *
	 * @throws SQLException the SQL exception
	 */
	public double getGrowthRateHC()throws SQLException{
		Double aplLC = (Double)getCachedValue("getGrowthRateHC");
		if(aplLC==null){
			aplLC=0.0;
			double sp = getSub().getYear(getSimId(), getGrowthRateStartYear()).getProjLoadHC();
			if(sp!=0){
				double tg = 0;
				for(int y=1; y<=getGrowthRateRange(); y++)
					tg += getSub().getYear(getSimId(),getGrowthRateStartYear()+y).getGrowthHC();
				aplLC= Math.pow((sp+tg)/sp,1.0/(getGrowthRateRange()))-1;
			}
			setCachedValue(aplLC,"getGrowthRateHC");
		}
		return aplLC;
	}
	
	/**
	 * Returns the growth rate based on the planFor unless
	 * the lse does not have load in the first year.
	 *
	 * @return - Growth Rate
	 *
	 * @throws SQLException the SQL exception
	 */
	public double getGrowthRateLC()throws SQLException{
		Double aplLC = (Double)getCachedValue("getGrowthRateLC");
		if(aplLC==null){
			aplLC=0.0;
			double sp = getSub().getYear(getSimId(), getGrowthRateStartYear()).getProjLoadLC();
			if(sp!=0){
				double tg = 0;
				for(int y=1; y<=getGrowthRateRange(); y++)
					tg += getSub().getYear(getSimId(),getGrowthRateStartYear()+y).getGrowthLC();
				aplLC= Math.pow((sp+tg)/sp,1.0/(getGrowthRateRange()))-1;
			}
			setCachedValue(aplLC,"getGrowthRateLC");
		}
		return aplLC;
	}
	
	/**
	 * Returns the base growth rate based on the planFor unless
	 * the lse does not have load in the first year.
	 *
	 * @return - Growth Rate
	 *
	 * @throws SQLException the SQL exception
	 */
	public double getBaseGrowthRate(GrowthType gt)throws SQLException{
		Double aplLC = (Double)getCachedValue("getBaseGrowthRate", gt);
		if(aplLC==null){
			aplLC=0.0;
			double sp = getSub().getYear(getSimId(), getGrowthRateStartYear()).getProjLoad();
			if(sp!=0){
				double tg = 0;
				for(int y=1; y<=getGrowthRateRange(); y++)
					tg += getSub().getYear(getSimId(),getGrowthRateStartYear()+y).getGrowth(gt);
				aplLC= Math.pow((sp+tg)/sp,1.0/(getGrowthRateRange()))-1;
			}
			setCachedValue(aplLC,"getBaseGrowthRate", gt);
		}
		return aplLC;
	}

	public double getABankGrowthRate()throws SQLException{
		Double aplLC = (Double)getCachedValue("getABankGrowthRate");
		if(aplLC==null){
			aplLC=0.0;
			double sp = getSub().getYear(getSimId(), getGrowthRateStartYear()).getABankProjLoad();
			if(sp!=0){
				double tg = 0;
				for(int y=1; y<=getGrowthRateRange(); y++)
					tg += getSub().getYear(getSimId(),getGrowthRateStartYear()+y).getABankGrowth();
				aplLC= Math.pow((sp+tg)/sp,1.0/(getGrowthRateRange()))-1;
			}
			setCachedValue(aplLC,"getABankGrowthRate");
		}
		return aplLC;
	}

	/**
	 * Returns the first year the lse has load for the growth rate.
	 *
	 * @return - Growth Rate Start Year
	 *
	 * @throws SQLException the SQL exception
	 */
	public int getGrowthRateStartYear()throws SQLException{
		if(getInServiceDate()!=null && getInServiceDate().getTimeInMillis() > Department.getInstance(getPlanyear()).getNormalizationDate().getTimeInMillis())
			return getInServiceDate().get(Calendar.YEAR);
		return Department.getInstance(getPlanyear()).getNormalizationDate().get(Calendar.YEAR);
	}

	/**
	 * Returns the number of years used for the growth rate.
	 *
	 * @return Growth Rate Range
	 *
	 * @throws SQLException the SQL exception
	 */
	public int getGrowthRateRange()throws SQLException{
		if(Simulation.getInstance(getPlanyear(), getSimId())!=null)
			return Simulation.getInstance(getPlanyear(), getSimId()).getPlanFor() - (getGrowthRateStartYear() - getPlanyear() + 1);
		return 10; //default to ten years
	}

	/**
	 * Gets the syss.
	 *
	 * @return the syss
	 *
	 * @throws SQLException the SQL exception
	 */
	public TreeSet<Sys> getSyss()throws SQLException{
		TreeSet<Sys> syss = new TreeSet<Sys>();
		for(int x=0; x<Department.getInstance(getPlanyear()).getPlanFor(); x++){
			Sys sys = getSub().getYear(getSimId(),getPlanyear()+x-1).getSys();
			if(sys != null)
				syss.add(sys);
		}
		return syss;
	}
	public TreeSet<Sys> getSyssSCE()throws SQLException{
		TreeSet<Sys> syss = new TreeSet<Sys>();
		for(int x=0; x<Department.getInstance(getPlanyear()).getPlanFor(); x++){
			Sys sys = getSub().getYear(getSimId(),getPlanyear()+x-1).getSys();
			if(sys != null && !sys.isForeignSys())
				syss.add(sys);
		}
		return syss;
    }
	public boolean isN1Approved()throws SQLException{
		return ((Bbank)getSub()).isN1Approved();
	}

	public double getPll()throws SQLException{
		return getNameplate()*getPllFactor();
	}
	
	/**
	 * Sets the peak date and sets user specified false if peak date was null
	 * Sets the peakDate
	 * @param The new peakDate
	 */
	public void setPeakDateBL(java.util.Calendar peakDate)throws SQLException{
		if(isSame(peakDate,getPeakDate())) return;
		boolean tricky = (getPeakDate()==null);		
		super.setPeakDate(peakDate);
		if(tricky)
			setUseAlt(false);
		if(getSub() instanceof Bbank)
			for(Ckt c:getSub().getYear(getSimId(), getPlanyear()-1).getCkts())
				c.setPeakDate(getSimId(), peakDate);
	}

	public SubDaily getPeakDailyPeak() throws SQLException{
		return SubDaily.getInstance(getPlanyear(),getSubId(),getPeakDate(),true);
	}

	public double getAdjustedPeak() throws SQLException {
		if(getPeakDailyPeak() != null)
			return getPeakDailyPeak().getAdjPeak();
		return 0;
	}

	public double getActualPeak() throws SQLException {
		if(getPeakDailyPeak() != null)
			return getPeakDailyPeak().getActualPeak();
		return 0;
	}

	public double getRecordedPeak() throws SQLException {
		if(getPeakDailyPeak() != null)
			return getPeakDailyPeak().getRecordedPeak();
		return 0;
	}

	public double getPeakAdjustment() throws SQLException {
		if(getPeakDailyPeak() != null)
			return getPeakDailyPeak().getPeakAdjustment();
		return 0;
	}
	
	public double getGenAdjustment() throws SQLException {
		if(getPeakDailyPeak() != null)
			return getPeakDailyPeak().getGenAdjustment();
		return 0;
	}
}
